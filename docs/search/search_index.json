{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".mono { font-family: monospace; } .mono { font-family: monospace; } What is snorer about? \u00b6 snorer , stands for S upernova- N eutrino-b O osted da R k matt ER , is a package for evaluating time-of-flight signatures of supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) from our Milky Way, SN1987a in Large Magellanic Cloud and SN in arbitrary distant galaxy. Citation \u00b6 If you use this package or part of the code in your research, please cite the followings: Y.-H. Lin et al. , Phys. Rev. Lett. 130 , 111002 (2023) [arXiv:2206.06864] Y.-H. Lin et al. , Phys. Rev. D 108 , 083013 (2023) [arXiv:2307.03522] snorer : https://github.com/yenhsunlin/snorer Installation \u00b6 To install, excute the following command on the prompt: $ pip install snorer and everything should be processed on-the-fly. Prerequisites \u00b6 snorer requires python >= 3.8 and the following dependencies: numpy >= 1.20 scipy >= 1.10 vegas >= 6.0 astropy >= 6.0 where vegas is a the backend engine for evaluating multidimensional integrals based on adaptive Monte Carlo vegas algorithm, see for detail. Other dependencies may be required by these packages and will be installed as well. Getting started \u00b6 snorer can be imported like any other packages import snorer as sn # Import snorer functions Assuming the following locations: Distance between Earth and galactic center: \\(R_e=8.5\\) kpc Distance between Earth and SN: \\(R_s=8.5\\) kpc The angle \\(\\beta=0\\) and DM properties: Mass \\(m_\\chi=0.001\\) MeV Kinetic energy \\(T_\\chi=15\\) MeV Evaluating flux \u00b6 Suppose we want to evaluate the BDM flux at \\(t=100\\) seconds after the observation of SN \\(\\nu\\) , then >>> t,Tx,mx,Rstar,beta = 100,15,1e-2,8.5,0 # Collecting parameters >>> flux = sn.flux(t,Tx,mx,Rstar,beta,is_spike=True,neval=15000) # Evaluating flux, 1/MeV/cm^2/s >>> print(flux) 4.572295175982701e-16 The parameter is_spike determines whether DM spike in the central region of the halo is considered and neval dictates how many samples will be generated by vegas in each chain. The default value for DM- \\(\\nu\\) cross section \\(\\sigma_{\\chi\\nu}=10^{-45}\\) cm 2 . See also snorer.flux . Evaluating event \u00b6 Assuming the main target to scatter with BDM in the detector is electron, the following function evaluating the event number per second per electron. The default value for DM- \\(\\nu\\) cross section \\(\\sigma_{\\chi\\nu}=10^{-45}\\) cm 2 but DM- e cross section \\(\\sigma_{\\chi e}\\) is normalized to 1 cm 2 . >>> mx,Rstar,beta = 1e-2,8.5,0.3 # Collecting parameters >>> event = sn.event(mx,Rstar,beta,is_spike=True,neval=30000) # Evaluating BDM event per electron with sigma_xe = 1 cm^2 >>> print(event) 4.6009089186164447e-07 Given the previous setup, event is the event number per electron for \\(\\sigma_{\\chi e}=1\\) cm 2 . Suppose there are \\(N_e\\) electrons in the detector and the true cross sections are \\(\\sigma_{\\chi\\nu}^{\\rm true}\\) and \\(\\sigma_{\\chi e}^{\\rm true}\\) , the total event number in this detector is $$ N_\\chi^{\\rm tot} = \\texttt{event} \\times \\frac{N_e}{1}\\times \\frac{\\sigma_{\\chi e}^{\\rm true}}{1 \\,{\\rm cm^2}} \\times \\frac{\\sigma_{\\chi\\nu}^{\\rm true}}{10^{-45}\\,{\\rm cm^2}}. $$ See also snorer.event . Reporting bug(s) \u00b6 Please report to Yen-Hsun Lin via yenhsun@phys.ncku.edu.tw","title":"Introduction"},{"location":"#what-is-snorer-about","text":"snorer , stands for S upernova- N eutrino-b O osted da R k matt ER , is a package for evaluating time-of-flight signatures of supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) from our Milky Way, SN1987a in Large Magellanic Cloud and SN in arbitrary distant galaxy.","title":"What is snorer about?"},{"location":"#citation","text":"If you use this package or part of the code in your research, please cite the followings: Y.-H. Lin et al. , Phys. Rev. Lett. 130 , 111002 (2023) [arXiv:2206.06864] Y.-H. Lin et al. , Phys. Rev. D 108 , 083013 (2023) [arXiv:2307.03522] snorer : https://github.com/yenhsunlin/snorer","title":"Citation"},{"location":"#installation","text":"To install, excute the following command on the prompt: $ pip install snorer and everything should be processed on-the-fly.","title":"Installation"},{"location":"#getting-started","text":"snorer can be imported like any other packages import snorer as sn # Import snorer functions Assuming the following locations: Distance between Earth and galactic center: \\(R_e=8.5\\) kpc Distance between Earth and SN: \\(R_s=8.5\\) kpc The angle \\(\\beta=0\\) and DM properties: Mass \\(m_\\chi=0.001\\) MeV Kinetic energy \\(T_\\chi=15\\) MeV","title":"Getting started"},{"location":"#reporting-bugs","text":"Please report to Yen-Hsun Lin via yenhsun@phys.ncku.edu.tw","title":"Reporting bug(s)"},{"location":"api/constants/Constants/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Constants \u00b6 class snorer.Constants() \u00b6 A data class stores many physical constants and coversion factors for convenient use. Attributes: perMeV2cm : float Convert MeV to MeV \u22121 to cm md2MeVperCubicCM : float Convert \\(M_\\odot\\) kpc \u22123 to MeV cm \u22123 year2Seconds : int Convert one year to seconds erg2MeV : int Convert erg to MeV kpc2cm : float Convert kiloparsec to cm me : float Electron mass, MeV mn : float Neutron mass, MeV mp : float Proton mass, MeV Msun : float Solar mass, MeV Msun_kg : float Solar mass, kg Mmw : float Stellar mass in Milky Way, Msun (halo not included) Mhalo : float Dark matter halo mass in Milky Way, Msun Rhalo : float Halo radius, kpc sigma0 : float Constant cross section, cm 2 c : int Speed of light, cm s \u22121 sigma0 : float Constant cross section, cm 2 H0 : float Hubble constant, km Mpc \u22121 s \u22121 rho_c : float Critical densityt \\(\\rho_c\\) in cosmology, \\(M_\\odot\\) pc \u22123 Lv : float Neutrino luminosity, divided by 10 seconds, for single species, total six (3 \\(\\nu\\) and 3 \\(\\bar{\\nu}\\) ), erg s \u22121 Omega_0m : float Cosmological matter fraction Omega_0L : float Cosmological dark energy fraction Omega_0r : float Cosmological radiation fraction Omega_0 : float Cosmological total energy, 1 D_H0 : float Cosmological distance, Mpc G : float Gravitational constant, pc \\(M_\\odot^{-1}\\) kms 2 s \u22121 SgrA_coord : list Sagittarius A* coordinate and distance, [ str , str , float ] = [RAC,DEC,kpc] LMC_coord : list Coordinate for Large Magellanic Cloud center and distance, [ str , str , float ] = [RAC,DEC,kpc] SN1987a_coord : list SN1987a coordinate and distance, [ str , str , float ] = [RAC,DEC,kpc] Examples Import snorer and do >>> import snorer as sn >>> sn.Constants().perMeV2cm # Convert 1/MeV to cm 1.973e-11 >>> sn.Constants().SgrA_coord # Sgr A J2000 coordinate and its distance in kpc ['17h45m40.0383s', '-29d00m28.069s', 8.13] For simplicity, one can also call the constants and conversion factors by >>> sn.constant.perMeV2cm 1.973e-11 Both Constants and constant are equivalent and is related by constant = Constants() .","title":"Constants"},{"location":"api/constants/Constants/#snorerconstants","text":"","title":"snorer.Constants"},{"location":"api/geometry/Geometry/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Geometry \u00b6 class snorer.Geometry( l , theta , phi , Rs , Re , beta ) \u00b6 The class constructs the static geomatrical relations for \\(d\\) , \\(r^\\prime\\) and \\(\\cos\\psi\\) when \\((l,\\theta,\\phi)\\) and \\((R_s,R_e,\\beta)\\) are specified. See Positioning for more detail. Parameters: l : array_like The line-of-sight distance, kpc theta : array_like The zenith angle \\(\\theta\\) at Earth, centers SN, rad phi : array_like Azimuthal angle \\(\\varphi\\) at Earth, centers SN, rad Rs : array_like Distance from Earth to SN, kpc Re : array_like Distance from Earth to GC, kpc beta : array_like Off-center angle \\(\\beta\\) , rad Attributes: d : scalar/ndarray Distance from SN to boost point \\(d\\) , kpc rprime : scalar/ndarray Distance from GC to boost point \\(r^\\prime\\) , kpc cos_psi : scalar/ndarray \\(\\cos\\psi\\) at boost point where \\(\\psi\\) is the direction for BDM at B pointing Earth Examples Import snorer and do >>> l,theta,phi,Rs,Re,beta = 5.160e-9,1e-4,0,11.6,8.5,0.71 # specify quantities >>> bdmGeo = Geometry(l,theta,phi,Rs,Re,beta) >>> print(bdmGeo.d) # SN to boost point 11.59999999483988 >>> print(bdmGeo.rprime) # GC to boost point 8.49999999608676 >>> print(bdmGeo.cos_psi) # cos(psi) 0.9999999721078604","title":"Geometry"},{"location":"api/geometry/Geometry/#snorergeometry","text":"","title":"snorer.Geometry"},{"location":"api/geometry/Positioning/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; Positioning \u00b6 To position the BDM signals, cf. Fig. 1 in BDM Physics , we have to analyze the geometry of propagation in order to get how large the emissivity is at B. Once the geometrical relations are understood, we can proceed to construct a class that solve this matter on-the-fly. See also Ref. [ 1 ] and note that we slightly modify the notations in this document for transparency. Geometry \u00b6 We replot Fig. 1 in BDM Physics and leaves only relevant information in the following Fig. 1 . Three coplanar points S, G and E remained the same. Repeated quantities are the same while we also mark addditional auxiliary terms which their purposes will be clear soon. Figure 1. The geometry of BDM propagation. By examining the blue and green triangles, we have \\[ \\begin{align} h &= \\ell \\sin\\theta \\\\ b &= \\ell \\cos\\theta. \\end{align} \\] Moreover, blue and brown triangles are identical, as brown one simply rotates around axis \\(\\overline{\\mathsf{SE}}\\) by \\(\\varphi\\) . See Fig. 2 . Figure 2. Blue and brown triangles are identical. Suppose B is distant \\(r\\) away from G, then B\u2032 is \\(r^\\prime\\) . It says that \\(r\\) is a special case of \\(r^\\prime\\) when \\(\\varphi=0\\) . This is curcial that when SN is not at the GC, DM number density \\(n_\\chi\\) is not spherical symmetric relative to SN. To resolve the correct \\(j_\\chi\\) at boost point, one needs to know \\(n_\\chi(r^\\prime(\\varphi))\\) . Figure 3. Another set of auxiliary triangles. We draw another set of auxiliary triangles in Fig. 3 , also cf. Fig. 1 , and immediately see that, left figure, \\[ \\begin{equation}\\label{eq:rprime} r^{\\prime2} = a^2 + h^2\\cos^2\\varphi \\end{equation} \\] while \\[ \\begin{equation} a^2 = (\\rho\\sin\\delta - h\\sin\\varphi)^2 + \\rho^2\\cos^2\\delta \\end{equation} \\] and, from law of cosine, the right figure gives, \\[ \\begin{equation} \\rho = \\sqrt{b^2+R_e^2 - 2b R_e \\cos\\beta}. \\end{equation} \\] To determine \\(\\delta\\) , we apply law of cosine (cause we need to know whether \\(\\delta> \\pi/2\\) or not) on right figure, \\[ R_e^2 =\\rho^2 + b^2 - 2\\rho b \\cos(\\pi-\\delta) \\] which yields \\[ \\begin{equation} \\cos\\delta =\\frac{R_e^2-\\rho^2-b^2}{2\\rho b} \\end{equation} \\] One can check that we already determine \\(r^\\prime\\) , Eq. \\(\\eqref{eq:rprime}\\) , by known quantities \\((d,\\ell,\\theta,\\varphi)\\) and \\((R_s,R_e,\\beta)\\) . The first set will be specified during evaluating BDM signatures and the second set of parameters gives the SN location. Last thing to be calculated is the scattering angle \\(\\psi\\) , which can be easily obtained by law of cosine again, \\[ R_s^2 = d^2 + \\ell^2 -2d \\ell \\cos(\\pi-\\psi) \\] such that \\[ \\begin{equation} \\cos\\psi = \\frac{R_s^2-d^2-\\ell^2}{2d\\ell} \\end{equation} \\] where $$ \\begin{equation}\\label{eq:d} d = \\sqrt{\\ell^2 + R_s^2 - 2\\ell R_s\\cos\\theta}. \\end{equation} $$ This indicates that \\(d\\) is not an independent quantity but subject to \\(\\ell\\) and \\(\\theta\\) . Static to time-dependent \u00b6 From Eq. (15) in BDM Physics and offseting it by \\(t_\\nu=R_s/c\\) , we have \\[ t = \\frac{d}{c} + \\frac{\\ell}{v_\\chi}- t_\\nu \\] hence \\[ \\begin{equation}\\label{eq:t_dependent} d + \\frac{\\ell}{\\beta_\\chi} = R_s + ct. \\end{equation} \\] where \\(\\beta_\\chi = v_\\chi/c\\) . For convenience, we define \\[ \\begin{equation} \\zeta(t) := R_s + ct \\end{equation} \\] and plug Eq. \\(\\eqref{eq:d}\\) into Eq. \\(\\eqref{eq:t_dependent}\\) and solve for \\(\\ell\\) , $$ \\begin{equation}\\label{eq:ell_t} \\ell(t) = -\\frac{\\beta_\\chi}{1-\\beta^2_\\chi}\\left(\\alpha + \\gamma-\\zeta \\right). \\end{equation} $$ where \\[ \\begin{align*} \\alpha &= \\sqrt{(R_s^2-\\zeta^2)(1-\\beta_\\chi^2)+(R_s\\beta_\\chi\\cos\\theta-\\zeta)^2},\\\\ \\gamma &= R_s\\beta_\\chi\\cos\\theta. \\end{align*} \\] We now can determine \\(\\ell\\) at any time \\(t\\) from Eq. \\(\\eqref{eq:ell_t}\\) and \\(d\\) is also subject to the change of \\(\\ell\\) when \\(\\theta\\) is specified.. The geometry for BDM becomes time-dependent from a static profile. References \u00b6 Y.-H. Lin et al. , Phys. Rev. D. 108 , 083013 (2023)","title":"Positioning"},{"location":"api/geometry/Positioning/#positioning","text":"To position the BDM signals, cf. Fig. 1 in BDM Physics , we have to analyze the geometry of propagation in order to get how large the emissivity is at B. Once the geometrical relations are understood, we can proceed to construct a class that solve this matter on-the-fly. See also Ref. [ 1 ] and note that we slightly modify the notations in this document for transparency.","title":"Positioning"},{"location":"api/geometry/Positioning/#geometry","text":"We replot Fig. 1 in BDM Physics and leaves only relevant information in the following Fig. 1 . Three coplanar points S, G and E remained the same. Repeated quantities are the same while we also mark addditional auxiliary terms which their purposes will be clear soon. Figure 1. The geometry of BDM propagation. By examining the blue and green triangles, we have \\[ \\begin{align} h &= \\ell \\sin\\theta \\\\ b &= \\ell \\cos\\theta. \\end{align} \\] Moreover, blue and brown triangles are identical, as brown one simply rotates around axis \\(\\overline{\\mathsf{SE}}\\) by \\(\\varphi\\) . See Fig. 2 . Figure 2. Blue and brown triangles are identical. Suppose B is distant \\(r\\) away from G, then B\u2032 is \\(r^\\prime\\) . It says that \\(r\\) is a special case of \\(r^\\prime\\) when \\(\\varphi=0\\) . This is curcial that when SN is not at the GC, DM number density \\(n_\\chi\\) is not spherical symmetric relative to SN. To resolve the correct \\(j_\\chi\\) at boost point, one needs to know \\(n_\\chi(r^\\prime(\\varphi))\\) . Figure 3. Another set of auxiliary triangles. We draw another set of auxiliary triangles in Fig. 3 , also cf. Fig. 1 , and immediately see that, left figure, \\[ \\begin{equation}\\label{eq:rprime} r^{\\prime2} = a^2 + h^2\\cos^2\\varphi \\end{equation} \\] while \\[ \\begin{equation} a^2 = (\\rho\\sin\\delta - h\\sin\\varphi)^2 + \\rho^2\\cos^2\\delta \\end{equation} \\] and, from law of cosine, the right figure gives, \\[ \\begin{equation} \\rho = \\sqrt{b^2+R_e^2 - 2b R_e \\cos\\beta}. \\end{equation} \\] To determine \\(\\delta\\) , we apply law of cosine (cause we need to know whether \\(\\delta> \\pi/2\\) or not) on right figure, \\[ R_e^2 =\\rho^2 + b^2 - 2\\rho b \\cos(\\pi-\\delta) \\] which yields \\[ \\begin{equation} \\cos\\delta =\\frac{R_e^2-\\rho^2-b^2}{2\\rho b} \\end{equation} \\] One can check that we already determine \\(r^\\prime\\) , Eq. \\(\\eqref{eq:rprime}\\) , by known quantities \\((d,\\ell,\\theta,\\varphi)\\) and \\((R_s,R_e,\\beta)\\) . The first set will be specified during evaluating BDM signatures and the second set of parameters gives the SN location. Last thing to be calculated is the scattering angle \\(\\psi\\) , which can be easily obtained by law of cosine again, \\[ R_s^2 = d^2 + \\ell^2 -2d \\ell \\cos(\\pi-\\psi) \\] such that \\[ \\begin{equation} \\cos\\psi = \\frac{R_s^2-d^2-\\ell^2}{2d\\ell} \\end{equation} \\] where $$ \\begin{equation}\\label{eq:d} d = \\sqrt{\\ell^2 + R_s^2 - 2\\ell R_s\\cos\\theta}. \\end{equation} $$ This indicates that \\(d\\) is not an independent quantity but subject to \\(\\ell\\) and \\(\\theta\\) .","title":"Geometry"},{"location":"api/geometry/Positioning/#static-to-time-dependent","text":"From Eq. (15) in BDM Physics and offseting it by \\(t_\\nu=R_s/c\\) , we have \\[ t = \\frac{d}{c} + \\frac{\\ell}{v_\\chi}- t_\\nu \\] hence \\[ \\begin{equation}\\label{eq:t_dependent} d + \\frac{\\ell}{\\beta_\\chi} = R_s + ct. \\end{equation} \\] where \\(\\beta_\\chi = v_\\chi/c\\) . For convenience, we define \\[ \\begin{equation} \\zeta(t) := R_s + ct \\end{equation} \\] and plug Eq. \\(\\eqref{eq:d}\\) into Eq. \\(\\eqref{eq:t_dependent}\\) and solve for \\(\\ell\\) , $$ \\begin{equation}\\label{eq:ell_t} \\ell(t) = -\\frac{\\beta_\\chi}{1-\\beta^2_\\chi}\\left(\\alpha + \\gamma-\\zeta \\right). \\end{equation} $$ where \\[ \\begin{align*} \\alpha &= \\sqrt{(R_s^2-\\zeta^2)(1-\\beta_\\chi^2)+(R_s\\beta_\\chi\\cos\\theta-\\zeta)^2},\\\\ \\gamma &= R_s\\beta_\\chi\\cos\\theta. \\end{align*} \\] We now can determine \\(\\ell\\) at any time \\(t\\) from Eq. \\(\\eqref{eq:ell_t}\\) and \\(d\\) is also subject to the change of \\(\\ell\\) when \\(\\theta\\) is specified.. The geometry for BDM becomes time-dependent from a static profile.","title":"Static to time-dependent"},{"location":"api/geometry/Propagation/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Propagation \u00b6 class snorer.Propagation( t , vx , theta , phi , Rs , Re , beta ) \u00b6 Superclass: snorer.Geometry The class constructs the dynamical geomatrical relations for \\(d\\) , \\(r^\\prime\\) and \\(\\cos\\psi\\) when \\((l,\\theta,\\phi)\\) and \\((R_s,R_e,\\beta)\\) are specified. Unlike its superclass Geometry, the class parameter l is now replaced by a specific time t and dimensionless BDM velocity vx . This allows it to incorporate time-dependent feature when evaluating the geometrical quantities during propagation. This class is also not exclusively for SN in MW or LMC, it can be generalized to SN in arbitrary distant galaxy as long as the aforementioned inputs are determined. The BDM emissivity along the line-of-sight then can be determined when calculate the BDM flux and event at Earth associated to that particular SN. See Positioning for more detail. Parameters: t : array_like The BDM at specific time \\(t\\) , seconds. Time-zero is set to be the arrival of SN \\(\\nu\\) at Earth vx : array_like BDM dimesionless velocity \\(v_\\chi/c\\) theta : array_like The zenith angle \\(\\theta\\) at Earth, centers SN, rad phi : array_like Azimuthal angle \\(\\varphi\\) at Earth, centers SN, rad Rs : array_like Distance from Earth to SN, kpc Re : array_like Distance from Earth to GC, kpc beta : array_like Off-center angle \\(\\beta\\) , rad Attributes: l : scalar/ndarray The line-of-sight distance \\(\\ell\\) , kpc d : scalar/ndarray Distance from SN to boost point \\(d\\) , kpc rprime : scalar/ndarray Distance from GC to boost point \\(r^\\prime\\) , kpc cos_psi : scalar/ndarray \\(\\cos\\psi\\) at boost point where \\(\\psi\\) is the direction for BDM at B pointing Earth Examples Import snorer and do >>> bdmProp = Propagation(t=59,vx=0.9,theta=1e-4,phi=0,Rs=11.6,Re=8.5,beta=0.71) >>> print(bdmProp.l) # The corresponding l.o.s. distance 5.160120751743069e-09 >>> print(bdmProp.d) # The distace from SN to boost point 11.59999999483988 >>> print(bdmProp.rprime) # The distance from GC to boost point 8.49999999608676 >>> print(bdmProp.cos_psi) # Scattering angle that points Earth at B 1.0","title":"Propagation"},{"location":"api/geometry/Propagation/#snorerpropagation","text":"","title":"snorer.Propagation"},{"location":"api/halo/HaloSpike/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.HaloSpike \u00b6 class snorer.HaloSpike( mBH , tBH , alpha ) \u00b6 Superclass: snorer.Constants Class for constructing dark matter halo with spike due to supermassive black hole (SMBH) in the galactic center. Parameters: mBH : float SMBH mass, \\(M_\\odot\\) tBH : float SMBH age, years alpha : str Slope of the spike profile, only '3/2' or '7/3' is acceptable Attributes: mBH : float SMBH mass, user's input tBH : float SMBH age, user's input alpha : obj Slope of the spike profile, user's input and is a Fraction object rh : float SMBH influence radius \\(r_h\\) , kpc Rsp : float Spike radius \\(R_{\\rm sp}\\) , kpc __call__ ( r , mx , sigv , rhos , rs , n ) \u00b6 After initializing snorer.HaloSpike instance, it is callable like normal function with the following required inputs. Parameters: r : float Distance to GC, kpc mx : float DM mass, MeV sigv : float DM annihilation cross section \\(\\langle\\sigma v\\rangle\\) in the unit of cm 3 s \u22121 . None means no annihilation rhos : float Charasteristic density \\(\\rho_s\\) , MeV s \u22123 rs : float Characteristic radius \\(r_s\\) , kpc n : float Slope of the DM profile outside \\(R_{\\rm sp}\\) Returns: out : scalar DM number density at \\(r\\) , cm \u22123 Examples Initializing instance and check its attributes. >>> import snorer as sn >>> nx = sn.HaloSpike(mBH=1e7,tBH=1e10,alpha='3/2') # initializing instance >>> nx # print instance information SMBH mass: 1.000e+07 M_sun Spike slope: 3/2 Initial slope: 1.000e+00 Spike radius: 9.504e-10 kpc Influence radius: 3.412e-03 kpc >>> nx.alpha # check alpha Fraction(3,2) The influence radius \\(r_h\\) is auto generated but can be replaced by user defined number. It can be reset to the default value by giving None . >>> nx.rh # default value of rh 0.003411783398329804 >>> nx.rh = 2.54e-3 # replace rh with user-defined value >>> nx.rh 2.54e-03 >>> nx.rh = None # reset it to the default value >>> nx.rh 0.003411783398329804 Make it a callable function that can calculate DM number density at different \\(r\\) . import numpy as np import matplotlib.pyplot as plt import snorer as sn # Get MW rhos, rs, n, mBH and rh rhos,rs,n,mBH,rh = constant.MW_profile.values() # Assuming BH age is 1 Gyr tBH = 1e10 # DM mass, MeV mx = 0.1 # Annihilation cross section sigv_list = [3,0.03,None] sigv_label = ['3','0.03','0'] # Initializing instances with two different alphas nx = HaloSpike(mBH=mBH,tBH=tBH,alpha='3/2') # alpha = 3/2 # radius, kpc r_vals = np.logspace(-5,2,100) for i in range(3): sigv = sigv_list[i] nx_vals = [nx(r,mx,sigv,rhos,rs,n) for r in r_vals] plt.plot(r_vals,nx_vals,label=sigv_label[i] + r'$\\times10^{-26}\\,{\\rm cm^3~s^{-1}}$') plt.xscale('log') plt.yscale('log') plt.xlabel(r'$r$ [kpc]') plt.ylabel(r'$n_\\chi(r)$ [cm$^{-3}$]') plt.title(fr'$m_\\chi = {mx:.1f}$ MeV') plt.legend() plt.show() References \u00b6 P. Gondolo and J. Silk, Phys. Rev. Lett. 83 , 1719 (1999) J. Cline and M. Puel, JCAP 06 , 004 (2023)","title":"HaloSpike"},{"location":"api/halo/HaloSpike/#snorerhalospike","text":"","title":"snorer.HaloSpike"},{"location":"api/halo/M_sigma/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.M_sigma \u00b6 snorer.M_sigma( mBH ) \u00b6 Stellar dispersion relation under the influence of black hole. Also known as \\(M-\\sigma\\) relation. Parameters: mBH : array_like Supermassive black hole mass, \\(M_\\odot\\) Returns: out : scalar/ndarray Stellar velocity dispersion, km s \u22121 . Out is scalar if the input is scalar too. Notes This function evaluates the stellar dispersion \\(\\sigma_s\\) near supermassive black hole $$ \\log_{10}\\left(\\frac{M_{\\rm BH}}{M_\\odot}\\right) = 8.29 + 5.12\\log_{10}\\left(\\frac{\\sigma_s}{200\\,{\\rm km\\,s^{-1}}}\\right). $$ References \u00b6 N. McConnell et al. , Nature 480 , 215 (2011)","title":"M_sigma"},{"location":"api/halo/M_sigma/#snorerm_sigma","text":"","title":"snorer.M_sigma"},{"location":"api/halo/nx/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.nx \u00b6 snorer.nx( r , mx , is_spike=False , **kwargs *) \u00b6 Dark matter number density of Milky Way of Large Magellanic Cloud at distance \\(r\\) to the galactic center. Spike feature is not included. Parameters: r : array_like Distance to galactic center \\(r\\) , kpc mx : array_like Dark matter mass, MeV is_spike : bool Is halo spike included? Default is False . **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.halo and snorer.params.spike . Returns: out : scalar/ndarray Dark matter number density at \\(r\\) , cm \u22123 Examples Let's plot \\(n_\\chi(r)\\) for different profiles. import numpy as np import matplotlib.pyplot as plt import snorer as sn mx = 0.01 # radius, kpc r_vals = np.logspace(-3,2,100) # profiles profiles = [sn.constant.MW_profile,sn.constant.LMC_profile] labels = ['MW','LMC'] # Make plot for i in range(2): rhos,rs,n,_,_ = profiles[i].values() nx_vals = sn.nx(r_vals,mx,rhos=rhos,rs=rs,n=n) plt.plot(r_vals,nx_vals,label=labels[i]) plt.xscale('log') plt.yscale('log') plt.xlabel(r'$r$ [kpc]') plt.ylabel(r'$n_\\chi(r)$ [cm$^{-3}$]') plt.title(fr'$m_\\chi = {mx:.2f}$ MeV') plt.legend() plt.show() Notes Number density is just density divided by mass, $$ n_\\chi(r)=\\frac{\\rho_\\chi(r)}{m_\\chi}. $$ See also snorer.rhox .","title":"nx"},{"location":"api/halo/nx/#snorernx","text":"","title":"snorer.nx"},{"location":"api/halo/nxSpike/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.nxSpike \u00b6 snorer.nxSpike( r , mx , profile='MW' , sigv=None , tBH=1e+10 , alpha='3/2' ) \u00b6 Dark matter number density of Milky Way of Large Magellanic Cloud at distance \\(r\\) to the galactic center. Spike feature is included. Parameters: r : array_like Distance to galactic center, kpc mx : array_like Dark matter mass, MeV profile : str 'MW' or 'LMC' , stands for MW halo or LMC halo sigv : scalar DM annihilation cross section, in the unit of \\(10^{-26}\\) cm 3 s \u22121 . None indicates no annihilation tBH : float Supermassive black hole age, years alpha : str Slope of the spike, '3/2' or '7/3' Returns: out : scalar/ndarray Dark matter number density at r with spike in the center, cm \u22123 Examples Let's plot \\(n_\\chi\\) for different \\(\\langle \\sigma v\\rangle\\) . import numpy as np import matplotlib.pyplot as plt import snorer as sn # DM mass, keV mx = 0.01 # radius, kpc r_vals = np.logspace(-5,2,100) # profiles sigv_vals = [None,0.01,0.1,3] for sigv in sigv_vals: # calculate nx nx_vals = nxSpike(r_vals,mx,sigv=sigv,profile='LMC') if sigv is None: sigv = 0 # legend label plt.plot(r_vals,nx_vals,label=r'$\\langle\\sigma v\\rangle=$' + str(sigv)) plt.xscale('log') plt.yscale('log') plt.xlabel(r'$r$ [kpc]') plt.ylabel(r'$n_\\chi(r)$ [cm$^{-3}$]') plt.title(fr'LMC with spike and $m_\\chi = {mx:.2f}$ MeV') plt.legend() plt.show() Notes To realize \\(n_\\chi\\) with spike feature we initialized a snorer.HaloSpike instance inside the function snorer.nxSpike and utilize the callable feature. However, such callable function does not support vectorization. To mimic vectorized inputs/outputs, we employ numpy.nditer . It could become clumsy if the points to be calculated are massive.","title":"nxSpike"},{"location":"api/halo/nxSpike/#snorernxspike","text":"","title":"snorer.nxSpike"},{"location":"api/halo/radiusInfluence/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.radiusInfluence \u00b6 snorer.radiusInfluence( mBH ) \u00b6 Influence radius of a supermassive black hole Parameters: mBH : array_like Supermassive black hole mass, \\(M_\\odot\\) Returns: out : scalar/ndarray Influence radisu, kpc. Out is scalar if the input is scalar. Notes This function evaluates the influence radius of a supermassive black hole $$ r_h = \\frac{GM_{\\rm BH}}{\\sigma_s^2} $$ where sigma_s is the stellar dispersion near SMBH. See also snorer.M_sigma .","title":"radiusInfluence"},{"location":"api/halo/radiusInfluence/#snorerradiusinfluence","text":"","title":"snorer.radiusInfluence"},{"location":"api/halo/radiusSchwarzschild/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.radiusSchwarzschild \u00b6 snorer.radiusSchwarzschild( mBH ) \u00b6 Schawarzschild radius of a supermassive black hole. Parameters: mBH : array_like Supermassive black hole mass, \\(M_\\odot\\) Returns: out : scalar/ndarray Schwarzschild radius, kpc. Out is scalar if the input is scalar.","title":"radiusSchwarzschild"},{"location":"api/halo/radiusSchwarzschild/#snorerradiusschwarzschild","text":"","title":"snorer.radiusSchwarzschild"},{"location":"api/halo/rhox/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.rhox \u00b6 snorer.rhox( r , rhos , rs , n ) \u00b6 Dark matter density at \\(r\\) . Parameters: r : array_like Distance to GC, kpc rhos : array_like Characteristic density \\(\\rho_s\\) , MeV cm \u22123 rs : array_like Characteristic radius \\(r_s\\) , kpc n : array_like Slope of the DM profile Returns: out : scalar/ndarray DM density at \\(r\\) , MeV cm \u22123 . Out is scalar if all inputs are scalars Notes This function evaluates the DM density profile $$ \\rho_\\chi(r)=\\frac{\\rho_s}{\\frac{r}{r_s}(1+\\frac{r}{r_s})^n} $$ where rhos and rs are characteristic density and radius respectively. When \\((\\rho_s,r_s,n) =\\) (184 MeV cm \u22123 , 24.42 kpc, 2), it is the famous NFW profile. If divided by \\(m_\\chi\\) , it becomes DM number density. References \u00b6 G. Bertone et al. , Phys. Rept. 405 , 279 (2005)","title":"rhox"},{"location":"api/halo/rhox/#snorerrhox","text":"","title":"snorer.rhox"},{"location":"api/kinematics/22scat/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; 2-2 elastic scattering \u00b6 We have reviewed the 2-2 elastic scattering with one is massless neutrino in BDM Physics . In order to facilitate a broader case, we relax the massless assumption and do not identitfy them as any particle species. This aids us to build an independent class that is suitable for any 2-2 scattering with non-zero masses. General expressions \u00b6 The scheme for scattering of two particles, labeled 1 and 2, is shown in Fig. 1 . Each particle carries non-zero mass \\(m_1\\) and \\(m_2\\) respectively. Four-momenta for evary particles are shown on the sides. The scattering angle measures the degrees of deflection relative to the incoming direction of particle 1. After scattering, particles 1 and 2 have scattering angles \\(\\vartheta\\) and \\(\\psi\\) respectively. Figure 1. The 2-2 particle scattering in lab frame. We can write down the 4-momenta in lab frame, \\[ \\begin{align*} p_1 = (E_1,\\mathbf{p}_1),&\\quad p_2 = (m_2,\\mathbf{0}),\\\\ p_1^{\\prime} = (E_1^\\prime,\\mathbf{p}_1^\\prime),&\\quad p_2^{\\prime} = (E_2^\\prime,\\mathbf{p}_2^\\prime), \\end{align*} \\] and the corresponding \\(u\\) -channel \\[ \\begin{gather*} (p_1-p_2^\\prime)^2 = m_1^2+m_2^2-2E_1E_2^\\prime +2 |\\mathbf{p}_1| |\\mathbf{p}_2^\\prime| \\cos\\psi,\\\\ (p_2-p_1^\\prime)^2 = m_1^2+m_2^2 - 2 E_1^\\prime m_2. \\end{gather*} \\] The two identities are equivalent due to Lorentz invariant nature. Similar to the BDM case, suppose we know \\(E_2^\\prime\\) and its kinetic energy such that $$ T_2 = E^\\prime_2 - m_2 = E_1 - E_1^\\prime. $$ We thus have $$ \\begin{equation} E_1 (T_2+m_2) -|\\mathbf{p}_1||\\mathbf{p}_2^\\prime| x = (E_1-T_2)m_2, \\end{equation} $$ where \\(x:= \\cos\\psi\\) . By letting \\(|\\mathbf{p}_1|=\\sqrt{E_1^2-m_1^2}\\) and \\(|\\mathbf{p}_2^\\prime| =\\sqrt{T_2(T_2+2m_2)}\\) , the only unknown in the above equation is \\(E_1\\) , which can be solved analytically, \\[ \\begin{equation}\\label{eq:E1} E_1=\\frac{T_2^2 m_2 + |\\mathbf{p}_2^\\prime|x\\sqrt{m_1^2 |\\mathbf{p}_2^\\prime|^2 x^2 + T_2^2 (m_2^2-m_1^2)}}{|\\mathbf{p}_2^\\prime|^2 x^2 - T_2^2}. \\end{equation} \\] Note the \\(E_1\\) gives the total energy of particle 1, thus \\(T_1=E_1 - m_1\\) . It is true that \\(E_1 = T_1\\) only when \\(m_1=0\\) . Moreover, one can differentiate \\(E_1\\) w.r.t. \\(T_2\\) and it yields $$ \\begin{equation}\\label{eq:dE1/dT2} \\frac{dE_1}{dT_2}=m_2x^2\\times \\frac{\\alpha +\\beta + \\gamma}{\\eta} \\end{equation} $$ where \\[ \\begin{align*} \\alpha &= m_1^2 \\delta, \\\\ \\beta & = m_2^2 (2T_2+\\delta),\\\\ \\gamma &= 2m_2 x \\kappa,\\\\ \\eta &= \\delta^2 x \\kappa, \\end{align*} \\] with \\(\\delta=-T_2 + (T_2 + 2m_2)x^2\\) and \\(\\kappa=\\sqrt{(T_2+2m_2)(\\alpha+ T_2 m_2^2 )}\\) . In most of the situations, elastic scattering does not change particle mass, thus $$ \\begin{equation} \\frac{dE_1}{dT_2} = \\frac{d}{dT_2}(T_1 + m_1) = \\frac{dT_1}{dT_2} \\end{equation} $$ and this allows to express every quantities in terms of kinetic energies \\(T_i\\) . When we construct the corresponding class , the namespace will always refers to \\(T_i\\) instead of \\(E_i\\) . Though the angle \\(\\vartheta\\) for particle 1 is irrelevant to our study, we can still determine it by 3-momentum conservation, $$ \\begin{equation} \\vartheta =\\sin^{-1}\\left( \\frac{|\\mathbf{p}_2^\\prime|}{|\\mathbf{p}_1^\\prime|}\\sin\\psi\\right) \\end{equation} $$ where \\(|\\mathbf{p_1^\\prime}|=\\sqrt{E_1^{\\prime 2}-m_1^2}\\) and \\(E_1^\\prime = E_1-T_2\\) . Validation \u00b6 Now recall the \\(\\nu\\chi\\) scattering with \\(E_1=E_\\nu\\) , \\(T_2=T_\\chi\\) , \\(m_1=m_\\nu=0\\) and \\(m_2=m_\\chi\\) . With \\(|\\mathbf{p}_2^\\prime|=|\\mathbf{p}_\\chi|=\\sqrt{T_\\chi(T_\\chi+m_\\chi)}\\) , Eq. \\(\\eqref{eq:E1}\\) becomes \\[ \\begin{equation}\\label{eq:Ev} E_\\nu = T_\\chi m_\\chi \\frac{T_\\chi + |\\mathbf{p}_\\chi|x }{( |\\mathbf{p}_\\chi|x-T_\\chi)(|\\mathbf{p}_\\chi|x+T_\\chi)}=\\frac{T_\\chi m_\\chi}{|\\mathbf{p}_\\chi|x-T_\\chi}. \\end{equation} \\] Additionally, \\[ \\begin{align*} \\alpha &= 0, \\\\ \\beta & = m_\\chi^2 (T_\\chi+(T_\\chi +2m_\\chi)x^2),\\\\ \\gamma &= 2m_\\chi^2 |\\mathbf{p}_\\chi|x,\\\\ \\eta &= \\delta^2 m_\\chi |\\mathbf{p}_\\chi|x , \\end{align*} \\] and with some tedious math one obtains \\[ \\begin{align*} m_\\chi x^2\\frac{\\alpha+\\beta+\\gamma}{\\eta}&= \\frac{x}{\\delta^2}\\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|}(T_\\chi+(T_\\chi+2m_\\chi)x^2+2|\\mathbf{p}_\\chi|x) \\\\ &=\\frac{x}{\\delta^2}\\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|}\\left(T_\\chi +\\frac{|\\mathbf{p}_\\chi|^2}{T_\\chi}x^2+2|\\mathbf{p}_\\chi|x\\right)\\\\ & = \\frac{x}{\\delta^2}\\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|} \\frac{(T_\\chi + |\\mathbf{p}_\\chi|x)^2}{T_\\chi } \\end{align*} \\] we further use \\[ \\begin{align*} \\delta^2 & =\\left(-T_\\chi + \\frac{|\\mathbf{p}_\\chi|^2}{T_\\chi}x^2\\right)^2=\\frac{(|\\mathbf{p}_\\chi|^2x^2 - T_\\chi^2)^2}{T_\\chi^2}\\\\ &= \\frac{(|\\mathbf{p}_\\chi|x - T_\\chi)^2(|\\mathbf{p}_\\chi|x + T_\\chi)^2}{T_\\chi^2} \\end{align*} \\] then finally reaches \\[ \\begin{equation}\\label{eq:dEv/dTx} m_\\chi x^2\\frac{\\alpha+\\beta+\\gamma}{\\eta}=\\left(\\frac{m_\\chi}{|\\mathbf{p}_\\chi|x - T_\\chi}\\right)^2\\frac{T_\\chi}{|\\mathbf{p}_\\chi|}x = \\frac{dE_\\nu}{dT_\\chi}. \\end{equation} \\] We discover that Eqs. \\(\\eqref{eq:Ev}\\) and \\(\\eqref{eq:dEv/dTx}\\) are exactly Eqs. (5) and (8) in BDM Physics respectively. Thus conclude that Eqs. \\(\\eqref{eq:E1}\\) and \\(\\eqref{eq:dE1/dT2}\\) are the general expressions for massive 2-2 elastic scattering.","title":"2-2 elastic scattering"},{"location":"api/kinematics/22scat/#2-2-elastic-scattering","text":"We have reviewed the 2-2 elastic scattering with one is massless neutrino in BDM Physics . In order to facilitate a broader case, we relax the massless assumption and do not identitfy them as any particle species. This aids us to build an independent class that is suitable for any 2-2 scattering with non-zero masses.","title":"2-2 elastic scattering"},{"location":"api/kinematics/22scat/#general-expressions","text":"The scheme for scattering of two particles, labeled 1 and 2, is shown in Fig. 1 . Each particle carries non-zero mass \\(m_1\\) and \\(m_2\\) respectively. Four-momenta for evary particles are shown on the sides. The scattering angle measures the degrees of deflection relative to the incoming direction of particle 1. After scattering, particles 1 and 2 have scattering angles \\(\\vartheta\\) and \\(\\psi\\) respectively. Figure 1. The 2-2 particle scattering in lab frame. We can write down the 4-momenta in lab frame, \\[ \\begin{align*} p_1 = (E_1,\\mathbf{p}_1),&\\quad p_2 = (m_2,\\mathbf{0}),\\\\ p_1^{\\prime} = (E_1^\\prime,\\mathbf{p}_1^\\prime),&\\quad p_2^{\\prime} = (E_2^\\prime,\\mathbf{p}_2^\\prime), \\end{align*} \\] and the corresponding \\(u\\) -channel \\[ \\begin{gather*} (p_1-p_2^\\prime)^2 = m_1^2+m_2^2-2E_1E_2^\\prime +2 |\\mathbf{p}_1| |\\mathbf{p}_2^\\prime| \\cos\\psi,\\\\ (p_2-p_1^\\prime)^2 = m_1^2+m_2^2 - 2 E_1^\\prime m_2. \\end{gather*} \\] The two identities are equivalent due to Lorentz invariant nature. Similar to the BDM case, suppose we know \\(E_2^\\prime\\) and its kinetic energy such that $$ T_2 = E^\\prime_2 - m_2 = E_1 - E_1^\\prime. $$ We thus have $$ \\begin{equation} E_1 (T_2+m_2) -|\\mathbf{p}_1||\\mathbf{p}_2^\\prime| x = (E_1-T_2)m_2, \\end{equation} $$ where \\(x:= \\cos\\psi\\) . By letting \\(|\\mathbf{p}_1|=\\sqrt{E_1^2-m_1^2}\\) and \\(|\\mathbf{p}_2^\\prime| =\\sqrt{T_2(T_2+2m_2)}\\) , the only unknown in the above equation is \\(E_1\\) , which can be solved analytically, \\[ \\begin{equation}\\label{eq:E1} E_1=\\frac{T_2^2 m_2 + |\\mathbf{p}_2^\\prime|x\\sqrt{m_1^2 |\\mathbf{p}_2^\\prime|^2 x^2 + T_2^2 (m_2^2-m_1^2)}}{|\\mathbf{p}_2^\\prime|^2 x^2 - T_2^2}. \\end{equation} \\] Note the \\(E_1\\) gives the total energy of particle 1, thus \\(T_1=E_1 - m_1\\) . It is true that \\(E_1 = T_1\\) only when \\(m_1=0\\) . Moreover, one can differentiate \\(E_1\\) w.r.t. \\(T_2\\) and it yields $$ \\begin{equation}\\label{eq:dE1/dT2} \\frac{dE_1}{dT_2}=m_2x^2\\times \\frac{\\alpha +\\beta + \\gamma}{\\eta} \\end{equation} $$ where \\[ \\begin{align*} \\alpha &= m_1^2 \\delta, \\\\ \\beta & = m_2^2 (2T_2+\\delta),\\\\ \\gamma &= 2m_2 x \\kappa,\\\\ \\eta &= \\delta^2 x \\kappa, \\end{align*} \\] with \\(\\delta=-T_2 + (T_2 + 2m_2)x^2\\) and \\(\\kappa=\\sqrt{(T_2+2m_2)(\\alpha+ T_2 m_2^2 )}\\) . In most of the situations, elastic scattering does not change particle mass, thus $$ \\begin{equation} \\frac{dE_1}{dT_2} = \\frac{d}{dT_2}(T_1 + m_1) = \\frac{dT_1}{dT_2} \\end{equation} $$ and this allows to express every quantities in terms of kinetic energies \\(T_i\\) . When we construct the corresponding class , the namespace will always refers to \\(T_i\\) instead of \\(E_i\\) . Though the angle \\(\\vartheta\\) for particle 1 is irrelevant to our study, we can still determine it by 3-momentum conservation, $$ \\begin{equation} \\vartheta =\\sin^{-1}\\left( \\frac{|\\mathbf{p}_2^\\prime|}{|\\mathbf{p}_1^\\prime|}\\sin\\psi\\right) \\end{equation} $$ where \\(|\\mathbf{p_1^\\prime}|=\\sqrt{E_1^{\\prime 2}-m_1^2}\\) and \\(E_1^\\prime = E_1-T_2\\) .","title":"General expressions"},{"location":"api/kinematics/22scat/#validation","text":"Now recall the \\(\\nu\\chi\\) scattering with \\(E_1=E_\\nu\\) , \\(T_2=T_\\chi\\) , \\(m_1=m_\\nu=0\\) and \\(m_2=m_\\chi\\) . With \\(|\\mathbf{p}_2^\\prime|=|\\mathbf{p}_\\chi|=\\sqrt{T_\\chi(T_\\chi+m_\\chi)}\\) , Eq. \\(\\eqref{eq:E1}\\) becomes \\[ \\begin{equation}\\label{eq:Ev} E_\\nu = T_\\chi m_\\chi \\frac{T_\\chi + |\\mathbf{p}_\\chi|x }{( |\\mathbf{p}_\\chi|x-T_\\chi)(|\\mathbf{p}_\\chi|x+T_\\chi)}=\\frac{T_\\chi m_\\chi}{|\\mathbf{p}_\\chi|x-T_\\chi}. \\end{equation} \\] Additionally, \\[ \\begin{align*} \\alpha &= 0, \\\\ \\beta & = m_\\chi^2 (T_\\chi+(T_\\chi +2m_\\chi)x^2),\\\\ \\gamma &= 2m_\\chi^2 |\\mathbf{p}_\\chi|x,\\\\ \\eta &= \\delta^2 m_\\chi |\\mathbf{p}_\\chi|x , \\end{align*} \\] and with some tedious math one obtains \\[ \\begin{align*} m_\\chi x^2\\frac{\\alpha+\\beta+\\gamma}{\\eta}&= \\frac{x}{\\delta^2}\\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|}(T_\\chi+(T_\\chi+2m_\\chi)x^2+2|\\mathbf{p}_\\chi|x) \\\\ &=\\frac{x}{\\delta^2}\\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|}\\left(T_\\chi +\\frac{|\\mathbf{p}_\\chi|^2}{T_\\chi}x^2+2|\\mathbf{p}_\\chi|x\\right)\\\\ & = \\frac{x}{\\delta^2}\\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|} \\frac{(T_\\chi + |\\mathbf{p}_\\chi|x)^2}{T_\\chi } \\end{align*} \\] we further use \\[ \\begin{align*} \\delta^2 & =\\left(-T_\\chi + \\frac{|\\mathbf{p}_\\chi|^2}{T_\\chi}x^2\\right)^2=\\frac{(|\\mathbf{p}_\\chi|^2x^2 - T_\\chi^2)^2}{T_\\chi^2}\\\\ &= \\frac{(|\\mathbf{p}_\\chi|x - T_\\chi)^2(|\\mathbf{p}_\\chi|x + T_\\chi)^2}{T_\\chi^2} \\end{align*} \\] then finally reaches \\[ \\begin{equation}\\label{eq:dEv/dTx} m_\\chi x^2\\frac{\\alpha+\\beta+\\gamma}{\\eta}=\\left(\\frac{m_\\chi}{|\\mathbf{p}_\\chi|x - T_\\chi}\\right)^2\\frac{T_\\chi}{|\\mathbf{p}_\\chi|}x = \\frac{dE_\\nu}{dT_\\chi}. \\end{equation} \\] We discover that Eqs. \\(\\eqref{eq:Ev}\\) and \\(\\eqref{eq:dEv/dTx}\\) are exactly Eqs. (5) and (8) in BDM Physics respectively. Thus conclude that Eqs. \\(\\eqref{eq:E1}\\) and \\(\\eqref{eq:dE1/dT2}\\) are the general expressions for massive 2-2 elastic scattering.","title":"Validation"},{"location":"api/kinematics/KallenLambda/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.KallenLambda \u00b6 snorer.KallenLambda( x , y , z ) \u00b6 K\u00e4llen lambda function $$ \\lambda(x,y,z)=x^2+y^2+z^2-2(xy+yz+zx), $$ a useful function for evaluating kinetical quantities in particle physics. Parameters: x : array_like y : array_like z : array_like Returns: out : scalar/ndarray out is scalar if all inputs are scalars. References \u00b6 V. Ilisie, Concepts in quantum field theory: A practitioner's toolkit , Springer (2016)","title":"KallenLambda"},{"location":"api/kinematics/KallenLambda/#snorerkallenlambda","text":"","title":"snorer.KallenLambda"},{"location":"api/kinematics/Kinematics/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Kinematics \u00b6 class snorer.Kinematics( T2 , m1 , m2 , psi ) \u00b6 This class constructs the required kinetic energy \\(T_1\\) of incoming particle with mass \\(m_1\\) to boost the target with mass \\(m_2\\) to kinetic energy \\(T_2\\) along the direction \\(\\psi\\) . See Fig. 1 in 2-2 elastic scattering . Parameters: T2 : array_like Kinetic energy \\(T_2\\) received by the particle 2, MeV m1 : array_like Mass of particle 1 (incident) \\(m_1\\) , MeV m2 : array_like Mass of particle 2 (target) \\(m_2\\) , MeV psi : array_like Lab frame scattering angle \\(\\psi\\) , rad Attributes: T1 : scalar/ndarray The required kinetic energy \\(T_1\\) of particle 1, MeV dT1 : scalar/ndarray The Jacobian \\(dT_1/dT_2\\) , dimensionless x : scalar/ndarray \\(x:=\\cos\\psi \\in [1,-1]\\) sanity : boolr/ndarray Are the parameters physically plausible? True for plausible and False for physically impossible. dLips : scalar/ndarray Value for differential Lorentz invariant phase space Examples Import snorer and do >>> import snorer as sn >>> T2,m1,m2,psi = 15,0,1e-3,0.05 # kinetic energy, m1, m2, scattering angle >>> snv = sn.Kinematics(T2,m1,m2,psi) >>> snv.T1 # required kinetic energy T1 for particle 1 -0.8451953159962898 >>> snv.dT1 # Jacobian 0.0031707324661873464 >>> snv.sanity # is this physically possible? False It is clear that massless particle 1 is no way to upscatter particle 2 with \\(m_2=10^{-3}\\) MeV to \\(T_2=15\\) MeV at angular direction \\(\\psi\\) . Becasue the required \\(T_1\\) ( snv.T1 ) is negative. The attribute snv.sanity is False , which implies this reaction is physically impossible.","title":"Kinematics"},{"location":"api/kinematics/Kinematics/#snorerkinematics","text":"","title":"snorer.Kinematics"},{"location":"api/kinematics/Mandelstam/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Mandelstam \u00b6 class snorer.Mandelstam( T2 , m1 , m2 , psi ) \u00b6 Superclass: snorer.Kinematics This class constructs the associated Mandelstam variables \\(s\\) , \\(t\\) and \\(u\\) associated with the scattering process depicted in Fig. 1 in 2-2 elastic scattering . Parameters: T2 : array_like Kinetic energy \\(T_2\\) received by the particle 2, MeV m1 : array_like Mass of particle 1 (incident) \\(m_1\\) , MeV m2 : array_like Mass of particle 2 (target) \\(m_2\\) , MeV psi : array_like Lab frame scattering angle \\(\\psi\\) , rad Attributes: s : scalar/ndarray The \\(s\\) -channel in this scattering process, MeV 2 t : scalar/ndarray The \\(t\\) -channel in this scattering process, MeV 2 u : scalar/ndarray The \\(u\\) -channel in this scattering process, MeV 2 T1 : scalar/ndarray The required kinetic energy \\(T_1\\) of particle 1, MeV dT1 : scalar/ndarray The Jacobian \\(dT_1/dT_2\\) , dimensionless x : scalar/ndarray \\(x:=\\cos\\psi \\in [1,-1]\\) sanity : bool/ndarray Are the parameters physically plausible? True for plausible and False for physically impossible. dLips : scalar/ndarray Value for differential Lorentz invariant phase space Notes Given \\(T_1\\) is obtained from its superclass snorer.Kinematics , we can evaluate all Mandelstam variables easily. Thus, \\[ \\begin{align*} s &= (p_1+p_2)^2 = m_1^2+m_2^2 + 2 E_1 m_1 \\\\ &= m_1^2+m_2^2 + 2(T_1+m_1)m_2 \\end{align*} \\] for \\(s\\) -channel, and \\[ \\begin{align*} t &= (p_2^\\prime - p_2)^2 = 2m_2^2 - 2E_2 E_2^\\prime \\\\ &= 2m_2^2 - 2(T_2+m_2)m_2. \\end{align*} \\] For \\(u\\) -channel, we use the identity $$ s+t+u = \\sum_i m_i^2 = 2(m_1^2+m_2^2) $$ where \\(i\\) indicates all particle masses before and after the reaction. References \u00b6 M. Peskin and D. Schroeder, An Introduction To Quantum Field Theory , Westview (1995)","title":"Mandelstam"},{"location":"api/kinematics/Mandelstam/#snorermandelstam","text":"","title":"snorer.Mandelstam"},{"location":"api/kinematics/Neutrino/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Neutrino \u00b6 class snorer.Neutrino( Tx , mx , psi ) \u00b6 Superclass: snorer.Kinematics This class constructs the required neturino energy to have BDM with \\((T_\\chi,m_\\chi,\\psi)\\) . See Fig. 2 in BDM Physics . We have assumed neutrino mass \\(m_\\nu=0\\) . Parameters: Tx : array_like BDM kinetic energy \\(T_\\chi\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV psi : array_like Lab frame scattering angle \\(\\psi\\) , rad Attributes: Ev : scalar/ndarray The required neutrino energy \\(E_\\nu\\) to boost DM with \\(m_\\chi\\) to \\(T_\\chi\\) , MeV dEv : scalar/ndarray The Jacobian \\(dE_\\nu/dT_\\chi\\) , dimensionless x : scalar/ndarray \\(x:=\\cos\\psi \\in [1,-1]\\) sanity : bool/ndarray Is the reaction physically plausible? True for plausible and False for physically impossible. dLips : scalar/ndarray Value for differential Lorentz invariant phase space Examples Import snorer and do >>> import snorer as sn >>> Tx,mx,psi = 15,1e-3,0.05 # BDM kinetic energy, mx, scattering angle >>> snv = sn.Neutrino(Tx,mx,psi) >>> snv.Ev # required Ev -0.8451953159962898 >>> snv.dEv # Jacobian 0.0031707324661873464 >>> snv.sanity # is this physically possible? False This example is identical to the example conducted in snorer.Kinematics as snorer.Kinematics is the superclass of snorer.Neutrino . One understands that \\(T_1=E_\\nu\\) , \\(T_2=T_\\chi\\) , \\(m_1=m_\\nu=0\\) and \\(m_2=m_\\chi\\) .","title":"Neutrino"},{"location":"api/kinematics/Neutrino/#snorerneutrino","text":"","title":"snorer.Neutrino"},{"location":"api/kinematics/get_gx/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_gx \u00b6 snorer.get_gx( Ev , mx , psi ) \u00b6 Calculate the probability density for cross section at scattering angle psi and averaged over azimuthal angle in lab frame. This is for energy-independent cross section. See Eq. (3) in BDM Physics . Parameters: Ev : array_like The incoming neutrino energy \\(E_\\nu\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV psi : array_like Lab frame scattering angle \\(\\psi\\) , rad Returns: out : scalar/ndarray Probability density for cross section at \\(\\psi\\) and averaged over azimuthal angle \\(2\\pi\\) . The result is a scalar if the three inputs are all scalars. The unit is sr \u22121 Examples In this example, we show \\(2\\pi g_\\chi\\sin\\psi\\) vs. \\(\\psi\\) for various \\(m_\\chi\\) . import numpy as np import matplotlib.pyplot as plt import snorer as sn # Neutrino energy, mx values and psi range Ev = 10 mx_vals = np.logspace(-3,0,4) psi_vals = np.linspace(0,np.pi/2,500) # Draw gx plots for various mx for mx in mx_vals: dOmega = 2*np.pi*np.sin(psi_vals) gx_vals = get_gx(Ev,mx,psi_vals)*dOmega plt.plot(psi_vals,gx_vals,label=fr'$m_\\chi={1000*mx:.0f}$ keV') plt.yscale('log') plt.ylim(9.5e-3,) plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$2\\pi g_\\chi\\sin\\psi$') plt.legend() plt.show()","title":"get_gx"},{"location":"api/kinematics/get_gx/#snorerget_gx","text":"","title":"snorer.get_gx"},{"location":"api/kinematics/get_psiMax/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_psiMax \u00b6 ssnorer.get_psiMax( Tx , mx ) \u00b6 Get the maximumly allowed scattering angle \\(\\psi_{\\rm max}\\) . Se Eq. (6) BDM Physics . Parameters: Tx : array_like BDM kinetic energy \\(T_\\chi\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV Returns: out : scalar/ndarray Maximum allowed scattering angle \\(\\psi_{\\rm max}\\) [rad]. out is scalar if all inputs are scalars.","title":"get_psiMax"},{"location":"api/kinematics/get_psiMax/#snorerget_psimax","text":"","title":"snorer.get_psiMax"},{"location":"api/kinematics/get_thetaMax/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_thetaMax \u00b6 snorer.get_thetaMax( t , Tx , mx , Rs ) \u00b6 Find the maximum BDM field-of-view, \\(\\theta_{M}^*\\) , that centers SN at particular time \\(t^*\\) . See Eq. (24) in BDM Physics . Parameters: t : scalar The BDM at particular time \\(t^*\\) , seconds. If \\(t^* > t_{\\rm van}\\) , the result is unphysical. Tx : scalar BDM kinetic energy \\(T_\\chi\\) , MeV mx : scalar DM mass \\(m_\\chi\\) , MeV Rs : scalar Distance to supernova, \\(R_s\\) , kpc. Returns: out : scalar Maximum field-of-view centers supernova, \\(\\theta^*_M\\) [rad].","title":"get_thetaMax"},{"location":"api/kinematics/get_thetaMax/#snorerget_thetamax","text":"","title":"snorer.get_thetaMax"},{"location":"api/kinematics/get_tvan/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_tvan \u00b6 snorer.get_tvan( Tx , mx , Rs ) \u00b6 Get the BDM vanishing time. The time-zero is set as the arrival of SN \\(\\nu\\) at Earth. See Eqs. (22) and (23) in BDM Physics . Parameters: Tx : array_like BDM kinetic energy \\(T_\\chi\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV Rs : array_like Distance to supernova, \\(R_s\\) , kpc Returns: out : scalar/ndarray BDM vanishing time \\(t_{\\rm vab}\\) , seconds Examples In this example, we show \\(t_{\\rm van}\\) on \\((m_\\chi,T_\\chi)\\) plane. import numpy as np import matplotlib.pyplot as plt import matplotlib.colors as mcolors import snorer as sn Rs = 9.6 # SN distance, kpc Tx_vals = np.logspace(-6,2,100) # Tx values mx_vals = np.logspace(-6,3,100) # mx values # Setup meshgrid for (mx,Tx) plane MX,TX = np.meshgrid(mx_vals,Tx_vals,indexing='ij') # Evaluating tvan and convert it to years TVAN = sn.get_tvan(TX,MX,Rs)/sn.constant.year2Seconds # Plot fig, ax = plt.subplots() # log-scaler color norm = mcolors.LogNorm(vmin=TVAN.min(), vmax=TVAN.max()) # Contour plot contour = ax.contourf(MX, TX, TVAN, levels=20, cmap=\"viridis\", norm=norm) ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel(r'$m_\\chi$ [MeV]') ax.set_ylabel(r'$T_\\chi$ [MeV]') # Color bar cbar = fig.colorbar(contour, ax=ax) cbar.set_label(r\"$t_{\\rm van}$ [yrs]\") plt.show() Notes Practically speaking, the underlying algorithm of snorer.get_tvan is not vectorized. It relies on numpy.nditer to support vectorized inputs/outputs. The kernel of snorer.get_tvan is the internal function snorer._get_tof which has the same Parameters and Returns as snorer.get_tvan but only accepts scalar inputs/outputs. It could become clumsy when the points to be calcuated are massive.","title":"get_tvan"},{"location":"api/kinematics/get_tvan/#snorerget_tvan","text":"","title":"snorer.get_tvan"},{"location":"api/kinematics/get_vx/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_vx \u00b6 ssnorer.get_vx( Tx , mx ) \u00b6 Get dimensionless BDM velocity \\(v_\\chi/c\\) . See BDM Physics for detail. Parameters: Tx : array_like BDM kinetic energy \\(T_\\chi\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV Returns: out : scalar/ndarray Dimensionless BDM velocity. out is scalar if all inputs are scalars.","title":"get_vx"},{"location":"api/kinematics/get_vx/#snorerget_vx","text":"","title":"snorer.get_vx"},{"location":"api/main/differential_flux/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.differential_flux \u00b6 snorer.differential_flux( t , Tx , mx , theta , phi , Rs , beta , Re=8.5 , sigxv0=1e-45 , is_spike=False , **kwargs ) \u00b6 The differential supernova-neutrin-boosted dark matter flux at Earth at specific time \\(t\\) and angular direction \\((\\theta,\\varphi)\\) \\[ \\left.\\sin\\theta\\mathcal{J}j_\\chi(d,r,T_\\chi,\\psi)\\right|_{t=\\frac{d}{c}+\\frac{\\ell}{v_\\chi}-t_\\nu}. \\] This is the integrand of Eq. (18) in BDM Physics , cf. Fig. 1 too. Parameters: t : float Time \\(t\\) , relative to the SN \\(\\nu\\) 's arrival Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. theta : float The zenith angle \\(\\theta\\) , rad. phi : float The azimuthal angle \\(\\varphi\\) that centers SN, rad. Rs : floate Distance from supernova to Earth, kpc. beta : floate The off-center angle, characterizes how SN deviates from GC-Earth axis angularly, rad. Re : floate The distance from GC to Earth, kpc. Default is 8.5 kpc. sigxv0 : float* Total DM- \\(\\nu\\) cross section, cm 2 . It will be multiplied by snorer.get_gx to account for the angular distribution and makes it cm 2 sr \u22121 . is_spike : bool Is halo spike included? Default is False . **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.min_distance , snorer.params.halo and snorer.params.spike . Returns: out : scalar The differential BDM flux at Earth, MeV \u22121 cm \u22122 s \u22121 sr \u22121 .","title":"differential_flux"},{"location":"api/main/differential_flux/#snorerdifferential_flux","text":"","title":"snorer.differential_flux"},{"location":"api/main/dsigma_xv/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.dsigma_xv \u00b6 snorer.dsigma_xv( Ev , mx , psi , sigxv0='1e-45' ) \u00b6 Differential DM- \\(\\nu\\) scattering cross section at angle \\(\\psi\\) in lab frame, $$ \\frac{d\\sigma_{\\chi\\nu}}{d\\Omega_{\\rm lab}}=\\sigma_0 \\times g_\\chi(\\psi). $$ See Eqs. (2) and (3) in BDM Physics . Parameters: Ev : array_like Neutrino energy, MeV. mx : array_like Dark matter mass, MeV. psi : array_like Lab frame scattering angle \\(\\psi \\in [0,\\pi/2]\\) . sigxv0 : array_like Energy-independent DM- \\(\\nu\\) cross section \\(\\sigma_0\\) , cm 2 . Default is \\(10^{-45}\\) cm 2 . Returns: out : scalar/ndarray Differential DM- \\(\\nu\\) cross section, cm 2 sr \u22121 . Out is scalar if all inputs are scalars. Notes The result is simply sigxv0 * snorer.get_gx . See also snorer.get_gx .","title":"dsigma_xv"},{"location":"api/main/dsigma_xv/#snorerdsigma_xv","text":"","title":"snorer.dsigma_xv"},{"location":"api/main/emissivity_jx/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.emissivity_jx \u00b6 snorer.emissivity_jx( Ev , dEv , mx , d , r , psi , sigxv0=1e-45 , d_cut=3.24e-15 , is_spike=False , **kwargs ) \u00b6 Emissivity \\(j_\\chi\\) of supernova-neutrino-boost dark matter at boost point. See Eq. (13) in BDM Physics . Parameters: Ev : array_like The supernova neutrino energy, MeV. dEv : array_like The Jacobian \\((dE_\\nu/dT_\\chi)(v_\\chi/c)\\) that converts per netrino energy width, \\(dE_\\nu\\) , to per BDM kinetic energy width, \\(dT_\\chi\\) . mx : array_like Dark matter mass, MeV. d : array_like Distance from supernova to boost point, kpc. r : array_like Distance from galactic center to boost point, kpc. psi : array_like The scattering angle in lab frame at boost point, rad. sigxv0 : float* Total DM- \\(\\nu\\) cross section, cm 2 . It will be multiplied by snorer.get_gx to account for the angular distribution and makes it cm 2 sr \u22121 . d_cut : float Terminating point for \\(d\\) . Below the value will return 0. Default is \\(3.24\\times 10^{-15}\\) kpc, approximating 100 km, the size of neutrino sphere. is_spike : bool Whether spike feature is included in \\(n_\\chi\\) . Default is False. **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.halo and snorer.params.spike . Returns: out : scalar/ndarray BDM emissivity at boost point along the direction \\(\\psi\\) , MeV \u22121 cm \u22123 s \u22121 sr \u22121 .","title":"emissivity_jx"},{"location":"api/main/emissivity_jx/#snoreremissivity_jx","text":"","title":"snorer.emissivity_jx"},{"location":"api/main/event/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.event \u00b6 snorer.event( mx , Rs , beta , Re=8.5 , Tx_range=[5,30] , t_range=[10,1.1045e+09] , sigxv0=1e-45 , is_spike=False , **kwargs ) \u00b6 The supernova-neutrino-boosted dark matter evnet per electron with DM- \\(e\\) cross section \\(\\sigma_{\\chi e}\\) normalized to 1 cm 2 at Earth. The field-of-view \\(d\\Omega\\) is integrated over entirely and the kinetic energy \\(T_\\chi\\) , exposure time \\(t\\) can be integrated within user-defined ranges. Precisely speaking, the event \\(N_\\chi\\) is, using Eqs. (18) in BDM Physics , \\[ N_\\chi = N_e \\sigma_{\\chi e} \\int_{t_{\\rm min}}^{t_{\\rm max}} dt \\int_{T_{\\chi,{\\rm min}}}^{T_{\\chi,{\\rm max}}} dT_\\chi \\frac{d\\Phi_\\chi}{dT_\\chi} \\] and snorer.event presumes \\(N_e=1\\) and \\(\\sigma_{\\chi e}=1\\) cm 2 . One can restore the correct \\(N_\\chi^{\\rm correct}\\) for any detector by multiplying the true \\(N_e^{\\rm true}\\) for that detector and \\(\\sigma_{\\chi e}^{\\rm true}\\) , \\[ N_\\chi^{\\rm correct} = N_\\chi \\times \\frac{N_e}{1}\\times \\frac{\\sigma_{\\chi e}^{\\rm true}}{1 \\,{\\rm cm^2}} \\times \\frac{\\sigma_{\\chi\\nu}^{\\rm true}}{10^{-45}\\,{\\rm cm^2}} \\] where we have set \\(\\sigma_{\\chi \\nu}=10^{-45}\\) cm 2 by default in the function. Parameters: mx : float Dark matter mass, MeV. Rs : floate Distance from supernova to Earth, kpc. beta : floate The off-center angle, characterizes how SN deviates from GC-Earth axis angularly, rad. Re : floate The distance from GC to Earth, kpc. Default is 8.5 kpc. Tx_range : list Integration range for BDM kinetic energy [Tx_min,Tx_max] , MeV t_range : list Integration range for exposure time [t_min,t_max] , seconds sigxv0 : float* Total DM- \\(\\nu\\) cross section, cm 2 . It will be multiplied by snorer.get_gx to account for the angular distribution and makes it cm 2 sr \u22121 . is_spike : bool Is halo spike included? Default is False . **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.min_distance , snorer.params.halo , snorer.params.spike and snorer.params.vegas . Returns: out : scalar Event number of supernova-neutrino-boosted dark matter per electron. Notes We also use vegas to evaluate \\(N_\\chi\\) . See Notes in snorer.flux .","title":"event"},{"location":"api/main/event/#snorerevent","text":"","title":"snorer.event"},{"location":"api/main/flux/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.flux \u00b6 snorer.flux( t , Tx , mx , Rs , beta , Re=8.5 , sigxv0=1e-45 , is_spike=False , **kwargs *) \u00b6 The supernova-neutrino-boosted dark matter flux at time \\(t\\) on Earth after integrated over a field-of-view \\(d\\Omega\\) . Note that zenith angle \\(\\theta\\) is integrated up to \\(\\theta^*_M\\) and azimuthal angle \\(\\varphi\\) from \\(0\\) to \\(2\\pi\\) . See Eqs. (18) and (24) in BDM Physics , cf. Fig. 1 too. Parameters: t : float Time \\(t\\) , relative to the SN \\(\\nu\\) 's arrival Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. Rs : floate Distance from supernova to Earth, kpc. beta : floate The off-center angle, characterizes how SN deviates from GC-Earth axis angularly, rad. Re : floate The distance from GC to Earth, kpc. Default is 8.5 kpc. sigxv0 : float* Total DM- \\(\\nu\\) cross section, cm 2 . It will be multiplied by snorer.get_gx to account for the angular distribution and makes it cm 2 sr \u22121 . is_spike : bool Is halo spike included? Default is False . **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.min_distance , snorer.params.halo , snorer.params.spike and snorer.params.vegas . Returns: out : scalar The differential BDM flux at Earth, MeV \u22121 cm \u22122 s \u22121 sr \u22121 . Notes We use vegas to evaluate the integral Eq. (18). This explains why we incorporate nitn and neval in keyword arguments. Increasing these values will improve the accuracy but the computation time enhances too. One may need to find a balance between acceptable accuracy and evaluation time.","title":"flux"},{"location":"api/main/flux/#snorerflux","text":"","title":"snorer.flux"},{"location":"api/main/sn_nu_spectrum/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.sn_nu_spectrum \u00b6 snorer.sn_nu_spectrum( Ev , d , d_cut=3.24e-15 , is_density=False ) \u00b6 Supernova neutrino spectrum at distance \\(d\\) to supernova, $$ \\frac{dN_\\nu}{dE_\\nu}=\\sum_i\\frac{L_{\\nu_i}}{4\\pi d^2\\langle E_{\\nu_i}\\rangle} f_{\\nu_i}(E_\\nu). $$ See Eqs. (9-12) in BDM Physics for detail. Parameters: Ev : array_like Supernova neutrino energy, MeV. d : array_like Distance from supernova to the boost point, kpc. d_cut : float Terminating point for \\(d\\) . Below the value will return 0. Default is \\(3.24\\times 10^{-15}\\) kpc, approximating 100 km, the size of neutrino sphere. is_density : bool Should convert the output to the unit of number density. Default is False and output has the unit of flux. Returns: out : scalar/ndarray Outputs flux [MeV \u22121 cm \u22122 s \u22121 ] when is_density = False , or number density [MeV \u22121 cm \u22123 ] when is_density = True . The output is scalar if all inputs are scalars. Examples In this example, we show \\(dN_\\nu/dE_\\nu\\) over \\((E_\\nu,d)\\) plane. One can clearly see that \\(d<\\) d_cut the flux is 0. import numpy as np import matplotlib.pyplot as plt import matplotlib.colors as mcolors import snorer as sn Ev_vals = np.logspace(-3,2,100) # Ev values d_vals = np.logspace(-16,2,200) # d values # Setup meshgrid for (Ev,d) plane Ev,D = np.meshgrid(Ev_vals,d_vals,indexing='ij') # Evaluate SNv flux DNvDEv = sn.sn_nu_spectrum(Ev,D) # Plot fig, ax = plt.subplots() # log-scaler color norm = mcolors.LogNorm(vmin=DNvDEv.min() + 1, vmax=DNvDEv.max()) # Contour plot contour = ax.contourf(Ev, D, DNvDEv, levels=20, cmap=\"viridis\", norm=norm) ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel(r'$E_\\nu$ [MeV]') ax.set_ylabel(r'$d$ [kpc]') # Color bar cbar = fig.colorbar(contour, ax=ax) cbar.set_label(r\"$dN_\\nu/dE_\\nu$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]\") plt.show()","title":"sn_nu_spectrum"},{"location":"api/main/sn_nu_spectrum/#snorersn_nu_spectrum","text":"","title":"snorer.sn_nu_spectrum"},{"location":"api/params/params/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.params \u00b6 class snorer.params \u00b6 This class contains default parameters that will be used in many functions as keyword arguments ( **kwargs ). Four classes of parameters are predefined and incorporated as attributes in this class. We illustrate them in the followings. snorer.params.min_distance \u00b6 Instance. Attributes: d_cut : float Terminating point for \\(d\\) . Below this value snorer.sn_nu_spectrum will return 0. Default is \\(3.24\\times 10^{-15}\\) kpc, approximating 100 km, the size of neutrino sphere. r_cut : float Terminating \\(n_\\chi\\) when \\(r^\\prime <\\) r_cut , kpc. Below this value snorer.differential_flux will return 0. If one needs to incorporate dark matter spike in the central region, r_cut cannot be too large. Otherwise, the spike effect will be chopped off before it has any noticeble consequence. Default is \\(10^{-8}\\) kpc. snorer.params.halo \u00b6 Instance. Attributes: rhos : float Characteristic density, MeV cm \u22123 . Default is 184. rs : float Characteristic length, kpc. Default is 24.4. n : float Index for the halo. Default is 2. snorer.params.spike \u00b6 Instance. The following will be used as keyword arguments when is_spike = True . When having is_spike = False , typing any of the following arguments into function input will result in ValueError. Attributes: mBH : float Supermassive black hole (SMBH) mass, \\(M_\\odot\\) . Default is \\(4.29\\times 10^6\\) . tBH : float SMBH age, years. Default is \\(10^9\\) . rh : float SMBH influence radius, kpc. Defaut is 0.002. alpha : str Profile slope for halo spike, '3/2' or '7/3' . Default is '3/2' . sigv : None or float DM annihilation cross section, in the unit of \\(10^{-26}\\) cm 3 s \u22121 . None indicates no annihilation and 5.9 as \\(5.9\\times 10^{-26}\\) . snorer.params.vegas \u00b6 Instance. Attributes: nitn : int Number of chains in vegas for each integration. Default is 10. neval : int Number of evaluationg points in each chain in vegas . Default is 10000. Notes What type or types of parameters are contained in **kwargs of that function will be documented in its docstrings. Suppose the docstrings says the keywaord arguments containing the values in min_distance , halo and spike , it means all the attributes in the above theree categories can be used as keyword arguments in that function. We illustrate this in the following example. Examples Let's take snorer.event as an example. By looking at its doc page, the necessary **kwargs at least contains: rhos , rs , n , d_cut , r_cut , nitn and neval . However if one sets is_spike = True , then the followings: mBH , tBH , rh , alpha and sigv are also mandatory. If user didn't specify any of them above, they snorer will use default values listed above. For instance, without any keyword argument specification >>> import snorer as sn # import snorer >>> mx,Rs,beta = 1e-2,8.5,0.3 >>> event = sn.event(mx,Rs,beta) # none of the kwargs is specified. >>> print(event) 1.4301996553521633e-06 If we want to specify rhos and mBH , we can do >>> event_spike = sn.event(mx,Rs,beta,is_spike=True,rhos=500,mBH=1e7) >>> print(event_spike) 3.883407626493457e-06 Note that event_spike is slightly larger than event due to we turn on spike feature. However, the enhancement is not drastic due to supernova is not exactly located at the center as beta is not 0. If we remove is_spike , then the program uses default is_spike = False . This will result in ValueError due to mBH only valid when spike feature turns on.","title":"Parameters"},{"location":"api/params/params/#snorerparams","text":"","title":"snorer.params"},{"location":"api/utils/BDM/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.BoostedDarkMatter \u00b6 class snorer.BoostedDarkMatter( Rs , Rg , beta , amp2_xv , amp2_xe , mt=None , is_spike=False , **kwargs ) \u00b6 Superclass: Constants Class with medoths that evaluate supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) coming from SN in arbitrary distant galaxy with DM- \\(\\nu\\) and DM- \\(e\\) interaction cross sections descrbied by a specific particle model. This class integrates functions like snorer.flux and snorer.event as methods for user to calculate the SN \\(\\nu\\) BDM flux and event associated to any models. To construct the scattering amplitude \\(\\mathcal{M}\\) from a specific model, we take the one discussed in Ref. [ 1 ] for instance. Both DM- \\(\\nu\\) and DM- \\(e\\) have the same amplitude square \\(|\\mathcal{M}|^2\\) shown by Eq. (3) of Ref. [ 1 ] in terms of Mandelstam variables \\(s\\) , \\(t\\) , and \\(u\\) , \\[ |\\mathcal{M}|^2 = 2 \\left(\\frac{\\mathcal{Q}}{t} - m_V^2\\right)^2 (s^2 + u^2 + 4t (m_1^2 + m_2^2) - 2 (m_1^2 + m_2^2)^2) \\] where \\(\\mathcal{Q}\\) is the multiplication of coupling constants, \\(m_1\\) and \\(m_2\\) are the masses of incident and target particles respectively and \\(m_V\\) the mediator mass. Thus we can construct DM- \\(\\nu\\) amplitude square by letting, \\(m_1 = 0\\) and assume \\(m_V = m_\\chi/3\\) , \\(g_V = 10^{-6}\\) and \\(g_\\chi = 10^{-2}\\) , def amp2_xv(s,t,u,mx) -> float: mV = mx/3 gV,gx = 1e-06,1e-02 Q = gV*gx return (s**2 + u**2 + 4*t*(mx**2) - 2*(mx**2)**2)*(Q/(t - mV**2))**2 Similarily, for DM- \\(e\\) scattering, \\(m_1 = m_\\chi\\) , \\(m_2 = m_e\\) and kinetic mixing \\(\\varepsilon = 10^{-6}\\) , def amp2_xe(s,t,u,mx) -> float: mV = mx/3 me = snorer.constant.me gx,eps = 1e-02,1e-06 Q = gx*eps return 2*(s**2 + u**2 + 4*t*(me**2 + mx**2) - 2*(me**2 + mx**2)**2)*(Q/(t - mV**2))**2 These are the desired amplitudes and serve as the inputs in the class. Parameters: Rs : float Distance from Earth to SN, kpc. Rg : float Distance from Earth to the center of a distant galaxy, kpc. beta : float Off-center angle, rad. amp2_xv : func Amplitude squared for DM- \\(\\nu\\) interaction with 4 positioning arguments. amp2_xv = func(s,t,u,mx) : the first 3 are Mandelstam variables and the last one is the DM mass. amp2_xe : func Arguments are identical to amp2_xv , but is for DM- \\(e\\) interaction. Generally, amp2_xe is not exclusively for electron, user can assume any particle in the detector to be scattered off by BDM. If the target is not electron, user has to input its mass mt . See the description for parameter mt next. mt : None/float Mass of the target in the detector. Default is None and implies the target is electron. If amp2_xe is for particle other than electron, user has to assign its mass here. The unit is MeV. is_spike : bool Whether spike feature is included in \\(n_\\chi\\) . Default is False. **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.halo and snorer.params.spike . nx( r , mx ) \u00b6 Method. Yields DM number density at place distant \\(r\\) to GC. Whether spike feature is on depending the initial setting of is_spike when the class instance is initialized. Parameters: r : float Distance from Earth to GC, kpc. mx : float Dark matter mass, MeV. Returns: out : float Dark matter number density at \\(r\\) , cm \u22123 . dsigma_xv( Tx , mx , psi ) \u00b6 Method. Yields differential DM- \\(\\nu\\) cross section for a given \\((T_\\chi,m_\\chi,\\psi)\\) associated with amp2_xv . Parameters: Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. psi : float Scattering angle in lab frame, rad. Returns: out : float Differential DM- \\(\\nu\\) cross section, cm 2 sr \u22121 . sigma_xe( Tx , mx ) \u00b6 Method. Yields total DM- \\(e\\) cross section for a given \\((T_\\chi,m_\\chi)\\) associated with amp2_xe . Parameters: Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. Returns: out : float Total DM- \\(e\\) cross section, cm 2 . flux( t , Tx , mx , **kwargs ) \u00b6 Method. The SN \\(\\nu\\) BDM flux at time \\(t\\) on Earth after integrated over a field-of-view \\(d\\Omega_{\\rm lab}\\) . Note that zenith angle \\(\\theta\\) is integrated up to \\(\\theta_{\\rm M}^*\\) and azimuthal angle \\(\\varphi\\) from \\(0\\) to \\(2\\pi\\) . Parameters: t : float The BDM ToF, relative to the first SN neutrino's arrival. Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. **kwargs Keyword arguments for min distances and vegas. See default arguments in snorer.params.min_distance and snorer.params.vegas . Returns: out : float The time-depenent boosted dark matter flux at Earth, MeV \u22121 cm 2 s \u22121 . event( mx , Tx_range=[5,30] , t_range=[10,1.1045e+09] , **kwargs ) \u00b6 Method. The SN \\(\\nu\\) BDM evnet per electron , \\(N_{\\chi,0}\\) . To retrieve the correct event number, one should mutiply the total electron number \\(N_e\\) . For instance, if the BDM event rate obtained from this function is \\(N_\\chi\\) , then the total BDM event in a detector with electron number \\(N_e\\) is \\[ N_\\chi^{\\rm correct} = N_e\\times N_{\\chi,0}. \\] Parameters: mx : float Dark matter mass, MeV. Tx_range : list Integration range for BDM kinetic energy [Tx_min,Tx_max] , MeV. Default is [5,30] . t_range : list Integration range for exposure time [t_min,t_max] , seconds. Default is [10,1.1045e+09] and implies t_max is around 35 years. **kwargs Keyword arguments for min distances and vegas. See default arguments in snorer.params.min_distance and snorer.params.vegas . Returns: out : float Event number of SN \\(\\nu\\) BDM per electron. References \u00b6 Y.-H. Lin et al. , Phys. Rev. D 108 , 083013 (2023)","title":"BoostedDarkMatter"},{"location":"api/utils/BDM/#snorerboosteddarkmatter","text":"","title":"snorer.BoostedDarkMatter"},{"location":"api/utils/coord_transf/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; Coordinate Transformations \u00b6 We briefly introduce how to extract the off-center angle \\(\\beta\\) , cf. Fig. 1 in BDM Physics , from two famous astronomical coordinate systems, galactic and equatorial coordinates. This aids us to input arbitrary supernova (SN) loactions from astrophysical database, eg. SRcat , into snorer and evaluates its BDM signature. Galactic coordinate \u00b6 The galactic coordinate is shown in Fig. 1 with its longitute \\(\\ell\\) and latitude \\(b\\) . Once \\((\\ell,b)\\) for a SN is specified, its position on the celestial sphere is marked. Figure 1. The galactic coordinate, including longitutde \\(\\ell\\) and latitude \\(b\\). Given that the distance from Earth to SN, \\(R_s\\) , will be provided by the database, the last task is to retrieve \\(\\beta\\) . Before proceed, there are two conventions in this coordinate. In terms of Cartesian representation, the Earth is at the origin and the galactic center (GC) at \\((x,y,z)=(0,R_e,0)\\) . See the lateral view to this geometrical system in Fig. 2 . Figure 2. The Cartesian representation of galactic coordinate with distance included. With two unit vectors that one points from Earth to SN \\(\\hat{\\mathbf{s}} = (x_s,y_s,z_s)/R_s\\) and the other points from Earth to GC \\(\\hat{\\mathbf{g}} = (0,1,0)\\) , we immediately obtain \\[ \\begin{equation} y_s = R_s \\cos b \\cos\\ell \\end{equation} \\] The reason why we don't need \\(x_s\\) and \\(z_s\\) is clear that when we evaluate \\(\\beta\\) , \\[ \\begin{equation}\\label{eq:cos_beta_MW} \\cos\\beta = \\hat{\\mathbf{g}}\\cdot \\hat{\\mathbf{s}} = \\cos b\\cos\\ell \\end{equation} \\] there is no need for these two. Note that when we retrieve \\(\\beta\\) from galactic coordinate, there is impossible to transform it back. It is obvious that \\(\\beta\\) to \\((\\ell,b)\\) is a one to two transformation. Without one additional constraint, the reverse is ill-posed. Reconstructing the SN location relative to galactic plane is implausible simply by \\(\\beta\\) . For completeness, to have the exact location, the missing information one needs is the azimuthal angle, say, around the Earth-GC axis. This requires both \\(x_s\\) and \\(z_s\\) . We omit the detail here due to its irrelevance. Supernova in arbitrary distant galaxy \u00b6 We now consider a more general case that SN lies in a arbitrary distant galaxy and we want to know the BDM signature from that SN. Again, no matter how this scene chages, the underlying concept is to obtain three things: \\(R_g\\) , \\(R_s\\) and \\(\\beta\\) . The last two are quite familiar but the first one indicates the distance between Earth and the center of the distant galaxy. On the other hand, we actually replace \\(R_e\\) by \\(R_g\\) . See Fig. 3 . Figure 3. SN in arbitrary distant galaxy. Suppose the galactic coordinates for the two stellar objects are \\((\\ell_s,b_s)\\) and \\((\\ell_g,b_g)\\) respectively, we can follow the previous derivation to obtain their Cartesian representations \\((x_s,y_s,z_s)\\) and \\((x_g,y_g,z_g)\\) . Thus \\[ \\begin{align*} x_s &= R_s \\cos b_s \\sin (2\\pi- \\ell_s), \\\\ y_s & = R_s \\cos b_s \\cos \\ell_s, \\\\ z_s & = R_s \\sin b_s \\end{align*} \\] for SN and \\[ \\begin{align*} x_g &= R_g \\cos b_g \\sin (2\\pi- \\ell_g), \\\\ y_g & = R_g \\cos b_g \\cos \\ell_g, \\\\ z_g & = R_g \\sin b_g \\end{align*} \\] for the distant galaxy. We define two unit vectors for the two stellar objects $$ \\hat{\\mathbf{s}}=(-\\cos b_s \\sin \\ell_s, \\cos b_s \\cos \\ell_s,\\sin b_s) $$ and $$ \\hat{\\mathbf{g}}=(-\\cos b_g \\sin \\ell_g, \\cos b_g \\cos \\ell_g,\\sin b_g) $$ respectively. The off-center angle \\(\\beta\\) can be retrieved by the same formula \\[ \\begin{equation} \\cos \\beta = \\hat{\\mathbf{g}}\\cdot\\hat{\\mathbf{s}} = \\cos b_s \\cos b_g \\cos(\\ell_s - \\ell_g) + \\sin b_s \\sin b_g. \\end{equation} \\] In terms of our Milky Way, \\(\\ell_g = b_g=0\\) , we recover Eq. \\(\\eqref{eq:cos_beta_MW}\\) . Equatorial coordinate \u00b6 Another commonly used coordinate system is the equatorial coordinate and is specified by right ascension \\(\\alpha\\) (RA) and declination \\(\\delta\\) (DEC). Due to its complexity, we do not provide any detail mathematical conversion from \\((\\alpha,\\delta)\\) to \\(\\beta\\) here. To tackle this task, we employ Astropy to resolve \\((\\ell,b)\\) from \\((\\alpha,\\delta)\\) . Then proceed the discussion in the last section to recover \\(\\beta\\) . Note that we will assume the input \\((\\alpha,\\delta)\\) in snorer is expressed in terms of ICRS J2000.0.","title":"Coordinate Transformations"},{"location":"api/utils/coord_transf/#coordinate-transformations","text":"We briefly introduce how to extract the off-center angle \\(\\beta\\) , cf. Fig. 1 in BDM Physics , from two famous astronomical coordinate systems, galactic and equatorial coordinates. This aids us to input arbitrary supernova (SN) loactions from astrophysical database, eg. SRcat , into snorer and evaluates its BDM signature.","title":"Coordinate Transformations"},{"location":"api/utils/coord_transf/#galactic-coordinate","text":"The galactic coordinate is shown in Fig. 1 with its longitute \\(\\ell\\) and latitude \\(b\\) . Once \\((\\ell,b)\\) for a SN is specified, its position on the celestial sphere is marked. Figure 1. The galactic coordinate, including longitutde \\(\\ell\\) and latitude \\(b\\). Given that the distance from Earth to SN, \\(R_s\\) , will be provided by the database, the last task is to retrieve \\(\\beta\\) . Before proceed, there are two conventions in this coordinate. In terms of Cartesian representation, the Earth is at the origin and the galactic center (GC) at \\((x,y,z)=(0,R_e,0)\\) . See the lateral view to this geometrical system in Fig. 2 . Figure 2. The Cartesian representation of galactic coordinate with distance included. With two unit vectors that one points from Earth to SN \\(\\hat{\\mathbf{s}} = (x_s,y_s,z_s)/R_s\\) and the other points from Earth to GC \\(\\hat{\\mathbf{g}} = (0,1,0)\\) , we immediately obtain \\[ \\begin{equation} y_s = R_s \\cos b \\cos\\ell \\end{equation} \\] The reason why we don't need \\(x_s\\) and \\(z_s\\) is clear that when we evaluate \\(\\beta\\) , \\[ \\begin{equation}\\label{eq:cos_beta_MW} \\cos\\beta = \\hat{\\mathbf{g}}\\cdot \\hat{\\mathbf{s}} = \\cos b\\cos\\ell \\end{equation} \\] there is no need for these two. Note that when we retrieve \\(\\beta\\) from galactic coordinate, there is impossible to transform it back. It is obvious that \\(\\beta\\) to \\((\\ell,b)\\) is a one to two transformation. Without one additional constraint, the reverse is ill-posed. Reconstructing the SN location relative to galactic plane is implausible simply by \\(\\beta\\) . For completeness, to have the exact location, the missing information one needs is the azimuthal angle, say, around the Earth-GC axis. This requires both \\(x_s\\) and \\(z_s\\) . We omit the detail here due to its irrelevance.","title":"Galactic coordinate"},{"location":"api/utils/coord_transf/#equatorial-coordinate","text":"Another commonly used coordinate system is the equatorial coordinate and is specified by right ascension \\(\\alpha\\) (RA) and declination \\(\\delta\\) (DEC). Due to its complexity, we do not provide any detail mathematical conversion from \\((\\alpha,\\delta)\\) to \\(\\beta\\) here. To tackle this task, we employ Astropy to resolve \\((\\ell,b)\\) from \\((\\alpha,\\delta)\\) . Then proceed the discussion in the last section to recover \\(\\beta\\) . Note that we will assume the input \\((\\alpha,\\delta)\\) in snorer is expressed in terms of ICRS J2000.0.","title":"Equatorial coordinate"},{"location":"api/utils/equa_to_beta/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.equatorial_to_beta \u00b6 snorer.equatorial_to_beta( ra , dec , GC_coord=None ) \u00b6 Transform equatorial coordinate to off-center angle and galactic coordinate \\((\\beta,\\ell,b)\\) . Parameters: ra : array_like Right ascension, hms in string type. Eg. '5h6.7m4.4s' . dec : array_like Declination, dms in string type. Eg. '6d10.7m9.4s' . GC_coord : None/list The equatorial coordinate for arbitrary galactic center. Default is None , which automatically implements our Milky Way center. For a specific GC coordinate, it should have GC_coord = [RA,DEC] where RA and DEC are, similar to ra and dec , in hms and dms units respectively. Additionally, they should be subject to ICRS J2000.0. Returns: out : tuple Tuple of \\((\\beta,\\ell,b)\\) in rad. Each component is scalar if all inputs are scalars. Notes We rely on astropy.coordinates.SkyCoord in Astropy to resolve \\((\\ell,b)\\) from \\((\\alpha,\\delta)\\) and obtain \\(\\beta\\) by snorer.galactic_to_beta .","title":"equatorial_to_beta"},{"location":"api/utils/equa_to_beta/#snorerequatorial_to_beta","text":"","title":"snorer.equatorial_to_beta"},{"location":"api/utils/gal_to_beta/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.galactic_to_beta \u00b6 snorer.galactic_to_beta( l , b , GC_coord=[0,0] ) \u00b6 Transform galactic coordinate \\((\\ell,b)\\) to off-center angle \\(\\beta\\) . See Eqs. (2) in Coordinate Transformations . Parameters: l : array_like Galactic longitude, rad. b : array_like Galactic latitude, rad. GC_coord : list Galactic coordinate for arbitrary galactic center \\((\\ell_g,b_g)\\) . Default is Milky Way center GC_coord = [0,0] . Returns: out : scalar/ndarray Off-center angle \\(\\beta\\) , rad. The result is scalar if all inputs are scalars.","title":"galactic_to_beta"},{"location":"api/utils/gal_to_beta/#snorergalactic_to_beta","text":"","title":"snorer.galactic_to_beta"},{"location":"manual/advanced/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } Advanced Topics \u00b6 We introduce some advanced usage in this document. In the following content, all equation numbers refer to BDM Physics unless specified otherwise. First, import the necessary packages: # import python packages import numpy as np import ipyparallel as ipp # import plotting package import matplotlib.pyplot as plt import matplotlib.colors as mcolors # uncomment the following two lines if you have a Hi-DPI monitor and wish to have a better figure resolution %matplotlib inline %config InlineBackend.figure_format='retina' # import snorer import snorer as sn print(f'Current version of snorer: {sn.__version__}') Current version of snorer: 2.0.0 Distribution across the celestial sphere \u00b6 We draw how supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) distributes across the sky. We use Cassiopeia A (Cas A) to be our SN in this example. Its \\(\\alpha\\) and \\(\\delta\\) are 23h23m24s and 58d49m00s respectively and \\(R_s\\approx 3.5\\) kpc. Hence, we obtain the off-center angle \\(\\beta\\) and its galactic coordinate by casA_beta,l_sn,b_sn = sn.equatorial_to_beta('23h23m24s','58d49m00s') print(f\"The off-center angle for Cas A approximates {casA_beta:.3f} rad.\") The off-center angle for Cas A approximates 1.950 rad. To evaluate the distribution across the sky, it is equivalent to draw \\[ \\begin{equation} \\left.\\frac{d\\Phi_\\chi}{dT_\\chi d\\Omega} = \\tau_s \\mathcal{J} j_\\chi\\right|_{t=\\frac{d}{c}+\\frac{\\ell}{v_\\chi}-t_\\nu} \\end{equation} \\] on the celestial sphere spanned by the galactic coordinate \\(\\ell\\) and \\(b\\) . The corresponding function in snorer is sn.differential_flux with 10 parameters. The first seven t , Tx , mx , theta , phi , Rs , beta are mandatory and the last three Re = 8.5 , sigxv0 = 1e-45 and is_spike = False are optional. Note that theta and phi are the zenith and azimuthal angles, cf. Fig. 1 in BDM Physics. Figure 1. Cas A and its location \\((\\ell_s,b_s)\\) on the galactic coordinate. Another point \\((\\ell_0,b_0)\\) is also labeled. Suppose Cas A locates at \\((\\ell_s,b_s)\\) on the galactic coordinate shown in Fig. 1, another point \\((\\ell_0,b_0)\\) that is distant from Cas A by \\(\\theta\\) and rotates by \\(\\varphi\\) azimuthally. We can determined them through \\[ \\begin{equation} \\theta = \\sqrt{\\ell^{\\prime 2}+b^{\\prime 2}},\\quad {\\rm and} \\quad \\varphi= \\tan^{-1}\\left(\\frac{\\ell^\\prime}{b^\\prime}\\right) \\end{equation} \\] where \\[ \\begin{equation} \\ell^\\prime = \\ell_0 - \\ell_s\\quad{\\rm and}\\quad b^\\prime = b_0-b_s. \\end{equation} \\] With \\(\\theta\\) and \\(\\varphi\\) , we further apply both to sn.differential_flux to get the differential flux. Note that we will eventually display the result using the Aitoff projection and in matplotlib such projections \\(\\ell\\in[-\\pi,\\pi)\\) , thus we define a function wrap_angle to convert \\(\\ell\\) from \\([0,2\\pi)\\) to \\([-\\pi,\\pi)\\) . The step-by-step approach is to: Construct a canvas across the entire galactic coordinate Calculate the \\((\\theta,\\varphi)\\) for every point \\((\\ell,b)\\) on the canvas Put \\((\\theta,\\varphi)\\) into sn.differential_flux and retrieve the BDM differential flux at that point def wrap_angle(l): \"\"\"Confine longitudinal in -pi and pi\"\"\" return (l + np.pi) % (2 * np.pi) - np.pi # Setup DM properties Tx,mx = 5,1 Rs = 3.5 # kpc t = 350 * sn.constant.year2Seconds # Setup canvas for galactic coordinate l and b l_vals = np.linspace(-np.pi,np.pi,800) b_vals = np.linspace(-np.pi/2,np.pi/2,400) L,B = np.meshgrid(l_vals,b_vals,indexing=\"ij\") # Evaluate dtheta and dvarphi for each grid point on the canvas L_coord = wrap_angle(L - l_sn) # adjust galactic longitude to [-pi, pi) B_coord = B - b_sn dtheta = np.sqrt(L_coord**2 + B_coord**2) dphi = np.arctan2(L_coord,B_coord)%(2 * np.pi) # using atan2 and mod 2pi to convert galactic latitude to [-pi/2, pi/2) # Canvas to store the result diffFlux = np.zeros_like(L) with np.nditer([dtheta,dphi,diffFlux],op_flags=[['readonly'],['readonly'],['writeonly']]) as it: for theta,phi,flux in it: flux[...] = sn.differential_flux(t,Tx,mx,theta,phi,Rs,casA_beta) # Plot fig = plt.figure(figsize=(12, 5)) ax = fig.add_subplot(111,projection='aitoff') norm = mcolors.SymLogNorm(linthresh=diffFlux.max()/1e2, vmin=diffFlux.max()/5e1, vmax=diffFlux.max(), base=10) mesh = ax.pcolormesh(L , B, diffFlux, cmap='inferno', norm=norm, rasterized=True) cbar = fig.colorbar(mesh, ax=ax, orientation='vertical') cbar.set_label(r\"$d\\Phi_\\chi/dtd\\Omega$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$ sr$^{-1}$]\") # axis label style ax.tick_params(axis=\"x\", colors=\"white\") ax.grid(True,linestyle='--', linewidth=0.7) # axis ticks x_ticks = np.linspace(-np.pi + np.pi/6, np.pi - np.pi/6, 11) y_ticks = np.linspace(-np.pi/2, np.pi/2, 13) ax.set_xticks(x_ticks) # set galactic longitude tick labels ax.set_xticklabels([r'\u2212150\u00b0', '\u2212120\u00b0', '\u221290\u00b0', '\u221260\u00b0', '\u221230\u00b0', '0\u00b0', '30\u00b0', '60\u00b0', '90\u00b0', '120\u00b0', '150\u00b0']) ax.set_yticks(y_ticks) # set galactic latitude tick labels ax.set_yticklabels(['\u221290\u00b0', '\u221275\u00b0', '\u221260\u00b0', '\u221245\u00b0', '\u221230\u00b0', '\u221215\u00b0', '0\u00b0', '15\u00b0', '30\u00b0', '45\u00b0', '60\u00b0', '75\u00b0', '90\u00b0']) ax.set_title(r'Cas A: $(T_\\chi,m_\\chi)=(5,1)$ MeV',y=1.1) plt.show() Note the above is a particular slice of \\(T_\\chi\\) . For practical case, one should integrate sn.differential_flux over a range of \\(T_\\chi\\) due to none of the existing detectors having infinite energy resolution. User-defined scattering amplitude \u00b6 Functions sn.flux and sn.event and the core functions to construct them are all based on energy-independent cross sections \\(\\sigma_{\\chi\\nu}\\) and \\(\\sigma_{\\chi e}\\) . However, by introducing a specific particle model, cross sections are no longer energy-independent but depend on the Mandelstam variables and model parameters. Thus, sn.flux and sn.event are not applicable. To resolve this issue, we provide a class sn.BoostedDarkMatter to cope with. This class integrate all the functions to evaluate BDM flux and event and manipulating halo properties as class methods . Additionally, this class takes scattering amplitudes for \\(\\chi\\nu\\) and \\(\\chi e\\) interactions as its parameters and calculate \\(d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}\\) and \\(\\sigma_{\\chi e}\\) automatically. We illustrate this by the famous \\(L_{\\mu-\\tau}\\) model with DM component \\(\\chi\\) . The Lagrangian is \\[ \\begin{alignat}{1} \\mathcal{L}_\\chi \\supset & -\\frac{1}{4}V_{\\mu\\nu}V^{\\mu\\nu}+\\frac{\\varepsilon}{2\\cos\\theta_W}F_{\\mu\\nu}V^{\\mu\\nu}-\\frac{1}{2}m_V^2 V_\\mu V^\\mu \\nonumber \\\\ & \\quad -m_\\chi \\bar{\\chi}\\chi +g_\\chi V_\\mu \\bar{\\chi}\\gamma^\\mu \\chi \\nonumber \\\\ & \\quad +g_V V_\\mu Q_{\\alpha\\beta}\\left(\\bar{\\ell}_\\alpha\\gamma^\\mu \\ell_\\beta +\\bar{\\nu}_\\alpha \\gamma^\\mu P_L \\nu_\\beta\\right) \\end{alignat} \\] with the first line for kinetic mixing, the second line for dark sector interaction and the last for coupling between dark and lepton sector. The associated Feynman diagrams for \\(\\chi \\nu\\) and \\(\\chi e\\) scatterings are shown in Fig. 2. Figure 2. Feynman diagrams for \\(\\chi\\nu\\) (left) and \\(\\chi e\\) (right) scatterings described by \\(L_{\\mu-\\tau}\\) model. The amplitude squared \\(|\\mathcal{M}|^2\\) is given by \\[ \\begin{equation} |\\mathcal{M}|^{2} =2\\left(\\frac{\\mathcal{Q}}{t-m_{V}^{2}}\\right)^{2}[s^{2}+u^{2} +4t(m_{1}^{2}+m_{2}^{2}) -2(m_{1}^{2}+m_{2}^{2})^{2}], \\end{equation} \\] where \\(s\\) , \\(t\\) and \\(u\\) are Mandelstam variables and \\(m_1\\) and \\(m_2\\) are incoming and being scattered particles respectively. We can encode such information into python function by def amp2_xv(s,t,u,mx) -> float: \"\"\"DM-v scattering amplitude squared\"\"\" mV = mx/3 gV,gx = 1e-06,1e-02 Q = gV*gx return (s**2 + u**2 + 4*t*(mx**2) - 2*(mx**2)**2)*(Q/(t - mV**2))**2 def amp2_xe(s,t,u,mx) -> float: \"\"\"DM-e scattering amplitude squared\"\"\" mV = mx/3 me = 0.511 # MeV gx,eps = 1e-02,1e-06 Q = gx*eps return 2*(s**2 + u**2 + 4*t*(me**2 + mx**2) - 2*(me**2 + mx**2)**2)*(Q/(t - mV**2))**2 Both functions only take 4 positioning arguments with the first three are Mandelstam variables (MeV 2 ) and the last is DM mass (MeV). Other model parameters should be defined either in the function or somewhere else. They cannot be the function input(s). We again use Cas A as the example. First, build up the instance for Cas A BDM and given it is within our Milky Way, we have \\(R_g = R_e=8.5\\) kpc. casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) There are plenty of methods can be called in the instance casA_bdm . For example, we can examine the associated \\(d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}\\) and \\(\\sigma_{\\chi e}\\) : # Differential DM-v cross sections Tx,mx = 5,1 # Get maximumlly allowed psi psi_max = sn.get_psiMax(Tx,mx) psi_max -= psi_max/1000 # avoid diverge at psi_max psi_vals = np.linspace(0,psi_max,100) # differential sigma_xv dsigxv = [casA_bdm.dsigma_xv(Tx,mx,psi) for psi in psi_vals] # Plot plt.plot(psi_vals,dsigxv) plt.yscale('log') plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}$ [cm$^2$ sr$^{-1}$]') plt.show() # Differential DM-e cross sections mx = 1 Tx_vals = np.logspace(-5,2,100) # differential sigma_xv sigxe = [casA_bdm.sigma_xe(Tx,mx) for Tx in Tx_vals] # Plot plt.plot(Tx_vals,sigxe) plt.xscale('log') plt.yscale('log') plt.xlabel(r'$T_\\chi$ [MeV]') plt.ylabel(r'$\\sigma_{\\chi e}$ [cm$^2$]') plt.show() Now we are ready to evaluate the BDM flux and event. For flux, given Cas A exploded 350 years ago, it is already 350 year-old. We have to determine the vanishing time first. # Setup DM properties Tx,mx = 5,1 Rs = 3.5 # kpc tvan = sn.get_tvan(Tx,mx,Rs) print(f'Vanishing time is {tvan/sn.constant.year2Seconds:.2f} years.') Vanishing time is 557.07 years. Hence for \\((T_\\chi,m_\\chi)=(5,1)\\) MeV, \\(t_{\\rm van}=557.07\\) years. However, 350 years have passed, leaving only 207 years atmost before it ceases completely. We can use the flux method to evaluate. It takes 3 inputs: t , Tx and mx . Additional **kwargs determine the cut distances d_cut and r_cut for SN \\(\\nu\\) spectrum and halo profile, respectively, due to both are proportional \\(1/L^n\\) and diverges when \\(L\\to 0\\) . Others like nitn and neval are for vegas . Note that this method does not contain any **kwargs related to halo profile as the halo behavior is decided during the initialization of the instance. See their API pages: sn.BoostedDarkMatter and sn.params for detail. t0 = 350 * sn.constant.year2Seconds time_vals = np.linspace(t0,tvan,70) def get_casA_flux(t,Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe): \"\"\"flux\"\"\" import snorer as sn Tx,mx = 5,1 casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) return casA_bdm.flux(t,Tx,mx,neval=5000) # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_casA_flux, time_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results casA_flux = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_casA_flux: 0%| | 0/70 [00:00<?, ?tasks/s] Stopping engine(s): 1742019912 engine set stopped 1742019912: {'engines': {'0': {'exit_code': 0, 'pid': 35213, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 35214, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 35215, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 35216, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 35217, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 35201, 'identifier': 'ipcontroller-1742019911-edc4-31540'} plt.plot(time_vals/sn.constant.year2Seconds + 1675,casA_flux) plt.yscale('log') plt.ylim(3e-16,) plt.xlabel(r'Anno Domini') plt.ylabel(r'$d\\Phi_\\chi/dT_\\chi dt$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]') plt.show() To evaluate event number, rember the parameter t_range in sn.event is the integration range of time interval and starts from \\(t_0=10\\) seconds by default. But it is not the case for Cas A as 350 years has passed. We shoud begin \\(t_0=350\\) years and end with, say, 35 years after \\(t_0\\) . Hence, mx_vals = np.logspace(-6,2,35) def get_casA_event(mx,Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe): \"\"\"flux\"\"\" import snorer as sn t0 = 350 * sn.constant.year2Seconds tf = (350 + 35) * sn.constant.year2Seconds casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) try: event = casA_bdm.event(mx,t_range=[t0,tf],neval=15000) except: event = 0 return event # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_casA_event, mx_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results casA_event = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_casA_event: 0%| | 0/35 [00:00<?, ?tasks/s] engine set stopped 1742023011: {'engines': {'1': {'exit_code': 0, 'pid': 36515, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 36516, 'identifier': '2'}, '0': {'exit_code': 0, 'pid': 36514, 'identifier': '0'}, '3': {'exit_code': 0, 'pid': 36517, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 36518, 'identifier': '4'}}, 'exit_code': 0} Stopping engine(s): 1742023069 engine set stopped 1742023069: {'engines': {'0': {'exit_code': 0, 'pid': 36594, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 36595, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 36596, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 36597, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 36598, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 36580, 'identifier': 'ipcontroller-1742023068-i421-31540'} plt.scatter(mx_vals,casA_event) plt.xscale('log') plt.yscale('log') #plt.ylim(3e-16,) plt.xlabel(r'$m_\\chi$ [MeV]') plt.ylabel(r'$N_\\chi$ per electron') plt.show() Unlike sn.event which the result is normalized to per electron and \\(\\sigma_{\\chi e}=1\\) cm 2 , in this class instance, \\(\\sigma_{\\chi e}\\) is determined by user-specified \\(|\\mathcal{M}|^2\\) , thus the cross section is exact what user expects at such energy. One only needs to multiply the correct electron number \\(N_e\\) in that detector. For example, Super-K has \\(7\\times 10^{33}\\) electrons approximately, then the BDM event is \\[ N_\\chi^{\\rm SK} = N_e^{\\rm SK} \\times N_\\chi = 7\\times 10^{33} N_\\chi \\] In the above plot, one sees that no event when \\(m_\\chi\\lesssim 500\\) keV. It is because the corresponding \\(t_{\\rm van}\\) for \\(m_\\chi\\) and \\(T_\\chi\\) -integrated range are much smaller than 350 years. Thus BDM from Cas A no longer exists at the present day. DM-nucleus scattering \u00b6 We discuss a more general case when target in the detector is not electron. Though by default sn.BoostedDarkMatter assumes \\(\\chi e\\) scattering, but the parameter amp2_xe is not exclusively for \\(\\chi e\\) interaction. To elaborate, we assume the target to be interacted is Xenon with target mass approximating \\(m_t = 1.3\\times 10^5\\) MeV. We can rewrite amp2_xe by m_xenon = 1.3e5 # xenon mass def amp2_x_xenon(s,t,u,mx) -> float: \"\"\"DM-xenon scattering amplitude squared\"\"\" mV = mx/3 mt = m_xenon # xenon mass, MeV gx,eps = 1e-02,1e-06 Q = gx*eps return 2*(s**2 + u**2 + 4*t*(mt**2 + mx**2) - 2*(mt**2 + mx**2)**2)*(Q/(t - mV**2))**2 When initialize sn.BoostedDarkMatter instance, we have to specify the target mass mt too, such as casA_bdm_xenon = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_x_xenon,mt=m_xenon,is_spike=False) Now we compare the associated \\(\\sigma_{\\chi e}\\) and \\(\\sigma_{\\chi-{\\rm Xe}}\\) , # Differential DM-e cross sections mx = 1 Tx_vals = np.logspace(-5,2,100) sigxe = [casA_bdm.sigma_xe(Tx,mx) for Tx in Tx_vals] sigx_xe = [casA_bdm_xenon.sigma_xe(Tx,mx) for Tx in Tx_vals] # Plot plt.plot(Tx_vals,sigx_xe,label=r'$\\sigma_{\\chi - {\\rm Xe}}$') plt.plot(Tx_vals,sigxe,label=r'$\\sigma_{\\chi e}$') plt.xscale('log') plt.yscale('log') plt.xlabel(r'$T_\\chi$ [MeV]') plt.ylabel(r'$\\sigma$ [cm$^2$]') plt.legend() plt.show() Thus in casA_bdm_xenon , the method sigma_xe is for DM-Xenon interaction cross section. Note that the above is a very naive example and is not plausible in practice. Given when nucleus is under discussion, nucleus form factor should be introduced in amp2_x_xenon . We relegate this to the users who work in this field.","title":"Advanced Topics"},{"location":"manual/advanced/#advanced-topics","text":"We introduce some advanced usage in this document. In the following content, all equation numbers refer to BDM Physics unless specified otherwise. First, import the necessary packages: # import python packages import numpy as np import ipyparallel as ipp # import plotting package import matplotlib.pyplot as plt import matplotlib.colors as mcolors # uncomment the following two lines if you have a Hi-DPI monitor and wish to have a better figure resolution %matplotlib inline %config InlineBackend.figure_format='retina' # import snorer import snorer as sn print(f'Current version of snorer: {sn.__version__}') Current version of snorer: 2.0.0","title":"Advanced Topics"},{"location":"manual/advanced/#distribution-across-the-celestial-sphere","text":"We draw how supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) distributes across the sky. We use Cassiopeia A (Cas A) to be our SN in this example. Its \\(\\alpha\\) and \\(\\delta\\) are 23h23m24s and 58d49m00s respectively and \\(R_s\\approx 3.5\\) kpc. Hence, we obtain the off-center angle \\(\\beta\\) and its galactic coordinate by casA_beta,l_sn,b_sn = sn.equatorial_to_beta('23h23m24s','58d49m00s') print(f\"The off-center angle for Cas A approximates {casA_beta:.3f} rad.\") The off-center angle for Cas A approximates 1.950 rad. To evaluate the distribution across the sky, it is equivalent to draw \\[ \\begin{equation} \\left.\\frac{d\\Phi_\\chi}{dT_\\chi d\\Omega} = \\tau_s \\mathcal{J} j_\\chi\\right|_{t=\\frac{d}{c}+\\frac{\\ell}{v_\\chi}-t_\\nu} \\end{equation} \\] on the celestial sphere spanned by the galactic coordinate \\(\\ell\\) and \\(b\\) . The corresponding function in snorer is sn.differential_flux with 10 parameters. The first seven t , Tx , mx , theta , phi , Rs , beta are mandatory and the last three Re = 8.5 , sigxv0 = 1e-45 and is_spike = False are optional. Note that theta and phi are the zenith and azimuthal angles, cf. Fig. 1 in BDM Physics. Figure 1. Cas A and its location \\((\\ell_s,b_s)\\) on the galactic coordinate. Another point \\((\\ell_0,b_0)\\) is also labeled. Suppose Cas A locates at \\((\\ell_s,b_s)\\) on the galactic coordinate shown in Fig. 1, another point \\((\\ell_0,b_0)\\) that is distant from Cas A by \\(\\theta\\) and rotates by \\(\\varphi\\) azimuthally. We can determined them through \\[ \\begin{equation} \\theta = \\sqrt{\\ell^{\\prime 2}+b^{\\prime 2}},\\quad {\\rm and} \\quad \\varphi= \\tan^{-1}\\left(\\frac{\\ell^\\prime}{b^\\prime}\\right) \\end{equation} \\] where \\[ \\begin{equation} \\ell^\\prime = \\ell_0 - \\ell_s\\quad{\\rm and}\\quad b^\\prime = b_0-b_s. \\end{equation} \\] With \\(\\theta\\) and \\(\\varphi\\) , we further apply both to sn.differential_flux to get the differential flux. Note that we will eventually display the result using the Aitoff projection and in matplotlib such projections \\(\\ell\\in[-\\pi,\\pi)\\) , thus we define a function wrap_angle to convert \\(\\ell\\) from \\([0,2\\pi)\\) to \\([-\\pi,\\pi)\\) . The step-by-step approach is to: Construct a canvas across the entire galactic coordinate Calculate the \\((\\theta,\\varphi)\\) for every point \\((\\ell,b)\\) on the canvas Put \\((\\theta,\\varphi)\\) into sn.differential_flux and retrieve the BDM differential flux at that point def wrap_angle(l): \"\"\"Confine longitudinal in -pi and pi\"\"\" return (l + np.pi) % (2 * np.pi) - np.pi # Setup DM properties Tx,mx = 5,1 Rs = 3.5 # kpc t = 350 * sn.constant.year2Seconds # Setup canvas for galactic coordinate l and b l_vals = np.linspace(-np.pi,np.pi,800) b_vals = np.linspace(-np.pi/2,np.pi/2,400) L,B = np.meshgrid(l_vals,b_vals,indexing=\"ij\") # Evaluate dtheta and dvarphi for each grid point on the canvas L_coord = wrap_angle(L - l_sn) # adjust galactic longitude to [-pi, pi) B_coord = B - b_sn dtheta = np.sqrt(L_coord**2 + B_coord**2) dphi = np.arctan2(L_coord,B_coord)%(2 * np.pi) # using atan2 and mod 2pi to convert galactic latitude to [-pi/2, pi/2) # Canvas to store the result diffFlux = np.zeros_like(L) with np.nditer([dtheta,dphi,diffFlux],op_flags=[['readonly'],['readonly'],['writeonly']]) as it: for theta,phi,flux in it: flux[...] = sn.differential_flux(t,Tx,mx,theta,phi,Rs,casA_beta) # Plot fig = plt.figure(figsize=(12, 5)) ax = fig.add_subplot(111,projection='aitoff') norm = mcolors.SymLogNorm(linthresh=diffFlux.max()/1e2, vmin=diffFlux.max()/5e1, vmax=diffFlux.max(), base=10) mesh = ax.pcolormesh(L , B, diffFlux, cmap='inferno', norm=norm, rasterized=True) cbar = fig.colorbar(mesh, ax=ax, orientation='vertical') cbar.set_label(r\"$d\\Phi_\\chi/dtd\\Omega$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$ sr$^{-1}$]\") # axis label style ax.tick_params(axis=\"x\", colors=\"white\") ax.grid(True,linestyle='--', linewidth=0.7) # axis ticks x_ticks = np.linspace(-np.pi + np.pi/6, np.pi - np.pi/6, 11) y_ticks = np.linspace(-np.pi/2, np.pi/2, 13) ax.set_xticks(x_ticks) # set galactic longitude tick labels ax.set_xticklabels([r'\u2212150\u00b0', '\u2212120\u00b0', '\u221290\u00b0', '\u221260\u00b0', '\u221230\u00b0', '0\u00b0', '30\u00b0', '60\u00b0', '90\u00b0', '120\u00b0', '150\u00b0']) ax.set_yticks(y_ticks) # set galactic latitude tick labels ax.set_yticklabels(['\u221290\u00b0', '\u221275\u00b0', '\u221260\u00b0', '\u221245\u00b0', '\u221230\u00b0', '\u221215\u00b0', '0\u00b0', '15\u00b0', '30\u00b0', '45\u00b0', '60\u00b0', '75\u00b0', '90\u00b0']) ax.set_title(r'Cas A: $(T_\\chi,m_\\chi)=(5,1)$ MeV',y=1.1) plt.show() Note the above is a particular slice of \\(T_\\chi\\) . For practical case, one should integrate sn.differential_flux over a range of \\(T_\\chi\\) due to none of the existing detectors having infinite energy resolution.","title":"Distribution across the celestial sphere"},{"location":"manual/advanced/#user-defined-scattering-amplitude","text":"Functions sn.flux and sn.event and the core functions to construct them are all based on energy-independent cross sections \\(\\sigma_{\\chi\\nu}\\) and \\(\\sigma_{\\chi e}\\) . However, by introducing a specific particle model, cross sections are no longer energy-independent but depend on the Mandelstam variables and model parameters. Thus, sn.flux and sn.event are not applicable. To resolve this issue, we provide a class sn.BoostedDarkMatter to cope with. This class integrate all the functions to evaluate BDM flux and event and manipulating halo properties as class methods . Additionally, this class takes scattering amplitudes for \\(\\chi\\nu\\) and \\(\\chi e\\) interactions as its parameters and calculate \\(d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}\\) and \\(\\sigma_{\\chi e}\\) automatically. We illustrate this by the famous \\(L_{\\mu-\\tau}\\) model with DM component \\(\\chi\\) . The Lagrangian is \\[ \\begin{alignat}{1} \\mathcal{L}_\\chi \\supset & -\\frac{1}{4}V_{\\mu\\nu}V^{\\mu\\nu}+\\frac{\\varepsilon}{2\\cos\\theta_W}F_{\\mu\\nu}V^{\\mu\\nu}-\\frac{1}{2}m_V^2 V_\\mu V^\\mu \\nonumber \\\\ & \\quad -m_\\chi \\bar{\\chi}\\chi +g_\\chi V_\\mu \\bar{\\chi}\\gamma^\\mu \\chi \\nonumber \\\\ & \\quad +g_V V_\\mu Q_{\\alpha\\beta}\\left(\\bar{\\ell}_\\alpha\\gamma^\\mu \\ell_\\beta +\\bar{\\nu}_\\alpha \\gamma^\\mu P_L \\nu_\\beta\\right) \\end{alignat} \\] with the first line for kinetic mixing, the second line for dark sector interaction and the last for coupling between dark and lepton sector. The associated Feynman diagrams for \\(\\chi \\nu\\) and \\(\\chi e\\) scatterings are shown in Fig. 2. Figure 2. Feynman diagrams for \\(\\chi\\nu\\) (left) and \\(\\chi e\\) (right) scatterings described by \\(L_{\\mu-\\tau}\\) model. The amplitude squared \\(|\\mathcal{M}|^2\\) is given by \\[ \\begin{equation} |\\mathcal{M}|^{2} =2\\left(\\frac{\\mathcal{Q}}{t-m_{V}^{2}}\\right)^{2}[s^{2}+u^{2} +4t(m_{1}^{2}+m_{2}^{2}) -2(m_{1}^{2}+m_{2}^{2})^{2}], \\end{equation} \\] where \\(s\\) , \\(t\\) and \\(u\\) are Mandelstam variables and \\(m_1\\) and \\(m_2\\) are incoming and being scattered particles respectively. We can encode such information into python function by def amp2_xv(s,t,u,mx) -> float: \"\"\"DM-v scattering amplitude squared\"\"\" mV = mx/3 gV,gx = 1e-06,1e-02 Q = gV*gx return (s**2 + u**2 + 4*t*(mx**2) - 2*(mx**2)**2)*(Q/(t - mV**2))**2 def amp2_xe(s,t,u,mx) -> float: \"\"\"DM-e scattering amplitude squared\"\"\" mV = mx/3 me = 0.511 # MeV gx,eps = 1e-02,1e-06 Q = gx*eps return 2*(s**2 + u**2 + 4*t*(me**2 + mx**2) - 2*(me**2 + mx**2)**2)*(Q/(t - mV**2))**2 Both functions only take 4 positioning arguments with the first three are Mandelstam variables (MeV 2 ) and the last is DM mass (MeV). Other model parameters should be defined either in the function or somewhere else. They cannot be the function input(s). We again use Cas A as the example. First, build up the instance for Cas A BDM and given it is within our Milky Way, we have \\(R_g = R_e=8.5\\) kpc. casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) There are plenty of methods can be called in the instance casA_bdm . For example, we can examine the associated \\(d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}\\) and \\(\\sigma_{\\chi e}\\) : # Differential DM-v cross sections Tx,mx = 5,1 # Get maximumlly allowed psi psi_max = sn.get_psiMax(Tx,mx) psi_max -= psi_max/1000 # avoid diverge at psi_max psi_vals = np.linspace(0,psi_max,100) # differential sigma_xv dsigxv = [casA_bdm.dsigma_xv(Tx,mx,psi) for psi in psi_vals] # Plot plt.plot(psi_vals,dsigxv) plt.yscale('log') plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}$ [cm$^2$ sr$^{-1}$]') plt.show() # Differential DM-e cross sections mx = 1 Tx_vals = np.logspace(-5,2,100) # differential sigma_xv sigxe = [casA_bdm.sigma_xe(Tx,mx) for Tx in Tx_vals] # Plot plt.plot(Tx_vals,sigxe) plt.xscale('log') plt.yscale('log') plt.xlabel(r'$T_\\chi$ [MeV]') plt.ylabel(r'$\\sigma_{\\chi e}$ [cm$^2$]') plt.show() Now we are ready to evaluate the BDM flux and event. For flux, given Cas A exploded 350 years ago, it is already 350 year-old. We have to determine the vanishing time first. # Setup DM properties Tx,mx = 5,1 Rs = 3.5 # kpc tvan = sn.get_tvan(Tx,mx,Rs) print(f'Vanishing time is {tvan/sn.constant.year2Seconds:.2f} years.') Vanishing time is 557.07 years. Hence for \\((T_\\chi,m_\\chi)=(5,1)\\) MeV, \\(t_{\\rm van}=557.07\\) years. However, 350 years have passed, leaving only 207 years atmost before it ceases completely. We can use the flux method to evaluate. It takes 3 inputs: t , Tx and mx . Additional **kwargs determine the cut distances d_cut and r_cut for SN \\(\\nu\\) spectrum and halo profile, respectively, due to both are proportional \\(1/L^n\\) and diverges when \\(L\\to 0\\) . Others like nitn and neval are for vegas . Note that this method does not contain any **kwargs related to halo profile as the halo behavior is decided during the initialization of the instance. See their API pages: sn.BoostedDarkMatter and sn.params for detail. t0 = 350 * sn.constant.year2Seconds time_vals = np.linspace(t0,tvan,70) def get_casA_flux(t,Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe): \"\"\"flux\"\"\" import snorer as sn Tx,mx = 5,1 casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) return casA_bdm.flux(t,Tx,mx,neval=5000) # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_casA_flux, time_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results casA_flux = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_casA_flux: 0%| | 0/70 [00:00<?, ?tasks/s] Stopping engine(s): 1742019912 engine set stopped 1742019912: {'engines': {'0': {'exit_code': 0, 'pid': 35213, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 35214, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 35215, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 35216, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 35217, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 35201, 'identifier': 'ipcontroller-1742019911-edc4-31540'} plt.plot(time_vals/sn.constant.year2Seconds + 1675,casA_flux) plt.yscale('log') plt.ylim(3e-16,) plt.xlabel(r'Anno Domini') plt.ylabel(r'$d\\Phi_\\chi/dT_\\chi dt$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]') plt.show() To evaluate event number, rember the parameter t_range in sn.event is the integration range of time interval and starts from \\(t_0=10\\) seconds by default. But it is not the case for Cas A as 350 years has passed. We shoud begin \\(t_0=350\\) years and end with, say, 35 years after \\(t_0\\) . Hence, mx_vals = np.logspace(-6,2,35) def get_casA_event(mx,Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe): \"\"\"flux\"\"\" import snorer as sn t0 = 350 * sn.constant.year2Seconds tf = (350 + 35) * sn.constant.year2Seconds casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) try: event = casA_bdm.event(mx,t_range=[t0,tf],neval=15000) except: event = 0 return event # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_casA_event, mx_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results casA_event = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_casA_event: 0%| | 0/35 [00:00<?, ?tasks/s] engine set stopped 1742023011: {'engines': {'1': {'exit_code': 0, 'pid': 36515, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 36516, 'identifier': '2'}, '0': {'exit_code': 0, 'pid': 36514, 'identifier': '0'}, '3': {'exit_code': 0, 'pid': 36517, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 36518, 'identifier': '4'}}, 'exit_code': 0} Stopping engine(s): 1742023069 engine set stopped 1742023069: {'engines': {'0': {'exit_code': 0, 'pid': 36594, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 36595, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 36596, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 36597, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 36598, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 36580, 'identifier': 'ipcontroller-1742023068-i421-31540'} plt.scatter(mx_vals,casA_event) plt.xscale('log') plt.yscale('log') #plt.ylim(3e-16,) plt.xlabel(r'$m_\\chi$ [MeV]') plt.ylabel(r'$N_\\chi$ per electron') plt.show() Unlike sn.event which the result is normalized to per electron and \\(\\sigma_{\\chi e}=1\\) cm 2 , in this class instance, \\(\\sigma_{\\chi e}\\) is determined by user-specified \\(|\\mathcal{M}|^2\\) , thus the cross section is exact what user expects at such energy. One only needs to multiply the correct electron number \\(N_e\\) in that detector. For example, Super-K has \\(7\\times 10^{33}\\) electrons approximately, then the BDM event is \\[ N_\\chi^{\\rm SK} = N_e^{\\rm SK} \\times N_\\chi = 7\\times 10^{33} N_\\chi \\] In the above plot, one sees that no event when \\(m_\\chi\\lesssim 500\\) keV. It is because the corresponding \\(t_{\\rm van}\\) for \\(m_\\chi\\) and \\(T_\\chi\\) -integrated range are much smaller than 350 years. Thus BDM from Cas A no longer exists at the present day.","title":"User-defined scattering amplitude"},{"location":"manual/overview/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; BDM Physics \u00b6 We review all the details provided in Refs. [ 1 , 2 ]. While these papers present mathematical expressions suitable for general readers, the content in this section is tailored for programming purposes. The goal of this document is not to replace Refs. [ 1 , 2 ] but to bridge the gap between traditional journal writing and the technical details required for programming. Typos and misinformation are corrected here to ensure clarity and facilitate understanding of the subsequent Python code. General picture \u00b6 Given non-zero cross section between DM ( \\(\\chi\\) ) and neutrino ( \\(\\nu\\) ), it is expected that when SN \\(\\nu\\) could scatter with halo \\(\\chi\\) when propagating outward from the explosion site. We display the general scheme in Fig. 1 . In this figure, SN, galactic center (GC) and Earth are denoted as S, G and E respectively. Figure 1. The 3D scheme for SN\\(\\nu\\) BDM. In Fig. 1 , S, G and E are coplanar and \\(\\chi\\) is boosted at B on the SN \\(\\nu\\) shell. \\(d\\) is the distance \\(\\overline{\\mathsf{SB}}\\) , \\(\\ell\\) the distance \\(\\overline{\\mathsf{BE}}\\) , \\(R_s\\) the distance between SN and Earth and \\(R_e\\) the distance between GC and Earth. The DM number density at B is determined by \\(n_\\chi(r)\\) where \\(r\\) is the radial distance between GC and B. We adopt NFW profile [ 3 ] for \\(n_\\chi\\) , $$ \\begin{equation} n_\\chi(r)=\\frac{\\rho_s}{m_\\chi}\\frac{1}{\\frac{r}{r_s}(1+\\frac{r}{r_s})^2} \\end{equation} $$ where \\(\\rho_s=184\\) MeV cm \u22123 and \\(r_s=24.4\\) kpc. Due to its spherical symmetric nature, one does not need to know where the galactic plane lies. Unless S lies on the axis \\(\\overline{\\mathsf{GE}}\\) , BDM is not azimuthally symmetric around \\(\\varphi\\) . We refer \\(\\beta\\) as the off-center angle. It characterizes how SN deviates from GC in angular direction. It will be elaborated more in the API documents: Positioning and Coordinate Transformations . Particle kinematics \u00b6 When a \\(\\nu\\) carries energy \\(E_\\nu\\) and scatters with a static \\(\\chi\\) at B, DM will receive kinetic energy \\(T_\\chi\\) by $$ T_\\chi = \\frac{E_\\nu^2}{E_\\nu+m_\\chi/2}\\left(\\frac{1+\\cos\\theta_c}{2}\\right) $$ where \\(\\theta_c\\) is the scattering angle at center-of-mass (cm) frame (do not confuse with the \\(\\theta\\) in Fig. 1 ). Assuming \\(\\theta_c\\) uniformly distributes in \\([0,\\pi]\\) , we can relate it with lab frame scattering \\(\\psi\\) by $$ \\theta_c =2\\tan^{-1}(\\gamma \\tan\\psi) $$ where \\(\\psi\\in [0,\\pi/2]\\) and \\(\\gamma=(E_\\nu+m_\\chi)/\\sqrt{m_\\chi(2E_\\nu+m_\\chi)}\\) . Thus we have $$ \\begin{equation} \\frac{d\\sigma_{\\chi\\nu}}{d\\Omega_{\\rm lab}}=\\frac{1}{2\\pi}\\frac{d\\sigma_{\\chi\\nu}}{d\\cos\\psi}=\\sigma_0\\times g_\\chi(\\psi) \\end{equation} $$ where $$ \\begin{equation}\\label{eq:gx} g_\\chi(\\psi) = \\frac{\\gamma^2\\sec^3\\psi}{\\pi(1+\\gamma^2\\tan^2\\psi)^2} \\end{equation} $$ is the angular distribution for \\(\\chi\\nu\\) scattering cross section in lab frame. One can easily verify that Eq. \\(\\eqref{eq:gx}\\) satisfy $$ 2\\pi \\int_0^{\\pi/2} g_\\chi(\\psi) \\sin\\psi d\\psi =1 $$ and is independent of \\(\\gamma\\) . When \\(d\\) , \\(\\ell\\) and \\(R_s\\) are specified, one can determined \\(\\psi\\) by law of cosine $$ R_s^2 = d^2+\\ell^2-2d\\ell \\cos(\\pi-\\psi) $$ where $$ \\begin{equation}\\label{eq:geo_psi} \\psi =\\cos^{-1}\\left( \\frac{R_s^2-d^2-\\ell^2}{2d\\ell}\\right). \\end{equation} $$ Constraint by positive-definite \\(E_\\nu\\) \u00b6 Note that though the valid range of \\(\\psi\\) from Eq. \\(\\eqref{eq:geo_psi}\\) is in \\([0,\\pi]\\) but Eq. \\(\\eqref{eq:gx}\\) puts stronger constraint. As Eq. \\(\\eqref{eq:geo_psi}\\) is merely a geometrical relation but Eq. \\(\\eqref{eq:gx}\\) is required by the kinematics. However, \\([0,\\pi/2]\\) is simply the full range allowed by kinematics, if we examine further, we will find that the true valid range for \\(\\psi\\) is narrower. Let's consider the \\(\\chi\\nu\\) scattering in lab frame in Fig. 2 Figure 2. \\(\\chi\\nu\\) scattering in lab frame. We write down the four-momenta for each particle, \\[ \\begin{align*} p_{\\nu} & =(E_{\\nu},0,0,E_{\\nu}),\\\\ p_{\\chi} & =(m_{\\chi},0,0,0),\\\\ p_{\\nu}^{\\prime} & =(E_{\\nu}^{\\prime},x,y,z),\\\\ p_{\\chi}^{\\prime} & =(E_{\\chi},-|\\mathbf{p}_{\\chi}|\\sin\\psi,0,|\\mathbf{p}_{\\chi}|\\cos\\psi), \\end{align*} \\] where \\((x,y,z)\\) indicates their values are irrelevant. Relativistic mechanics implies that, assuming \\(m_\\nu=0\\) and the metric tensor \\(g_{\\mu\\nu}={\\rm diag}(1,-1,-1,-1)\\) , \\[ \\begin{align*} (p_\\nu-p_\\chi^\\prime)^2 &= (p_\\chi-p_\\nu^\\prime)^2, \\\\ m_\\chi^2 - 2E_\\nu (E_\\chi -|\\mathbf{p}_{\\chi}|\\cos\\psi) &= m_\\chi^2-2m_\\chi E_\\nu^\\prime. \\end{align*} \\] We can rewrite the last line by \\(E_\\chi = T_\\chi + m_\\chi\\) and \\(T_\\chi = E_\\nu - E_\\nu^\\prime\\) which results in \\[ \\begin{equation}\\label{eq:Ev} E_\\nu = \\frac{T_\\chi m_\\chi }{ |\\mathbf{p}_{\\chi}|\\cos\\psi - T_\\chi}. \\end{equation} \\] Once BDM kinetic energy \\(T_\\chi\\) and scattering angle \\(\\psi\\) at B are given, Eq. \\(\\eqref{eq:Ev}\\) specifies the required \\(E_\\nu\\) to possess such properties. Without ambiguity, \\(E_\\nu\\) is positive-definite and non-divergent, hence an even stronger constraint is put by \\[ \\begin{equation}\\label{eq:psi_max} |\\mathbf{p}_\\chi| \\cos\\psi - T_\\chi > 0 \\to\\psi < \\psi_{\\rm max}:= \\cos^{-1}\\left(\\frac{T_\\chi}{|\\mathbf{p}_{\\chi}|}\\right). \\end{equation} \\] It is also not hard to deduce that \\(|\\mathbf{p}_{\\chi}|=\\sqrt{T_\\chi ( T_\\chi+2m_\\chi )}\\) . Hence the realistic range for \\(\\psi\\) is $$ \\begin{equation} \\psi \\in [0,\\psi_{\\rm max}) \\end{equation} $$ while \\(E_\\nu\\) diverges at \\(\\psi=\\psi_{\\rm max}\\) . Moreover, we can differentiate Eq. \\(\\eqref{eq:Ev}\\) w.r.t. \\(T_\\chi\\) and obtain \\[ \\begin{equation}\\label{eq:dEv/dTx} \\frac{dE_\\nu}{dT_\\chi}=\\left(\\frac{ m_\\chi }{|\\mathbf{p}_{\\chi}|\\cos\\psi-T_\\chi }\\right)^2\\frac{T_\\chi}{|\\mathbf{p}_{\\chi}|}\\cos\\psi. \\end{equation} \\] This function will be useful later. Dark emissivity \u00b6 The key factor is determining how many \\(\\chi\\) s are boosted at B. This is generally characterized by the emissivity which has units of of cm \u22123 s \u22121 and of MeV \u22121 cm \u22123 s \u22121 in terms of energy spectrum. SN \\(\\nu\\) spectrum \u00b6 We begin by writing down the SN \\(\\nu\\) energy spectrum on the shell at \\(d\\) $$ \\begin{equation}\\label{eq:snv_spectrum} \\frac{dN_\\nu}{dE_\\nu} = \\sum_i \\frac{L_{\\nu_i}}{4\\pi d^2 \\langle E_{\\nu_i}\\rangle} f_{\\nu_i}(E_\\nu) \\end{equation} $$ where \\(L_{\\nu_i}=L_{\\rm tot}/6\\) is the luminosity for each neutrino ( \\(\\nu_{e,\\mu,\\tau}\\) and their anti-particles) and \\(f_{\\nu_i}(E_\\nu)\\) is the Fermi-Dirac distribution [ 4 ], $$ \\begin{equation} f_{\\nu_i}(E_\\nu) = \\frac{1}{F_2(\\eta_\\nu)}\\frac{1}{T_\\nu^3}\\frac{E_\\nu^2}{e^{E_\\nu/T_\\nu-\\eta_\\nu}+1} \\end{equation} $$ where $$ \\begin{equation} F_k(\\eta) = \\int_0^\\infty dx \\frac{x^k}{e^{x-\\eta}+1}. \\end{equation} $$ We list all the numerical values for the parameters mentioned above in Tab. 1 Parameters Values Parameters Values \\(\\langle E_{\\nu_e}\\rangle\\) 11 MeV \\(T_{\\nu_e}\\) 2.76 MeV \\(\\langle E_{\\bar{\\nu}_e}\\rangle\\) 16 MeV \\(T_{\\bar{\\nu}_e}\\) 4.01 MeV \\(\\langle E_{\\nu_x,\\bar{\\nu}_x}\\rangle\\) 25 MeV \\(T_{\\nu_x,\\bar{\\nu}_x}\\) 6.26 MeV \\(L_{\\rm tot}\\) \\(3\\times10^{52}\\) erg s \u22121 \\(\\eta_i\\) 3 Table 1. Numerical values for parameters. Suppose the duration of the SN explosion is around \\(\\tau_s=10\\) s, the total energy released in the form of neutrinos approximates \\(10^{53}\\) erg for individual explosion. Number density on the shell \u00b6 After converting erg to MeV, one can examine that Eq. \\(\\eqref{eq:snv_spectrum}\\) , after multiplying \\(\\tau_s\\) , has the unit MeV \u22121 cm \u22122 . Because \\(\\nu\\) travels at light speed, we can estimate the shell thickness by \\(h=c\\tau_s\\) . The SN \\(\\nu\\) shell would have a number density $$ \\begin{equation}\\label{eq:snv_nd} \\frac{dn_\\nu}{dE_\\nu} = \\frac{dN_\\nu}{dE_\\nu}\\frac{\\tau_s}{h}= \\sum_i \\frac{L_{\\nu_i}}{4\\pi d^2 \\langle E_{\\nu_i}\\rangle c} f_{\\nu_i}(E_\\nu). \\end{equation} $$ One can verify that \\(dn_\\nu/dE_\\nu\\) has MeV \u22121 cm \u22123 , which is exactly the energy spectrum of SN \\(\\nu\\) number density on the shell. By multiplying \\(E_\\nu\\) , one can eliminate MeV \u22121 and receives $$ n_\\nu =\\frac{E_\\nu}{c} \\frac{dN_\\nu}{dE_\\nu} $$ the SN \\(\\nu\\) number density. Emissivity on the shell \u00b6 To obtain emissivity \\(j_\\chi\\) at B on the SN \\(\\nu\\) shell, one simply do $$ j_\\chi := c n_\\nu n_\\chi \\frac{d\\sigma_{\\chi\\nu}}{d\\Omega_{\\rm lab}} $$ which has units of cm \u22123 s \u22121 sr \u22121 and sr \u22121 indicates per steradian. It would be more convenient to restore the energy spectrum form and translate it into \\(T_\\chi\\) expression, $$ \\begin{equation}\\label{eq:jx} j_\\chi(d,r,T_\\chi,\\psi) = cn_\\chi \\frac{dn_\\nu}{dE_\\nu} \\left(\\frac{1}{2\\pi}\\frac{d\\sigma_{\\chi\\nu}}{d\\cos\\psi}\\right)\\left(\\frac{dE_\\nu}{dT_\\chi}\\frac{v_\\chi}{c}\\right) \\end{equation} $$ where \\(dE_\\nu/dT_\\chi\\) is given in Eq. \\(\\eqref{eq:dEv/dTx}\\) . The above equation describes the BDM emissivity at any point on the shell and has a unit MeV \u22121 cm \u22123 s \u22121 sr \u22121 . SN \\(\\nu\\) BDM flux \u00b6 When the emissivity at any point is known, one can calculate the BDM flux at Earth by integrating \\(j_\\chi\\) over the ling-of-sight (l.o.s.) \\(\\ell\\) . Thus, cf. Figs. 1 and 3 , $$ \\begin{equation}\\label{eq:total_Phi} \\frac{d\\Phi_\\chi}{dT_\\chi d\\Omega}=\\int d\\ell ~ j_\\chi \\Theta(r_\\nu - d)\\Theta(d+h-r_\\nu) \\end{equation} $$ where \\(d\\Omega\\) is the field-of-view (f.o.v.) centering SN. The two \\(\\Theta\\) functions restrict \\(j_\\chi\\) is only non-zero within the shell. Without loss of generality, \\(h\\ll d\\) always holds such that $$ \\Theta(r_\\nu-d)\\Theta(d+h -r_\\nu)\\approx h \\delta(r_\\nu-d) =c\\tau_s \\delta(r_\\nu-d) $$ where \\(\\delta(x)\\) is the Dirac-delta function. Thus, Eq. \\(\\eqref{eq:total_Phi}\\) describes the total BDM flux that could be observed on the Earth. Note that \\(\\delta(r_\\nu-d)\\) actually carries [L \u22121 ] and cancels the dimension from \\(c\\tau_s\\) . This approximation remains dimensionless and is self-consistent. Figure 3. BDM production on the shell with thickness \\(h\\) at \\(d\\) distant to SN. When \\(\\ell\\) and \\(\\theta\\) are specified, \\(j_\\chi\\) is non-zero at \\(r_\\nu\\) only when \\(d\\leq r_\\nu\\leq d+h\\). From line-of-sight to time-dependency \u00b6 However, Eq. \\(\\eqref{eq:total_Phi}\\) is inadequate because it does not take DM velocity into account. Given massive DM, BDM cannot have the same velocity as SN \\(\\nu\\) . Depending on where \\(\\chi\\) is upscattered, it will arrive on Earth at different times. This results in a prolonged flux vs. time compared to the SN \\(\\nu\\) flux. BDM arrives earlier if it was upscattered closer and much later if it was upscattered farther away. To incorporate time-dependent feature, let the time of SN explosion be the time-zero. Then SN \\(\\nu\\) needs $$ t_\\nu = \\frac{R_s}{c} $$ to propagate from S to E. For BDM produced at B, it will arrive at $$ \\begin{equation}\\label{eq:tprime} t^\\prime = \\frac{d}{c} + \\frac{\\ell}{v_\\chi} \\end{equation} $$ where the first term accounts for SN \\(\\nu\\) traveling from S to B and the BDM velocity $$ v_\\chi =\\frac{\\sqrt{T_\\chi(T_\\chi+2m_\\chi )}}{T_\\chi+m_\\chi}c. $$ Applying law of cosine, we have $$ \\begin{equation}\\label{eq:d} d = \\sqrt{\\ell^2 + R_s^2 - 2\\ell R_s \\cos\\theta} \\end{equation} $$ and take total differentiation on both sides of Eq. \\(\\eqref{eq:tprime}\\) , $$ \\begin{equation}\\label{eq:dtprime} dt^\\prime =\\left( \\frac{\\ell - R_s \\cos\\theta}{c d} + \\frac{1}{v_\\chi} \\right) d\\ell := \\mathcal{J}^{-1}d\\ell. \\end{equation} $$ Note that \\(\\mathcal{J}\\) has the same dimension as velocity [L T \u22121 ]. Before recasting Eq. \\(\\eqref{eq:total_Phi}\\) into time-dependent form, we firstly manage $$ c\\tau_s \\delta(r_\\nu-d) = \\tau_s \\delta\\left(\\frac{r_\\nu}{c}- \\frac{d}{c}\\right) = \\tau_s\\delta\\left(\\frac{r_\\nu}{c}- t^\\prime +\\frac{\\ell}{v_\\chi}\\right)=\\tau_s\\delta\\left(t^\\prime - \\frac{r_\\nu}{c}-\\frac{\\ell}{v_\\chi}\\right) $$ by \\(\\delta(ax)=\\delta(x)/|a|\\) . Using thin-shell approximation, \\(h\\ll d\\) , we approximate $$ d \\leq r_\\nu \\leq d+h \\approx 1 \\leq \\frac{r_\\nu}{d} \\leq 1+\\frac{h}{d} \\to r_\\nu\\approx d. $$ The \\(\\delta\\) -function becomes $$ c\\tau_s\\delta(r_\\nu-d) \\approx \\tau_s\\delta \\left(t^\\prime - \\frac{d}{c}-\\frac{\\ell}{v_\\chi} \\right). $$ Hence we can recast Eq. \\(\\eqref{eq:total_Phi}\\) from l.o.s. integration into time integration \\[ \\frac{d\\Phi_\\chi}{dT_\\chi d\\Omega} = \\tau_s \\int dt^\\prime \\mathcal{J} j_\\chi \\delta \\left(t^\\prime - \\frac{d}{c}-\\frac{\\ell}{v_\\chi} \\right) = \\left. \\tau_s\\mathcal{J} j_\\chi \\right|_{t^\\prime = \\frac{d}{c}+\\frac{\\ell}{v_\\chi}}. \\] In the last step, the \\(\\delta\\) function restricts the integrand to be non-zero at \\(t^\\prime = d/c+\\ell/v_\\chi\\) . Finally, we integrate over the f.o.v. from the viewpoint on Earth, \\[ \\begin{equation}\\label{eq:BDM_flux} \\frac{d\\Phi_\\chi(t^\\prime)}{dT_\\chi} = \\left. \\tau_s\\int_0^{2\\pi} d\\varphi \\int_0^{\\pi/2} d\\theta~\\sin\\theta\\mathcal{J} j_\\chi (d,r,T_\\chi,\\psi) \\right|_{t^\\prime = \\frac{d}{c}+\\frac{\\ell}{v_\\chi}} \\end{equation} \\] which is the time-dependent SN \\(\\boldsymbol{\\nu}\\) BDM flux at Earth. One last thing is to check the dimension, $$ \\left[\\tau_s \\times d\\varphi d\\theta \\sin\\theta \\times \\mathcal{J} \\times j_\\chi \\right] = {\\rm s}\\cdot{\\rm sr}\\cdot\\frac{\\rm cm}{\\rm s} \\cdot \\frac{1}{\\rm MeV~cm^3~s~sr}= {\\rm MeV^{-1}~cm^{-2}~s^{-1}} $$ that shows Eq. \\(\\eqref{eq:BDM_flux}\\) has the same unit as flux per energy width. Instead of setting time-zero for \\(t^\\prime\\) as the SN explosion, for our convenience, we can shift it by \\(t_\\nu\\) , $$ \\begin{equation}\\label{eq:t} t := t^\\prime - t_\\nu = \\frac{d}{c} + \\frac{\\ell}{v_\\chi} - t_\\nu \\end{equation} $$ and this offsets the time-zero to the arrival of SN \\(\\nu\\) at Earth, \\[ \\begin{equation}\\label{eq:BDM_flux_earth} \\frac{d\\Phi_\\chi(t)}{dT_\\chi} = \\left. \\tau_s\\int_0^{2\\pi} d\\varphi \\int_0^{\\pi/2} d\\theta~\\sin\\theta\\mathcal{J} j_\\chi (d,r,T_\\chi,\\psi) \\right|_{t = \\frac{d}{c}+\\frac{\\ell}{v_\\chi}-t_\\nu}. \\end{equation} \\] Note that \\(\\tau_s\\) in front is actually redundant. Becasue we have set $$ L_{\\rm tot} = \\frac{\\mathcal{E}_{\\rm tot}}{\\tau_s} $$ where \\(\\mathcal{E}\\approx 3\\times 10^{53}\\) erg is the total energy released in the form of neutrino, see Tab. 1 . Hence \\[ \\tau_s \\times L_{\\rm tot} = \\mathcal{E}_{\\rm tot}. \\] In numerics, we can dismiss \\(\\tau_s\\) and simply replace \\(L_{\\rm tot}\\) by \\(\\mathcal{E}_{\\rm tot}\\) in Eq. \\(\\eqref{eq:snv_spectrum}\\) . Time-dependent feature \u00b6 Judging by Eq. \\(\\eqref{eq:BDM_flux_earth}\\) , it is easy to realize that the BDM flux from an individual SN is not everlasting. The last bit of signal comes from the BDM with maximum propagation time. Hence we define a vanishing time, $$ t_{\\rm van} = \\max \\left[ \\frac{d(\\theta)}{c} + \\frac{\\ell(\\theta)}{v_\\chi} - t_\\nu\\right]. $$ Using law of sine, cf. Fig. 1 , $$ \\frac{\\ell}{\\sin(\\psi-\\theta)}=\\frac{d}{\\sin\\theta}=\\frac{R_s}{\\sin\\psi} $$ then $$ \\begin{equation}\\label{eq:t_psi} t =\\frac{R_s}{c}\\frac{\\sin\\theta}{\\sin\\psi}+\\frac{R_s}{v_\\chi}\\frac{\\sin(\\psi-\\theta)} {\\sin\\psi}-t_\\nu. \\end{equation} $$ Obviously, when we fix \\(\\theta\\) in Eq. \\(\\eqref{eq:t_psi}\\) , \\(t\\) increases monotonically with \\(\\psi \\in [0,\\pi/2]\\) . Thus to find the corresponding \\(\\theta\\) that maximizes \\(t\\) globally, we restrict ourselves at \\(\\psi=\\psi_{\\rm max}\\) , cf. Eq. \\(\\eqref{eq:psi_max}\\) , which only depends on \\(T_\\chi\\) and \\(m_\\chi\\) . Hence we can do \\(dt/d\\theta=0\\) and obtain $$ \\begin{equation}\\label{eq:theta_maximum_t} \\frac{\\cos\\theta}{c}=\\frac{\\cos(\\psi_{\\rm max}-\\theta)}{v_\\chi}. \\end{equation} $$ It can be solved numerically for \\(\\theta\\) . Suppose \\(\\theta_{\\rm MAX}\\) satisfy Eq. \\(\\eqref{eq:theta_maximum_t}\\) , then we have \\[ \\begin{equation}\\label{eq:tvan} t_{\\rm van} = \\frac{d(\\theta_{\\rm MAX})}{c} + \\frac{\\ell(\\theta_{\\rm MAX})}{v_\\chi} - t_\\nu. \\end{equation} \\] We note that Eq. \\(\\eqref{eq:tvan}\\) is the exact solution for \\(t_{\\rm van}\\) and valid for both relativistic and non-relativistic cases. However, an approximation given by Eq. (13) in Ref. [ 2 ] is only suitable for relativistic case. Field-of-view across the sky \u00b6 One can understand from the last subsection that \\(\\theta_{\\rm MAX}\\) dictates the largest f.o.v. at \\(t_{\\rm van}\\) . Now we can do it the other way around that by giving a particular time \\(t^* < t_{\\rm van}\\) . The \\(\\theta^*_M\\) that satisfies Eq. \\(\\eqref{eq:t_psi}\\) , \\[ \\begin{equation} t^* = \\frac{R_s}{c}\\frac{\\sin\\theta^*_M}{\\sin\\psi_{\\rm max}} + \\frac{R_s}{v_\\chi}\\frac{\\sin(\\psi_{\\rm max}-\\theta_M^*)}{\\sin\\psi_{\\rm max}}-t_\\nu \\end{equation} \\] corresponds the maximum f.o.v. at \\(t=t^*\\) . Thus we conclude that at any specific time, the f.o.v. that contains non-zero BDM flux distributes across $$ \\begin{equation} \\theta \\in [0,\\theta^*_M). \\end{equation} $$ References \u00b6 Y.-H. Lin et al. , Phys. Rev. Lett. 130 , 111002 (2023) Y.-H. Lin et al. , Phys. Rev. D. 108 , 083013 (2023) J. F. Navarro et al. , Astrophys. J. 462 , 563 (1996) H. Duan et al. , Phys. Rev. D 74 , 105014 (2006)","title":"BDM Physics"},{"location":"manual/overview/#bdm-physics","text":"We review all the details provided in Refs. [ 1 , 2 ]. While these papers present mathematical expressions suitable for general readers, the content in this section is tailored for programming purposes. The goal of this document is not to replace Refs. [ 1 , 2 ] but to bridge the gap between traditional journal writing and the technical details required for programming. Typos and misinformation are corrected here to ensure clarity and facilitate understanding of the subsequent Python code.","title":"BDM Physics"},{"location":"manual/overview/#general-picture","text":"Given non-zero cross section between DM ( \\(\\chi\\) ) and neutrino ( \\(\\nu\\) ), it is expected that when SN \\(\\nu\\) could scatter with halo \\(\\chi\\) when propagating outward from the explosion site. We display the general scheme in Fig. 1 . In this figure, SN, galactic center (GC) and Earth are denoted as S, G and E respectively. Figure 1. The 3D scheme for SN\\(\\nu\\) BDM. In Fig. 1 , S, G and E are coplanar and \\(\\chi\\) is boosted at B on the SN \\(\\nu\\) shell. \\(d\\) is the distance \\(\\overline{\\mathsf{SB}}\\) , \\(\\ell\\) the distance \\(\\overline{\\mathsf{BE}}\\) , \\(R_s\\) the distance between SN and Earth and \\(R_e\\) the distance between GC and Earth. The DM number density at B is determined by \\(n_\\chi(r)\\) where \\(r\\) is the radial distance between GC and B. We adopt NFW profile [ 3 ] for \\(n_\\chi\\) , $$ \\begin{equation} n_\\chi(r)=\\frac{\\rho_s}{m_\\chi}\\frac{1}{\\frac{r}{r_s}(1+\\frac{r}{r_s})^2} \\end{equation} $$ where \\(\\rho_s=184\\) MeV cm \u22123 and \\(r_s=24.4\\) kpc. Due to its spherical symmetric nature, one does not need to know where the galactic plane lies. Unless S lies on the axis \\(\\overline{\\mathsf{GE}}\\) , BDM is not azimuthally symmetric around \\(\\varphi\\) . We refer \\(\\beta\\) as the off-center angle. It characterizes how SN deviates from GC in angular direction. It will be elaborated more in the API documents: Positioning and Coordinate Transformations .","title":"General picture"},{"location":"manual/overview/#dark-emissivity","text":"The key factor is determining how many \\(\\chi\\) s are boosted at B. This is generally characterized by the emissivity which has units of of cm \u22123 s \u22121 and of MeV \u22121 cm \u22123 s \u22121 in terms of energy spectrum.","title":"Dark emissivity"},{"location":"manual/overview/#snnu-bdm-flux","text":"When the emissivity at any point is known, one can calculate the BDM flux at Earth by integrating \\(j_\\chi\\) over the ling-of-sight (l.o.s.) \\(\\ell\\) . Thus, cf. Figs. 1 and 3 , $$ \\begin{equation}\\label{eq:total_Phi} \\frac{d\\Phi_\\chi}{dT_\\chi d\\Omega}=\\int d\\ell ~ j_\\chi \\Theta(r_\\nu - d)\\Theta(d+h-r_\\nu) \\end{equation} $$ where \\(d\\Omega\\) is the field-of-view (f.o.v.) centering SN. The two \\(\\Theta\\) functions restrict \\(j_\\chi\\) is only non-zero within the shell. Without loss of generality, \\(h\\ll d\\) always holds such that $$ \\Theta(r_\\nu-d)\\Theta(d+h -r_\\nu)\\approx h \\delta(r_\\nu-d) =c\\tau_s \\delta(r_\\nu-d) $$ where \\(\\delta(x)\\) is the Dirac-delta function. Thus, Eq. \\(\\eqref{eq:total_Phi}\\) describes the total BDM flux that could be observed on the Earth. Note that \\(\\delta(r_\\nu-d)\\) actually carries [L \u22121 ] and cancels the dimension from \\(c\\tau_s\\) . This approximation remains dimensionless and is self-consistent. Figure 3. BDM production on the shell with thickness \\(h\\) at \\(d\\) distant to SN. When \\(\\ell\\) and \\(\\theta\\) are specified, \\(j_\\chi\\) is non-zero at \\(r_\\nu\\) only when \\(d\\leq r_\\nu\\leq d+h\\).","title":"SN\\(\\nu\\) BDM flux"},{"location":"manual/tutorial/","text":"Tutorial \u00b6 In this tutorial, we briefly introduce the basic usage of snorer , from the basic functions related to supernova (SN) flux, and boosted dark matter (BDM) flux and event calculations, etc. This tutorial is not meant for a complete guide for all classses and functions, but a portal to utilize the most important feature for physics calculation. For how to manipulate DM halo, we refer to their API description pages: snorer.HaloSpike and snorer.nx . To have a full description of every functions, we refer the users to API document. In the following content, all equation numbers are referred to BDM Physics unless specified otherwise. We begin with importing snorer and other useful packages in this tutorial. We use ipyparallel to manifest multiprocessing feature on jupyter for Mac/Windows users. For linux users, they can simply use multiprocessing . # import python packages import numpy as np import ipyparallel as ipp # import plotting package import matplotlib.pyplot as plt import matplotlib.colors as mcolors # uncomment the following two lines if you have a Hi-DPI monitor and wish to have a better figure resolution # %matplotlib inline # %config InlineBackend.figure_format='retina' # import snorer import snorer as sn print(f'Current version of snorer: {sn.__version__}') Current version of snorer: 2.0.0 The SN \\(\\nu\\) spectrum \u00b6 The SN \\(\\nu\\) spectrum is shown in Eq. (9) and the corresponding function in snorer is sn.sn_nu_spectrum . It takes four arguments where the first two Ev and d are necessary. They indicate the SN \\(\\nu\\) energy, in MeV, and the flux at distance \\(d\\) to the SN explosion site. The last two d_trunct and is_density are optional. When \\(d\\to 0\\) , Eq. (9) diverges, one has to set a truncation point. The default is \\(3.24\\times 10^{-15}\\) kpc which roughly corresponds to 100 km and is the size of neutrino sphere. is_density is to change the output to density unit, see Eq. (12). # Neutrino energy Ev_vals = np.logspace(-3,2,100) # Distance to the explosion site d_vals = np.logspace(-16,2,200) # Setup meshgrid for (Ev,d) plane Ev,D = np.meshgrid(Ev_vals,d_vals,indexing='ij') # Evaluate SNv flux DNvDEv = sn.sn_nu_spectrum(Ev,D) # Plot fig, ax = plt.subplots() # log-scaler color norm = mcolors.LogNorm(vmin=DNvDEv.min()+1, vmax=DNvDEv.max()) # Contour plot contour = ax.contourf(Ev, D, DNvDEv, levels=20, cmap=\"viridis\", norm=norm) ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel(r'$E_\\nu$ [MeV]') ax.set_ylabel(r'$d$ [kpc]') # Color bar cbar = fig.colorbar(contour, ax=ax) cbar.set_label(r\"$dN_\\nu/dE_\\nu$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]\") plt.show() The differential DM- \\(\\nu\\) cross section \u00b6 How DM distributes in lab-frame angular direction after boosted by \\(\\nu\\) is desecribed by Eq. (2). Given its energy indpendency, we assume the total cross section, after integrating over solid angle, is \\(\\sigma_0\\) . The differential case is just \\(\\sigma_0 \\times g_\\chi\\) . The corresponding function is sn.dsigma_xv and it takes four parameters. The first three are Ev , mx and psi , the incoming neutrino energy (MeV), DM mass (MeV) and lab frame scattering angle (rad). The last one sigxv0 is \\(\\sigma_0\\) and by default is 10 \u221245 cm 2 . # Neutrino energy, mx values and psi range Ev = 10 mx_vals = np.logspace(-3,0,4) sigma0 = 1e-35 psi_vals = np.linspace(0,np.pi/2,500) for mx in mx_vals: # differential cross section diff_sigma0 = sn.dsigma_xv(Ev,mx,psi_vals,sigxv0 = sigma0) # make plot plt.plot(psi_vals,diff_sigma0,label=fr'$m_\\chi={1000*mx:.0f}$ keV') plt.yscale('log') plt.legend() plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}$ [cm$^2$ sr$^{-1}$]') plt.show() One can also compare with sn.get_gx because sn.dsigma_xv = sigxv0 * sn.get_gx . Note that the plot in sn.get_gx page, we have weighted the result by \\(d\\Omega=2\\pi \\sin\\psi\\) . It explains the numerics is 0 at \\(\\psi=0\\) . Evaluating SN \\(\\nu\\) BDM \u00b6 Flux at Earth \u00b6 The SN \\(\\nu\\) BDM flux at Earth is given by Eq. (18), which has been integrated over the sky that contains non-zero BDM. The corresponding function is sn.flux and takes 8 parameters and **kwargs . The first 5 are t , Tx , mx , Rs and beta that indicate the time of arrival at Earth, relative to SN \\(\\nu\\) 's arrival at Earth, the BDM kinetic energy (MeV), the BDM mass (MeV), the distance to SN (kpc) and the off-center angle (rad). The rest 3 optional are Re = 8.5 , sigxv0 = 1e-45 and is_density = False . Re is the distance to galactic center and is_density determines whether the halo spike should be included. For additional keyword arguments, see pages for sn.flux and sn.params . Additionally, BDM flux only lasts unitil \\(t=t_{\\rm van}\\) , see Eq. (23). To evaluate the time-dependent flux, \\(t>t_{\\rm van}\\) is meaningless as the flux is 0. We can obtain the maximum time to be calculated at first by sn.get_tvan . It takes three inputs Tx , mx and Rs . For example, let's assume there is a SN at \\((R_s,\\beta)=(9.9\\,{\\rm kpc},0.33\\,{\\rm rad})\\) and BDM has \\((T_\\chi,m_\\chi)=(10,0.1)\\) MeV: # SN location Rs, beta = 9.9, 0.33 # kpc, rad # BDM properties Tx, mx = 10, 0.1 # MeV # Get vanishing time tvan = sn.get_tvan(Tx,mx,Rs) print(f'Vanishing time is {tvan/sn.constant.year2Seconds:.2f} years.') # convert from seconds to years Vanishing time is 80.61 years. For a particular time, say \\(t=23\\) years, one can set t = 23 * sn.constant.year2Seconds bdmflux = sn.flux(t,Tx,mx,Rs,beta) print(f'BDM flux at {t/sn.constant.year2Seconds:.2f} is {bdmflux:.4e} /MeV/cm^2/s.') BDM flux at 23.00 is 5.5491e-18 /MeV/cm^2/s. Now we can construct the time-dependent BDM flux, say from \\(t=0\\) to \\(t=80.61\\) years. In sn.flux we use vegas to perform the multidimension integral Eq. (18). Hence we use ipyparallel to utilize the multiprocessing computing on Mac/Windows jupyter notebook. # Define a function for multiprocessing flux evaluation by ipyparallel def get_flux(t): from snorer import flux Rs, beta = 9.9, 0.33 # kpc, rad Tx, mx = 10, 0.1 # MeV return flux(t,Tx,mx,Rs,beta) # Time steps time_vals = np.logspace(1,np.log10(tvan),50) # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_flux, time_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results bdmflux_time = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_flux: 0%| | 0/50 [00:00<?, ?tasks/s] Stopping engine(s): 1741921266 engine set stopped 1741921266: {'engines': {'0': {'exit_code': 0, 'pid': 5889, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 5890, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 5891, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 5892, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 5893, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 5876, 'identifier': 'ipcontroller-1741921265-4v3e-2996'} # Plot plt.plot(time_vals/sn.constant.year2Seconds,bdmflux_time) plt.xscale('log') plt.yscale('log') plt.ylim(5e-19,2e-17) plt.xlabel(r'$t$ [years]') plt.ylabel(r'$d\\Phi_\\chi/dT_\\chi dt$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]') plt.show() Event at Earth \u00b6 We call function sn.event to evaluate the BDM event \\(N_\\chi\\) at Earth. It's simply \\[ N_\\chi =N_e \\sigma_{\\chi e} \\int_{t_{\\rm min}}^{t_{\\rm max}} dt\\int_{T_{\\chi,{\\rm min}}}^{T_{\\chi,{\\rm max}}}dT_\\chi \\frac{d\\Phi_\\chi}{dT_\\chi dt} \\] It takes 8 inputs and **kwargs . The first three mx , Rs and beta are necessary. The last five Re , Tx_range , t_range , sigxv0 and is_spike are optional. By default Tx_range = [5,30] is the \\(T_\\chi\\) -integration range (MeV) and t_range = [10,1.1045e+09] is the time-integration range (seconds). The default \\(t_{\\rm max}\\) approximates 35 years. Note that the function will automatically truncate \\(t_{\\rm max}\\) at \\(t_{\\rm van}\\) if the user-input \\(t_{\\rm max}\\) is greater than \\(t_{\\rm van}\\) . Note that sn.event is normalized to \\(N_e = 1\\) , the electron number, and \\(\\sigma_{\\chi e}=1\\) cm 2 , the DM-electron cross section. One can easily scale the result to a detector with arbitrary number of \\(N_e\\) and \\(\\sigma_{\\chi e}=1\\) . # Define a function for multiprocessing event evaluation by ipyparallel def get_event(mx): from snorer import event Rs, beta = 8.5, 0.0 # kpc, rad return event(mx,Rs,beta,r_cut=1e-5,neval=30000) # increasing the evaluation number in each MCMC chain in vegas # DM mass to be evaluated mx_vals = np.logspace(-6,2,35) # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_event, mx_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results bdmevent_mx = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_event: 0%| | 0/35 [00:00<?, ?tasks/s] engine set stopped 1741928354: {'engines': {'0': {'exit_code': 0, 'pid': 9398, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 9399, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 9400, 'identifier': '2'}, '4': {'exit_code': 0, 'pid': 9402, 'identifier': '4'}, '3': {'exit_code': 0, 'pid': 9401, 'identifier': '3'}}, 'exit_code': 0} Stopping engine(s): 1741928391 engine set stopped 1741928391: {'engines': {'0': {'exit_code': 0, 'pid': 9444, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 9445, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 9446, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 9447, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 9448, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 9432, 'identifier': 'ipcontroller-1741928390-sv9q-2996'} Assume \\(N_e=3\\times 10^{33}\\) and \\(\\sigma_{\\chi e}=10^{-35}\\) cm 2 : Ne = 1e33 sigxe = 1e-35 bdmevent_mx = np.array(bdmevent_mx) * Ne * sigxe # Plot plt.scatter(mx_vals,bdmevent_mx) plt.xscale('log') plt.yscale('log') #plt.ylim(5e-19,2e-17) plt.xlabel(r'$m_\\chi$ [MeV]') plt.ylabel(r'$N_\\chi$') plt.show() More about **kwargs in sn.flux and sn.event \u00b6 We elaborate the optional parameters contained in **kwargs for both sn.flux and sn.event . Practically, they determine the DM halo shape ( sn.params.halo and sn.params.spike ) and control vegas algortihm ( sn.params.vegas ). See its API page for detail. For halo related **kwargs , if sets is_spike = False , then only three are avalaible: rhos : Characteristic denisty, MeV cm -3 . rs : Characteristic length, kpc. n : Halo profile slope. If is_spike = True , then there are five additional **kwargs will be activated: mBH : Supermassive black hole (SMBH) mass, \\(M_\\odot\\) . tBH : SMBH age, years. rh : SMBH influence radius, kpc. alpha : Spike slope, string type, only two options: '3/2' and '7/3' . sigv : DM annihilation cross section in the unit of 10 -26 cm 3 s -1 . For example, if we wish to have \\(\\langle \\sigma v\\rangle = 3\\times 10^{-26}\\) cm 3 s -1 , we simply set sigv = 3 . If one sets is_spike = False and typing any of the above **kwargs for spiky halo, ValueError will appear. Now if we want to evaluate a galaxy similar to our Milky Way but \\(\\rho_s=100\\) and \\(n=3.3\\) . Also we wish to have spike feature, such as SMBH mass is \\(10^7~M_\\odot\\) and strong annihilation such that \\(\\langle \\sigma v\\rangle = 13\\times 10^{-26}\\) . We can then set # Halo setup rhos, n = 100, 3.3 mBH, sigv = 1e7, 13 # SN location Rs, beta = 9.9, 0.33 # kpc, rad # BDM properties Tx, mx = 10, 0.1 # MeV # Flux t = 15*sn.constant.year2Seconds bdmflux_customized = sn.flux(t,Tx,mx,Rs,beta,is_spike=True,mBH=mBH,sigv=sigv,neval=15000) print(bdmflux_customized) 6.6134929121434916e-18 Coordinate transform and SN in arbitrary distant galaxy \u00b6 snorer also provides functions for converting galactic and equatorial coordinates into off-center angle \\(\\beta\\) , see Coordinate Transoformation for discussion. This aids us to compute those SNe documented in SRcat . For example, the Crab Neubla has \\((\\alpha,\\delta)= (05{\\rm h}34{\\rm m}31{\\rm s}, 22{\\rm d}01{\\rm m}00{\\rm s})\\) in equatorial coordinate based on ICRS J2000.0 frame. We can obtain \\(\\beta\\) by sn.equatorial_to_beta . This function takes three inputs and the first two are ra and dec in string type which correspond to \\(\\alpha\\) and \\(\\delta\\) of the SN to be investigated. The third one GC_coord is optional. Default None will automatically refer to Milky Way center. If you have your own prefer galaxy to be studied, please specifiy as GC = [gc_ra,gc_dec] where gc_ra and gc_dec are the equatorial coordinate of the galactic center. Additionally, sn.equatorial_to_beta will output a tuple contains three values \\((\\beta,\\ell,b)\\) where the last two indicate the galactic coordinate \\(\\ell\\) and \\(b\\) of SN. # Coordinate crab_ra, crab_dec = '05h34m31s', '22d01m00s' crab_beta,_,_ = sn.equatorial_to_beta(crab_ra,crab_dec) print(f'Off-center angle of Crab Neubla is {crab_beta:.3e} rad.') Off-center angle of Crab Neubla is 3.013e+00 rad. Now we show a case where SN is not in the Milky Way, the SN1987a, which located in Large Magellanic Cloud. There locations are given in # Print LMC coordinate: ra,dec,dist print(sn.constant.LMC_coord) # Print SN1987a coordinate: ra,dec,dist print(sn.constant.SN1987a_coord) ['05h23m34.5264s', '-69d45m22.053s', 49.97] ['05h35m27.8733s', '-69d16m10.478s', 51.4] Hence to get \\(\\beta\\) , we do SN1987a_ra,SN1987a_dec,Rs = sn.constant.SN1987a_coord LMC_ra,LMC_dec,Rg = sn.constant.LMC_coord sn1987a_beta,_,_ = sn.equatorial_to_beta(SN1987a_ra,SN1987a_dec,GC_coord=[LMC_ra,LMC_dec]) To evaluate event, we still use sn.event but have to specify Re by Rg because the default Re = 8.5 implies the distance between Earth and Milky Way center. mx = 0.5 beta = 0.0 # kpc, rad SN1987a_event = sn.event(mx,Rs,beta,Re=Rg,r_cut=1e-5,neval=30000) SN1987a_event *= (Ne * sigxe) # Assuming Ne and sigma_xe follow previously print(f'BDM event from SN1987a in LMC is {SN1987a_event:.3e}.') BDM event from SN1987a in LMC is 8.512e-13.","title":"Tutorial"},{"location":"manual/tutorial/#tutorial","text":"In this tutorial, we briefly introduce the basic usage of snorer , from the basic functions related to supernova (SN) flux, and boosted dark matter (BDM) flux and event calculations, etc. This tutorial is not meant for a complete guide for all classses and functions, but a portal to utilize the most important feature for physics calculation. For how to manipulate DM halo, we refer to their API description pages: snorer.HaloSpike and snorer.nx . To have a full description of every functions, we refer the users to API document. In the following content, all equation numbers are referred to BDM Physics unless specified otherwise. We begin with importing snorer and other useful packages in this tutorial. We use ipyparallel to manifest multiprocessing feature on jupyter for Mac/Windows users. For linux users, they can simply use multiprocessing . # import python packages import numpy as np import ipyparallel as ipp # import plotting package import matplotlib.pyplot as plt import matplotlib.colors as mcolors # uncomment the following two lines if you have a Hi-DPI monitor and wish to have a better figure resolution # %matplotlib inline # %config InlineBackend.figure_format='retina' # import snorer import snorer as sn print(f'Current version of snorer: {sn.__version__}') Current version of snorer: 2.0.0","title":"Tutorial"},{"location":"manual/tutorial/#the-snnu-spectrum","text":"The SN \\(\\nu\\) spectrum is shown in Eq. (9) and the corresponding function in snorer is sn.sn_nu_spectrum . It takes four arguments where the first two Ev and d are necessary. They indicate the SN \\(\\nu\\) energy, in MeV, and the flux at distance \\(d\\) to the SN explosion site. The last two d_trunct and is_density are optional. When \\(d\\to 0\\) , Eq. (9) diverges, one has to set a truncation point. The default is \\(3.24\\times 10^{-15}\\) kpc which roughly corresponds to 100 km and is the size of neutrino sphere. is_density is to change the output to density unit, see Eq. (12). # Neutrino energy Ev_vals = np.logspace(-3,2,100) # Distance to the explosion site d_vals = np.logspace(-16,2,200) # Setup meshgrid for (Ev,d) plane Ev,D = np.meshgrid(Ev_vals,d_vals,indexing='ij') # Evaluate SNv flux DNvDEv = sn.sn_nu_spectrum(Ev,D) # Plot fig, ax = plt.subplots() # log-scaler color norm = mcolors.LogNorm(vmin=DNvDEv.min()+1, vmax=DNvDEv.max()) # Contour plot contour = ax.contourf(Ev, D, DNvDEv, levels=20, cmap=\"viridis\", norm=norm) ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel(r'$E_\\nu$ [MeV]') ax.set_ylabel(r'$d$ [kpc]') # Color bar cbar = fig.colorbar(contour, ax=ax) cbar.set_label(r\"$dN_\\nu/dE_\\nu$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]\") plt.show()","title":"The SN\\(\\nu\\) spectrum"},{"location":"manual/tutorial/#the-differential-dm-nu-cross-section","text":"How DM distributes in lab-frame angular direction after boosted by \\(\\nu\\) is desecribed by Eq. (2). Given its energy indpendency, we assume the total cross section, after integrating over solid angle, is \\(\\sigma_0\\) . The differential case is just \\(\\sigma_0 \\times g_\\chi\\) . The corresponding function is sn.dsigma_xv and it takes four parameters. The first three are Ev , mx and psi , the incoming neutrino energy (MeV), DM mass (MeV) and lab frame scattering angle (rad). The last one sigxv0 is \\(\\sigma_0\\) and by default is 10 \u221245 cm 2 . # Neutrino energy, mx values and psi range Ev = 10 mx_vals = np.logspace(-3,0,4) sigma0 = 1e-35 psi_vals = np.linspace(0,np.pi/2,500) for mx in mx_vals: # differential cross section diff_sigma0 = sn.dsigma_xv(Ev,mx,psi_vals,sigxv0 = sigma0) # make plot plt.plot(psi_vals,diff_sigma0,label=fr'$m_\\chi={1000*mx:.0f}$ keV') plt.yscale('log') plt.legend() plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}$ [cm$^2$ sr$^{-1}$]') plt.show() One can also compare with sn.get_gx because sn.dsigma_xv = sigxv0 * sn.get_gx . Note that the plot in sn.get_gx page, we have weighted the result by \\(d\\Omega=2\\pi \\sin\\psi\\) . It explains the numerics is 0 at \\(\\psi=0\\) .","title":"The differential DM-\\(\\nu\\) cross section"},{"location":"manual/tutorial/#evaluating-snnu-bdm","text":"","title":"Evaluating SN\\(\\nu\\) BDM"},{"location":"manual/tutorial/#coordinate-transform-and-sn-in-arbitrary-distant-galaxy","text":"snorer also provides functions for converting galactic and equatorial coordinates into off-center angle \\(\\beta\\) , see Coordinate Transoformation for discussion. This aids us to compute those SNe documented in SRcat . For example, the Crab Neubla has \\((\\alpha,\\delta)= (05{\\rm h}34{\\rm m}31{\\rm s}, 22{\\rm d}01{\\rm m}00{\\rm s})\\) in equatorial coordinate based on ICRS J2000.0 frame. We can obtain \\(\\beta\\) by sn.equatorial_to_beta . This function takes three inputs and the first two are ra and dec in string type which correspond to \\(\\alpha\\) and \\(\\delta\\) of the SN to be investigated. The third one GC_coord is optional. Default None will automatically refer to Milky Way center. If you have your own prefer galaxy to be studied, please specifiy as GC = [gc_ra,gc_dec] where gc_ra and gc_dec are the equatorial coordinate of the galactic center. Additionally, sn.equatorial_to_beta will output a tuple contains three values \\((\\beta,\\ell,b)\\) where the last two indicate the galactic coordinate \\(\\ell\\) and \\(b\\) of SN. # Coordinate crab_ra, crab_dec = '05h34m31s', '22d01m00s' crab_beta,_,_ = sn.equatorial_to_beta(crab_ra,crab_dec) print(f'Off-center angle of Crab Neubla is {crab_beta:.3e} rad.') Off-center angle of Crab Neubla is 3.013e+00 rad. Now we show a case where SN is not in the Milky Way, the SN1987a, which located in Large Magellanic Cloud. There locations are given in # Print LMC coordinate: ra,dec,dist print(sn.constant.LMC_coord) # Print SN1987a coordinate: ra,dec,dist print(sn.constant.SN1987a_coord) ['05h23m34.5264s', '-69d45m22.053s', 49.97] ['05h35m27.8733s', '-69d16m10.478s', 51.4] Hence to get \\(\\beta\\) , we do SN1987a_ra,SN1987a_dec,Rs = sn.constant.SN1987a_coord LMC_ra,LMC_dec,Rg = sn.constant.LMC_coord sn1987a_beta,_,_ = sn.equatorial_to_beta(SN1987a_ra,SN1987a_dec,GC_coord=[LMC_ra,LMC_dec]) To evaluate event, we still use sn.event but have to specify Re by Rg because the default Re = 8.5 implies the distance between Earth and Milky Way center. mx = 0.5 beta = 0.0 # kpc, rad SN1987a_event = sn.event(mx,Rs,beta,Re=Rg,r_cut=1e-5,neval=30000) SN1987a_event *= (Ne * sigxe) # Assuming Ne and sigma_xe follow previously print(f'BDM event from SN1987a in LMC is {SN1987a_event:.3e}.') BDM event from SN1987a in LMC is 8.512e-13.","title":"Coordinate transform and SN in arbitrary distant galaxy"}]}