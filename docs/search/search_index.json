{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".mono { font-family: monospace; } .mono { font-family: monospace; } What is snorer about? \u00b6 snorer , short for S upernova- N eutrino-b O osted da R k matt ER , is a package for evaluating time-of-flight signatures of supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) from the Milky Way, SN1987a in the Large Magellanic Cloud, and SN in arbitrary distant galaxies. Citation \u00b6 If you use this package or part of the code in your research, please cite the followings: Y.-H. Lin et al. , Phys. Rev. Lett. 130 , 111002 (2023) [arXiv:2206.06864] Y.-H. Lin et al. , Phys. Rev. D 108 , 083013 (2023) [arXiv:2307.03522] snorer : https://github.com/yenhsunlin/snorer Installation \u00b6 To install, excute the following command on the prompt: $ pip install snorer and everything should be processed on-the-fly. Prerequisites \u00b6 snorer requires Python >= 3.8 and the following dependencies: numpy >= 1.20 scipy >= 1.10 vegas >= 6.0 astropy >= 6.0 Here, vegas serves as the backend engine for evaluating multidimensional integrals using the vegas algorithm . See the linked repository for more details. Other dependencies may be required by these packages and will be installed automatically. Document structure \u00b6 There are two main parts in this document: User Manual and API References . The User Manual contains four sections. The first section provides an overview of the entire BDM physics, including comprehensive and self-consistent derivations of all relevant equations. This is followed by two tutorial-style instructions for using snorer , covering topics from basic to advanced usage, and concluding with one demonstration page. In the API References , we list all docstrings and usage examples for every function and class in snorer , organized by functionality. Each section begins with any supplementary documents that may be needed beyond what is covered in the User Manual . Then it is divided into two categories: Classes and Functions , which explain the usage and behavior of all classes and functions in that section. Getting started \u00b6 Following is a simple taste of snorer . To import, do import snorer as sn # Import snorer functions Assuming the following locations: Distance between Earth and galactic center: \\(R_e=8.5\\) kpc Distance between Earth and SN: \\(R_s=8.5\\) kpc The angle \\(\\beta=0\\) and DM properties: Mass \\(m_\\chi=0.001\\) MeV Kinetic energy \\(T_\\chi=15\\) MeV Evaluating flux \u00b6 Suppose we want to evaluate the BDM flux at \\(t=100\\) seconds after the observation of SN \\(\\nu\\) , then >>> t,Tx,mx,Rstar,beta = 100,15,1e-2,8.5,0 # Collecting parameters >>> flux = sn.flux(t,Tx,mx,Rstar,beta,is_spike=True,neval=15000) # Evaluating flux, 1/MeV/cm^2/s >>> print(flux) 4.572295175982701e-16 The parameter is_spike determines whether a DM spike in the central region of the halo is included, and neval specifies how many samples will be generated by vegas in each integration chain. The default value for the DM- \\(\\nu\\) cross section is \\(\\sigma_{\\chi\\nu} = 10^{-45}\\) \u202fcm 2 . See also snorer.flux . Evaluating event \u00b6 Assuming the main target that scatters with BDM in the detector is the electron , the following function evaluates the event rate per second per electron . The default value for the DM\u2013 \\(\\nu\\) cross section is \\(\\sigma_{\\chi\\nu} = 10^{-45}\\) \u202fcm 2 , while the DM\u2013 e cross section \\(\\sigma_{\\chi e}\\) is normalized to 1\u202fcm 2 . >>> mx,Rstar,beta = 1e-2,8.5,0.3 # Collecting parameters >>> event = sn.event(mx,Rstar,beta,is_spike=True,neval=30000) # Evaluating BDM event per electron with sigma_xe = 1 cm^2 >>> print(event) 1.4350397711858462e-06 Given the previous setup, event is the event rate per electron assuming \\(\\sigma_{\\chi e} = 1\\) cm 2 . Suppose the detector contains \\(N_e\\) electrons, and the true cross sections are \\(\\sigma_{\\chi\\nu}^{\\rm true}\\) and \\(\\sigma_{\\chi e}^{\\rm true}\\) , then the total event number in this detector is $$ N_\\chi^{\\rm tot} = \\texttt{event} \\times \\frac{N_e}{1}\\times \\frac{\\sigma_{\\chi e}^{\\rm true}}{1 \\,{\\rm cm^2}} \\times \\frac{\\sigma_{\\chi\\nu}^{\\rm true}}{10^{-45}\\,{\\rm cm^2}}. $$ See also snorer.event . Reporting bug(s) \u00b6 Please report to Yen-Hsun Lin via yenhsun@phys.ncku.edu.tw","title":"Introduction"},{"location":"#what-is-snorer-about","text":"snorer , short for S upernova- N eutrino-b O osted da R k matt ER , is a package for evaluating time-of-flight signatures of supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) from the Milky Way, SN1987a in the Large Magellanic Cloud, and SN in arbitrary distant galaxies.","title":"What is snorer about?"},{"location":"#citation","text":"If you use this package or part of the code in your research, please cite the followings: Y.-H. Lin et al. , Phys. Rev. Lett. 130 , 111002 (2023) [arXiv:2206.06864] Y.-H. Lin et al. , Phys. Rev. D 108 , 083013 (2023) [arXiv:2307.03522] snorer : https://github.com/yenhsunlin/snorer","title":"Citation"},{"location":"#installation","text":"To install, excute the following command on the prompt: $ pip install snorer and everything should be processed on-the-fly.","title":"Installation"},{"location":"#document-structure","text":"There are two main parts in this document: User Manual and API References . The User Manual contains four sections. The first section provides an overview of the entire BDM physics, including comprehensive and self-consistent derivations of all relevant equations. This is followed by two tutorial-style instructions for using snorer , covering topics from basic to advanced usage, and concluding with one demonstration page. In the API References , we list all docstrings and usage examples for every function and class in snorer , organized by functionality. Each section begins with any supplementary documents that may be needed beyond what is covered in the User Manual . Then it is divided into two categories: Classes and Functions , which explain the usage and behavior of all classes and functions in that section.","title":"Document structure"},{"location":"#getting-started","text":"Following is a simple taste of snorer . To import, do import snorer as sn # Import snorer functions Assuming the following locations: Distance between Earth and galactic center: \\(R_e=8.5\\) kpc Distance between Earth and SN: \\(R_s=8.5\\) kpc The angle \\(\\beta=0\\) and DM properties: Mass \\(m_\\chi=0.001\\) MeV Kinetic energy \\(T_\\chi=15\\) MeV","title":"Getting started"},{"location":"#reporting-bugs","text":"Please report to Yen-Hsun Lin via yenhsun@phys.ncku.edu.tw","title":"Reporting bug(s)"},{"location":"api/constants/Constants/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Constants \u00b6 class snorer.Constants() \u00b6 A data class stores many physical constants and coversion factors for convenient use. Attributes: perMeV2cm : float Convert MeV to MeV \u22121 to cm md2MeVperCubicCM : float Convert \\(M_\\odot\\) kpc \u22123 to MeV cm \u22123 year2Seconds : int Convert one year to seconds erg2MeV : int Convert erg to MeV kpc2cm : float Convert kiloparsec to cm me : float Electron mass, MeV mn : float Neutron mass, MeV mp : float Proton mass, MeV Msun : float Solar mass, MeV Msun_kg : float Solar mass, kg Mmw : float Stellar mass in Milky Way, Msun (halo not included) Mhalo : float Dark matter halo mass in Milky Way, Msun Rhalo : float Halo radius, kpc sigma0 : float Constant cross section, cm 2 c : int Speed of light, cm s \u22121 sigma0 : float Constant cross section, cm 2 H0 : float Hubble constant, km Mpc \u22121 s \u22121 rho_c : float Critical densityt \\(\\rho_c\\) in cosmology, \\(M_\\odot\\) pc \u22123 Lv : float Neutrino luminosity, divided by 10 seconds, for single species, total six (3 \\(\\nu\\) and 3 \\(\\bar{\\nu}\\) ), erg s \u22121 Omega_0m : float Cosmological matter fraction Omega_0L : float Cosmological dark energy fraction Omega_0r : float Cosmological radiation fraction Omega_0 : float Cosmological total energy, 1 D_H0 : float Cosmological distance, Mpc G : float Gravitational constant, pc \\(M_\\odot^{-1}\\) kms 2 s \u22121 SgrA_coord : list Sagittarius A* coordinate and distance, [ str , str , float ] = [RAC,DEC,kpc] LMC_coord : list Coordinate for Large Magellanic Cloud center and distance, [ str , str , float ] = [RAC,DEC,kpc] SN1987a_coord : list SN1987a coordinate and distance, [ str , str , float ] = [RAC,DEC,kpc] Examples Import snorer and do >>> import snorer as sn >>> sn.Constants().perMeV2cm # Convert 1/MeV to cm 1.973e-11 >>> sn.Constants().SgrA_coord # Sgr A J2000 coordinate and its distance in kpc ['17h45m40.0383s', '-29d00m28.069s', 8.13] For simplicity, one can also call the constants and conversion factors by >>> sn.constant.perMeV2cm 1.973e-11 Both Constants and constant are equivalent and is related by constant = Constants() .","title":"Constants"},{"location":"api/constants/Constants/#snorerconstants","text":"","title":"snorer.Constants"},{"location":"api/geometry/Geometry/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Geometry \u00b6 class snorer.Geometry( l , theta , phi , Rs , Re , beta ) \u00b6 The class constructs the static geomatrical relations for \\(d\\) , \\(r^\\prime\\) and \\(\\cos\\psi\\) when \\((l,\\theta,\\phi)\\) and \\((R_s,R_e,\\beta)\\) are specified. See Positioning for more detail. Parameters: l : array_like The line-of-sight distance, kpc theta : array_like The zenith angle \\(\\theta\\) at Earth, centers SN, rad phi : array_like Azimuthal angle \\(\\varphi\\) at Earth, centers SN, rad Rs : array_like Distance from Earth to SN, kpc Re : array_like Distance from Earth to GC, kpc beta : array_like Off-center angle \\(\\beta\\) , rad Attributes: d : scalar/ndarray Distance from SN to boost point \\(d\\) , kpc rprime : scalar/ndarray Distance from GC to boost point \\(r^\\prime\\) , kpc cos_psi : scalar/ndarray \\(\\cos\\psi\\) at boost point where \\(\\psi\\) is the direction for BDM at B pointing Earth Examples Import snorer and do >>> l,theta,phi,Rs,Re,beta = 5.160e-9,1e-4,0,11.6,8.5,0.71 # specify quantities >>> bdmGeo = Geometry(l,theta,phi,Rs,Re,beta) >>> print(bdmGeo.d) # SN to boost point 11.59999999483988 >>> print(bdmGeo.rprime) # GC to boost point 8.49999999608676 >>> print(bdmGeo.cos_psi) # cos(psi) 0.9999999721078604","title":"Geometry"},{"location":"api/geometry/Geometry/#snorergeometry","text":"","title":"snorer.Geometry"},{"location":"api/geometry/Positioning/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; Positioning \u00b6 To position the BDM signals, cf. Fig. 1 in BDM Physics , we need to analyze the geometry of propagation in order to determine how large the emissivity is at point B. Once the geometrical relations are properly understood, we can proceed to construct a class that solves this problem on-the-fly. See also Ref. [ 1 ], and note that we slightly modify the notations in this document for improved clarity. Geometry \u00b6 The geometry for BDM propagation is depicted in Fig. 1 . The three coplanar points S, G, and E remain the same as before. Repeated quantities retain their original definitions, while we also introduce additional auxiliary terms whose purposes will become clear shortly. Figure 1. The geometry of BDM propagation. By examining the blue and green triangles, we have \\[ \\begin{align} h &= \\ell \\sin\\theta \\\\ b &= \\ell \\cos\\theta. \\end{align} \\] Moreover, the blue and brown triangles are identical, with the brown one being a rotation of the blue triangle around the axis \\(\\overline{\\mathsf{SE}}\\) by angle \\(\\varphi\\) . See Fig. 2 . Figure 2. Blue and brown triangles are identical. Suppose point B is at a distance \\(r\\) from G, then its rotated counterpart B\u2032 is at distance \\(r^\\prime\\) . Clearly, \\(r\\) is a special case of \\(r^\\prime\\) when \\(\\varphi = 0\\) . This is crucial because when the SN is not located at the GC, the DM number density \\(n_\\chi\\) is no longer spherically symmetric with respect to the SN. To correctly evaluate \\(j_\\chi\\) at the boost point B, one must use the DM density evaluated at the rotated distance: \\(n_\\chi(r^\\prime(\\varphi))\\) . Figure 3. Another set of auxiliary triangles. We draw another set of auxiliary triangles in Fig. 3 , also cf. Fig. 1 , and immediately observe that, in the left figure, \\[\\begin{equation}\\label{eq:rprime} r^{\\prime 2} = a^2 + h^2 \\cos^2\\varphi, \\end{equation}\\] while \\[\\begin{equation} a^2 = (\\rho \\sin\\delta - h \\sin\\varphi)^2 + \\rho^2 \\cos^2\\delta, \\end{equation}\\] and from the law of cosines, the right figure gives \\[\\begin{equation} \\rho = \\sqrt{b^2 + R_e^2 - 2b R_e \\cos\\beta}. \\end{equation}\\] To determine \\(\\delta\\) , we again apply the law of cosines (since we need to know whether \\(\\delta > \\pi/2\\) ): \\[ R_e^2 = \\rho^2 + b^2 - 2\\rho b \\cos(\\pi - \\delta), \\] which yields \\[\\begin{equation} \\cos\\delta = \\frac{R_e^2 - \\rho^2 - b^2}{2\\rho b}. \\end{equation}\\] One can check that we have already determined \\(r^\\prime\\) (Eq. \\eqref{eq:rprime}) in terms of known quantities \\((d, \\ell, \\theta, \\varphi)\\) and \\((R_s, R_e, \\beta)\\) . The first set is specified during the evaluation of BDM signatures, and the second set defines the SN location. The last quantity to compute is the scattering angle \\(\\psi\\) , which can be obtained via the law of cosines: \\[ R_s^2 = d^2 + \\ell^2 - 2d \\ell \\cos(\\pi - \\psi), \\] so that \\[\\begin{equation} \\cos\\psi = \\frac{R_s^2 - d^2 - \\ell^2}{2d\\ell}, \\end{equation}\\] where \\[\\begin{equation}\\label{eq:d} d = \\sqrt{\\ell^2 + R_s^2 - 2\\ell R_s \\cos\\theta}. \\end{equation}\\] This indicates that \\(d\\) is not an independent quantity, but is instead determined by \\(\\ell\\) and \\(\\theta\\) . Static to time-dependent \u00b6 From Eq. (15) in BDM Physics and offsetting by \\(t_\\nu = R_s / c\\) , we have \\[ t = \\frac{d}{c} + \\frac{\\ell}{v_\\chi} - t_\\nu, \\] which leads to \\begin{equation}\\label{eq:t_dependent} d + \\frac{\\ell}{\\beta_\\chi} = R_s + ct, \\end{equation} where \\(\\beta_\\chi = v_\\chi / c\\) . For convenience, we define \\begin{equation} \\zeta(t) = R_s + ct, \\end{equation} and plug Eq. \\eqref{eq:d} into Eq. \\eqref{eq:t_dependent}, then solve for \\(\\ell\\) \\begin{equation}\\label{eq:ell_t} \\ell(t) = -\\frac{\\beta_\\chi}{1 - \\beta_\\chi^2} \\left( \\alpha + \\gamma - \\zeta \\right), \\end{equation} where \\[\\begin{align*} \\alpha &= \\sqrt{(R_s^2 - \\zeta^2)(1 - \\beta_\\chi^2) + (R_s \\beta_\\chi \\cos\\theta - \\zeta)^2}, \\\\ \\gamma &= R_s \\beta_\\chi \\cos\\theta. \\end{align*}\\] We can now determine \\(\\ell\\) at any time \\(t\\) using Eq. \\eqref{eq:ell_t}, and since \\(d\\) depends on \\(\\ell\\) when \\(\\theta\\) is specified (via Eq. \\eqref{eq:d}), the geometry of BDM propagation becomes time-dependent , transitioning from a static configuration. References \u00b6 Y.-H. Lin et al. , Phys. Rev. D. 108 , 083013 (2023)","title":"Positioning"},{"location":"api/geometry/Positioning/#positioning","text":"To position the BDM signals, cf. Fig. 1 in BDM Physics , we need to analyze the geometry of propagation in order to determine how large the emissivity is at point B. Once the geometrical relations are properly understood, we can proceed to construct a class that solves this problem on-the-fly. See also Ref. [ 1 ], and note that we slightly modify the notations in this document for improved clarity.","title":"Positioning"},{"location":"api/geometry/Positioning/#geometry","text":"The geometry for BDM propagation is depicted in Fig. 1 . The three coplanar points S, G, and E remain the same as before. Repeated quantities retain their original definitions, while we also introduce additional auxiliary terms whose purposes will become clear shortly. Figure 1. The geometry of BDM propagation. By examining the blue and green triangles, we have \\[ \\begin{align} h &= \\ell \\sin\\theta \\\\ b &= \\ell \\cos\\theta. \\end{align} \\] Moreover, the blue and brown triangles are identical, with the brown one being a rotation of the blue triangle around the axis \\(\\overline{\\mathsf{SE}}\\) by angle \\(\\varphi\\) . See Fig. 2 . Figure 2. Blue and brown triangles are identical. Suppose point B is at a distance \\(r\\) from G, then its rotated counterpart B\u2032 is at distance \\(r^\\prime\\) . Clearly, \\(r\\) is a special case of \\(r^\\prime\\) when \\(\\varphi = 0\\) . This is crucial because when the SN is not located at the GC, the DM number density \\(n_\\chi\\) is no longer spherically symmetric with respect to the SN. To correctly evaluate \\(j_\\chi\\) at the boost point B, one must use the DM density evaluated at the rotated distance: \\(n_\\chi(r^\\prime(\\varphi))\\) . Figure 3. Another set of auxiliary triangles. We draw another set of auxiliary triangles in Fig. 3 , also cf. Fig. 1 , and immediately observe that, in the left figure, \\[\\begin{equation}\\label{eq:rprime} r^{\\prime 2} = a^2 + h^2 \\cos^2\\varphi, \\end{equation}\\] while \\[\\begin{equation} a^2 = (\\rho \\sin\\delta - h \\sin\\varphi)^2 + \\rho^2 \\cos^2\\delta, \\end{equation}\\] and from the law of cosines, the right figure gives \\[\\begin{equation} \\rho = \\sqrt{b^2 + R_e^2 - 2b R_e \\cos\\beta}. \\end{equation}\\] To determine \\(\\delta\\) , we again apply the law of cosines (since we need to know whether \\(\\delta > \\pi/2\\) ): \\[ R_e^2 = \\rho^2 + b^2 - 2\\rho b \\cos(\\pi - \\delta), \\] which yields \\[\\begin{equation} \\cos\\delta = \\frac{R_e^2 - \\rho^2 - b^2}{2\\rho b}. \\end{equation}\\] One can check that we have already determined \\(r^\\prime\\) (Eq. \\eqref{eq:rprime}) in terms of known quantities \\((d, \\ell, \\theta, \\varphi)\\) and \\((R_s, R_e, \\beta)\\) . The first set is specified during the evaluation of BDM signatures, and the second set defines the SN location. The last quantity to compute is the scattering angle \\(\\psi\\) , which can be obtained via the law of cosines: \\[ R_s^2 = d^2 + \\ell^2 - 2d \\ell \\cos(\\pi - \\psi), \\] so that \\[\\begin{equation} \\cos\\psi = \\frac{R_s^2 - d^2 - \\ell^2}{2d\\ell}, \\end{equation}\\] where \\[\\begin{equation}\\label{eq:d} d = \\sqrt{\\ell^2 + R_s^2 - 2\\ell R_s \\cos\\theta}. \\end{equation}\\] This indicates that \\(d\\) is not an independent quantity, but is instead determined by \\(\\ell\\) and \\(\\theta\\) .","title":"Geometry"},{"location":"api/geometry/Positioning/#static-to-time-dependent","text":"From Eq. (15) in BDM Physics and offsetting by \\(t_\\nu = R_s / c\\) , we have \\[ t = \\frac{d}{c} + \\frac{\\ell}{v_\\chi} - t_\\nu, \\] which leads to \\begin{equation}\\label{eq:t_dependent} d + \\frac{\\ell}{\\beta_\\chi} = R_s + ct, \\end{equation} where \\(\\beta_\\chi = v_\\chi / c\\) . For convenience, we define \\begin{equation} \\zeta(t) = R_s + ct, \\end{equation} and plug Eq. \\eqref{eq:d} into Eq. \\eqref{eq:t_dependent}, then solve for \\(\\ell\\) \\begin{equation}\\label{eq:ell_t} \\ell(t) = -\\frac{\\beta_\\chi}{1 - \\beta_\\chi^2} \\left( \\alpha + \\gamma - \\zeta \\right), \\end{equation} where \\[\\begin{align*} \\alpha &= \\sqrt{(R_s^2 - \\zeta^2)(1 - \\beta_\\chi^2) + (R_s \\beta_\\chi \\cos\\theta - \\zeta)^2}, \\\\ \\gamma &= R_s \\beta_\\chi \\cos\\theta. \\end{align*}\\] We can now determine \\(\\ell\\) at any time \\(t\\) using Eq. \\eqref{eq:ell_t}, and since \\(d\\) depends on \\(\\ell\\) when \\(\\theta\\) is specified (via Eq. \\eqref{eq:d}), the geometry of BDM propagation becomes time-dependent , transitioning from a static configuration.","title":"Static to time-dependent"},{"location":"api/geometry/Propagation/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Propagation \u00b6 class snorer.Propagation( t , vx , theta , phi , Rs , Re , beta ) \u00b6 Superclass: snorer.Geometry The class constructs the dynamical geomatrical relations for \\(d\\) , \\(r^\\prime\\) and \\(\\cos\\psi\\) when \\((l,\\theta,\\phi)\\) and \\((R_s,R_e,\\beta)\\) are specified. Unlike its superclass Geometry, the class parameter l is now replaced by a specific time t and dimensionless BDM velocity vx . This allows it to incorporate time-dependent feature when evaluating the geometrical quantities during propagation. This class is also not exclusively for SN in MW or LMC, it can be generalized to SN in arbitrary distant galaxy as long as the aforementioned inputs are determined. The BDM emissivity along the line-of-sight then can be determined when calculate the BDM flux and event at Earth associated to that particular SN. See Positioning for more detail. Parameters: t : array_like The BDM at specific time \\(t\\) , seconds. Time-zero is set to be the arrival of SN \\(\\nu\\) at Earth vx : array_like BDM dimesionless velocity \\(v_\\chi/c\\) theta : array_like The zenith angle \\(\\theta\\) at Earth, centers SN, rad phi : array_like Azimuthal angle \\(\\varphi\\) at Earth, centers SN, rad Rs : array_like Distance from Earth to SN, kpc Re : array_like Distance from Earth to GC, kpc beta : array_like Off-center angle \\(\\beta\\) , rad Attributes: l : scalar/ndarray The line-of-sight distance \\(\\ell\\) , kpc d : scalar/ndarray Distance from SN to boost point \\(d\\) , kpc rprime : scalar/ndarray Distance from GC to boost point \\(r^\\prime\\) , kpc cos_psi : scalar/ndarray \\(\\cos\\psi\\) at boost point where \\(\\psi\\) is the direction for BDM at B pointing Earth Examples Import snorer and do >>> bdmProp = Propagation(t=59,vx=0.9,theta=1e-4,phi=0,Rs=11.6,Re=8.5,beta=0.71) >>> print(bdmProp.l) # The corresponding l.o.s. distance 5.160120751743069e-09 >>> print(bdmProp.d) # The distace from SN to boost point 11.59999999483988 >>> print(bdmProp.rprime) # The distance from GC to boost point 8.49999999608676 >>> print(bdmProp.cos_psi) # Scattering angle that points Earth at B 1.0","title":"Propagation"},{"location":"api/geometry/Propagation/#snorerpropagation","text":"","title":"snorer.Propagation"},{"location":"api/halo/HaloSpike/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.HaloSpike \u00b6 class snorer.HaloSpike( mBH , tBH , alpha ) \u00b6 Superclass: snorer.Constants Class for constructing dark matter halo with spike due to supermassive black hole (SMBH) in the galactic center. Parameters: mBH : float SMBH mass, \\(M_\\odot\\) tBH : float SMBH age, years alpha : str Slope of the spike profile, only '3/2' or '7/3' is acceptable Attributes: mBH : float SMBH mass, user's input tBH : float SMBH age, user's input alpha : obj Slope of the spike profile, user's input and is a Fraction object rh : float SMBH influence radius \\(r_h\\) , kpc Rsp : float Spike radius \\(R_{\\rm sp}\\) , kpc __call__ ( r , mx , sigv , rhos , rs , n ) \u00b6 After initializing snorer.HaloSpike instance, it is callable like normal function with the following required inputs. Parameters: r : float Distance to GC, kpc mx : float DM mass, MeV sigv : float DM annihilation cross section \\(\\langle\\sigma v\\rangle\\) in the unit of cm 3 s \u22121 . None means no annihilation rhos : float Charasteristic density \\(\\rho_s\\) , MeV s \u22123 rs : float Characteristic radius \\(r_s\\) , kpc n : float Slope of the DM profile outside \\(R_{\\rm sp}\\) Returns: out : scalar DM number density at \\(r\\) , cm \u22123 Examples Initializing instance and check its attributes. >>> import snorer as sn >>> nx = sn.HaloSpike(mBH=1e7,tBH=1e10,alpha='3/2') # initializing instance >>> nx # print instance information SMBH mass: 1.000e+07 M_sun Spike slope: 3/2 Initial slope: 1.000e+00 Spike radius: 9.504e-10 kpc Influence radius: 3.412e-03 kpc >>> nx.alpha # check alpha Fraction(3,2) The influence radius \\(r_h\\) is auto generated but can be replaced by user defined number. It can be reset to the default value by giving None . >>> nx.rh # default value of rh 0.003411783398329804 >>> nx.rh = 2.54e-3 # replace rh with user-defined value >>> nx.rh 2.54e-03 >>> nx.rh = None # reset it to the default value >>> nx.rh 0.003411783398329804 Make it a callable function that can calculate DM number density at different \\(r\\) . import numpy as np import matplotlib.pyplot as plt import snorer as sn # Get MW rhos, rs, n, mBH and rh rhos,rs,n,mBH,rh = constant.MW_profile.values() # Assuming BH age is 1 Gyr tBH = 1e10 # DM mass, MeV mx = 0.1 # Annihilation cross section sigv_list = [3,0.03,None] sigv_label = ['3','0.03','0'] # Initializing instances with two different alphas nx = HaloSpike(mBH=mBH,tBH=tBH,alpha='3/2') # alpha = 3/2 # radius, kpc r_vals = np.logspace(-5,2,100) for i in range(3): sigv = sigv_list[i] nx_vals = [nx(r,mx,sigv,rhos,rs,n) for r in r_vals] plt.plot(r_vals,nx_vals,label=sigv_label[i] + r'$\\times10^{-26}\\,{\\rm cm^3~s^{-1}}$') plt.xscale('log') plt.yscale('log') plt.xlabel(r'$r$ [kpc]') plt.ylabel(r'$n_\\chi(r)$ [cm$^{-3}$]') plt.title(fr'$m_\\chi = {mx:.1f}$ MeV') plt.legend() plt.show() Notes This class is based on the Supplementary Material of Ref. [ 1 ]. References \u00b6 Y.-H. Lin and M.-R. Wu, Phys. Rev. Lett. 133 , 111004 (2024) P. Gondolo and J. Silk, Phys. Rev. Lett. 83 , 1719 (1999) J. Cline and M. Puel, JCAP 06 , 004 (2023)","title":"HaloSpike"},{"location":"api/halo/HaloSpike/#snorerhalospike","text":"","title":"snorer.HaloSpike"},{"location":"api/halo/M_sigma/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.M_sigma \u00b6 snorer.M_sigma( mBH ) \u00b6 Stellar dispersion relation under the influence of black hole. Also known as \\(M-\\sigma\\) relation. Parameters: mBH : array_like Supermassive black hole mass, \\(M_\\odot\\) Returns: out : scalar/ndarray Stellar velocity dispersion, km s \u22121 . Out is scalar if the input is scalar too. Notes This function evaluates the stellar dispersion \\(\\sigma_s\\) near supermassive black hole $$ \\log_{10}\\left(\\frac{M_{\\rm BH}}{M_\\odot}\\right) = 8.29 + 5.12\\log_{10}\\left(\\frac{\\sigma_s}{200\\,{\\rm km\\,s^{-1}}}\\right). $$ References \u00b6 N. McConnell et al. , Nature 480 , 215 (2011)","title":"M_sigma"},{"location":"api/halo/M_sigma/#snorerm_sigma","text":"","title":"snorer.M_sigma"},{"location":"api/halo/nx/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.nx \u00b6 snorer.nx( r , mx , is_spike=False , **kwargs *) \u00b6 Dark matter number density of Milky Way of Large Magellanic Cloud at distance \\(r\\) to the galactic center. Spike feature is not included. Parameters: r : array_like Distance to galactic center \\(r\\) , kpc mx : array_like Dark matter mass, MeV is_spike : bool Is halo spike included? Default is False . **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.halo and snorer.params.spike . Returns: out : scalar/ndarray Dark matter number density at \\(r\\) , cm \u22123 Examples Let's plot \\(n_\\chi(r)\\) for different profiles. import numpy as np import matplotlib.pyplot as plt import snorer as sn mx = 0.01 # radius, kpc r_vals = np.logspace(-3,2,100) # profiles profiles = [sn.constant.MW_profile,sn.constant.LMC_profile] labels = ['MW','LMC'] # Make plot for i in range(2): rhos,rs,n,_,_ = profiles[i].values() nx_vals = sn.nx(r_vals,mx,rhos=rhos,rs=rs,n=n) plt.plot(r_vals,nx_vals,label=labels[i]) plt.xscale('log') plt.yscale('log') plt.xlabel(r'$r$ [kpc]') plt.ylabel(r'$n_\\chi(r)$ [cm$^{-3}$]') plt.title(fr'$m_\\chi = {mx:.2f}$ MeV') plt.legend() plt.show() Notes Number density is just density divided by mass, $$ n_\\chi(r)=\\frac{\\rho_\\chi(r)}{m_\\chi}. $$ See also snorer.rhox .","title":"nx"},{"location":"api/halo/nx/#snorernx","text":"","title":"snorer.nx"},{"location":"api/halo/nxSpike/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.nxSpike \u00b6 snorer.nxSpike( r , mx , profile='MW' , sigv=None , tBH=1e+10 , alpha='3/2' ) \u00b6 Dark matter number density of Milky Way of Large Magellanic Cloud at distance \\(r\\) to the galactic center. Spike feature is included. Parameters: r : array_like Distance to galactic center, kpc mx : array_like Dark matter mass, MeV profile : str 'MW' or 'LMC' , stands for MW halo or LMC halo sigv : scalar DM annihilation cross section, in the unit of \\(10^{-26}\\) cm 3 s \u22121 . None indicates no annihilation tBH : float Supermassive black hole age, years alpha : str Slope of the spike, '3/2' or '7/3' Returns: out : scalar/ndarray Dark matter number density at r with spike in the center, cm \u22123 Examples Let's plot \\(n_\\chi\\) for different \\(\\langle \\sigma v\\rangle\\) . import numpy as np import matplotlib.pyplot as plt import snorer as sn # DM mass, keV mx = 0.01 # radius, kpc r_vals = np.logspace(-5,2,100) # profiles sigv_vals = [None,0.01,0.1,3] for sigv in sigv_vals: # calculate nx nx_vals = nxSpike(r_vals,mx,sigv=sigv,profile='LMC') if sigv is None: sigv = 0 # legend label plt.plot(r_vals,nx_vals,label=r'$\\langle\\sigma v\\rangle=$' + str(sigv)) plt.xscale('log') plt.yscale('log') plt.xlabel(r'$r$ [kpc]') plt.ylabel(r'$n_\\chi(r)$ [cm$^{-3}$]') plt.title(fr'LMC with spike and $m_\\chi = {mx:.2f}$ MeV') plt.legend() plt.show() Notes To realize \\(n_\\chi\\) with spike feature we initialized a snorer.HaloSpike instance inside the function snorer.nxSpike and utilize the callable feature. However, such callable function does not support vectorization. To mimic vectorized inputs/outputs, we employ numpy.nditer . It could become clumsy if the points to be calculated are massive.","title":"nxSpike"},{"location":"api/halo/nxSpike/#snorernxspike","text":"","title":"snorer.nxSpike"},{"location":"api/halo/radiusInfluence/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.radiusInfluence \u00b6 snorer.radiusInfluence( mBH ) \u00b6 Influence radius of a supermassive black hole Parameters: mBH : array_like Supermassive black hole mass, \\(M_\\odot\\) Returns: out : scalar/ndarray Influence radisu, kpc. Out is scalar if the input is scalar. Notes This function evaluates the influence radius of a supermassive black hole $$ r_h = \\frac{GM_{\\rm BH}}{\\sigma_s^2} $$ where sigma_s is the stellar dispersion near SMBH. See also snorer.M_sigma .","title":"radiusInfluence"},{"location":"api/halo/radiusInfluence/#snorerradiusinfluence","text":"","title":"snorer.radiusInfluence"},{"location":"api/halo/radiusSchwarzschild/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.radiusSchwarzschild \u00b6 snorer.radiusSchwarzschild( mBH ) \u00b6 Schawarzschild radius of a supermassive black hole. Parameters: mBH : array_like Supermassive black hole mass, \\(M_\\odot\\) Returns: out : scalar/ndarray Schwarzschild radius, kpc. Out is scalar if the input is scalar.","title":"radiusSchwarzschild"},{"location":"api/halo/radiusSchwarzschild/#snorerradiusschwarzschild","text":"","title":"snorer.radiusSchwarzschild"},{"location":"api/halo/rhox/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.rhox \u00b6 snorer.rhox( r , rhos , rs , n ) \u00b6 Dark matter density at \\(r\\) . Parameters: r : array_like Distance to GC, kpc rhos : array_like Characteristic density \\(\\rho_s\\) , MeV cm \u22123 rs : array_like Characteristic radius \\(r_s\\) , kpc n : array_like Slope of the DM profile Returns: out : scalar/ndarray DM density at \\(r\\) , MeV cm \u22123 . Out is scalar if all inputs are scalars Notes This function evaluates the DM density profile $$ \\rho_\\chi(r)=\\frac{\\rho_s}{\\frac{r}{r_s}(1+\\frac{r}{r_s})^n} $$ where rhos and rs are characteristic density and radius respectively. When \\((\\rho_s,r_s,n) =\\) (184 MeV cm \u22123 , 24.42 kpc, 2), it is the famous NFW profile. If divided by \\(m_\\chi\\) , it becomes DM number density. References \u00b6 G. Bertone et al. , Phys. Rept. 405 , 279 (2005)","title":"rhox"},{"location":"api/halo/rhox/#snorerrhox","text":"","title":"snorer.rhox"},{"location":"api/kinematics/22scat/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; 2-2 elastic scattering \u00b6 We have reviewed the 2-2 elastic scattering with one massless neutrino in BDM Physics . To accommodate a more general case, we relax the massless assumption and do not identify the incoming or outgoing particles as any specific species. This allows us to build a general-purpose class suitable for arbitrary 2-2 scattering processes involving non-zero masses. General expressions \u00b6 The scheme for the scattering of two particles, labeled 1 and 2, is shown in Fig. 1 . Each particle carries non-zero mass \\(m_1\\) and \\(m_2\\) , respectively. The four-momenta of all particles are indicated in the diagram. The scattering angle quantifies the deflection relative to the incoming direction of particle 1. After the scattering event, particles 1 and 2 are deflected by angles \\(\\vartheta\\) and \\(\\psi\\) , respectively. Figure 1. The 2-2 particle scattering in lab frame. We can write down the 4-momenta in lab frame, \\[ \\begin{align*} p_1 = (E_1,\\mathbf{p}_1),&\\quad p_2 = (m_2,\\mathbf{0}),\\\\ p_1^{\\prime} = (E_1^\\prime,\\mathbf{p}_1^\\prime),&\\quad p_2^{\\prime} = (E_2^\\prime,\\mathbf{p}_2^\\prime), \\end{align*} \\] and the corresponding \\(u\\) -channel \\[ \\begin{gather*} (p_1-p_2^\\prime)^2 = m_1^2+m_2^2-2E_1E_2^\\prime +2 |\\mathbf{p}_1| |\\mathbf{p}_2^\\prime| \\cos\\psi,\\\\ (p_2-p_1^\\prime)^2 = m_1^2+m_2^2 - 2 E_1^\\prime m_2. \\end{gather*} \\] The two identities are equivalent due to the Lorentz-invariant nature of the process. Similar to the BDM case, suppose we know \\(E_2^\\prime\\) and its kinetic energy, such that $$ T_2 = E^\\prime_2 - m_2 = E_1 - E_1^\\prime. $$ We thus have $$ \\begin{equation} E_1 (T_2+m_2) -|\\mathbf{p}_1||\\mathbf{p}_2^\\prime| x = (E_1-T_2)m_2, \\end{equation} $$ where \\(x= \\cos\\psi\\) . By letting \\(|\\mathbf{p}_1|=\\sqrt{E_1^2-m_1^2}\\) and \\(|\\mathbf{p}_2^\\prime| =\\sqrt{T_2(T_2+2m_2)}\\) , the only unknown in the above equation is \\(E_1\\) , which can be solved analytically, \\[ \\begin{equation}\\label{eq:E1} E_1=\\frac{T_2^2 m_2 + |\\mathbf{p}_2^\\prime|x\\sqrt{m_1^2 |\\mathbf{p}_2^\\prime|^2 x^2 + T_2^2 (m_2^2-m_1^2)}}{|\\mathbf{p}_2^\\prime|^2 x^2 - T_2^2}. \\end{equation} \\] Note that \\(E_1\\) gives the total energy of particle 1, thus \\(T_1 = E_1 - m_1\\) . It is true that \\(E_1 = T_1\\) only in the special case where \\(m_1 = 0\\) . Moreover, one can differentiate \\(E_1\\) with respect to \\(T_2\\) , which yields $$ \\begin{equation}\\label{eq:dE1/dT2} \\frac{dE_1}{dT_2}=m_2x^2\\times \\frac{\\alpha +\\beta + \\gamma}{\\eta} \\end{equation} $$ where \\[ \\begin{align*} \\alpha &= m_1^2 \\delta, \\\\ \\beta & = m_2^2 (2T_2+\\delta),\\\\ \\gamma &= 2m_2 x \\kappa,\\\\ \\eta &= \\delta^2 x \\kappa, \\end{align*} \\] with \\(\\delta=-T_2 + (T_2 + 2m_2)x^2\\) and \\(\\kappa=\\sqrt{(T_2+2m_2)(\\alpha+ T_2 m_2^2 )}\\) . In most cases, elastic scattering does not change the mass of the particles, thus \\[\\begin{equation} \\frac{dE_1}{dT_2} = \\frac{d}{dT_2}(T_1 + m_1) = \\frac{dT_1}{dT_2} \\end{equation}\\] and this allows all relevant quantities to be expressed in terms of the kinetic energies \\(T_i\\) . When constructing the corresponding class , the namespace will consistently refer to \\(T_i\\) instead of \\(E_i\\) . Although the angle \\(\\vartheta\\) for particle 1 is irrelevant to our study, it can still be determined via 3-momentum conservation \\begin{equation} \\sin\\vartheta = \\frac{|\\mathbf{p}_2^\\prime|}{|\\mathbf{p}_1^\\prime|} \\sin\\psi \\end{equation} where \\(|\\mathbf{p}_1^\\prime| = \\sqrt{E_1^{\\prime 2} - m_1^2}\\) and \\(E_1^\\prime = E_1 - T_2\\) . Validation \u00b6 Now recall the \\(\\nu\\chi\\) scattering with \\(E_1 = E_\\nu\\) , \\(T_2 = T_\\chi\\) , \\(m_1 = m_\\nu = 0\\) , and \\(m_2 = m_\\chi\\) . With \\(|\\mathbf{p}_2^\\prime| = |\\mathbf{p}_\\chi| = \\sqrt{T_\\chi (T_\\chi + m_\\chi)}\\) , Eq. \\eqref{eq:E1} becomes \\[\\begin{equation}\\label{eq:Ev} E_\\nu = T_\\chi m_\\chi \\frac{T_\\chi + |\\mathbf{p}_\\chi| x}{(|\\mathbf{p}_\\chi| x - T_\\chi)(|\\mathbf{p}_\\chi| x + T_\\chi)} = \\frac{T_\\chi m_\\chi}{|\\mathbf{p}_\\chi| x - T_\\chi}. \\end{equation}\\] Additionally, \\[\\begin{align*} \\alpha &= 0, \\\\ \\beta &= m_\\chi^2 \\left(T_\\chi + (T_\\chi + 2m_\\chi)x^2\\right), \\\\ \\gamma &= 2m_\\chi^2 |\\mathbf{p}_\\chi| x, \\\\ \\eta &= \\delta^2 m_\\chi |\\mathbf{p}_\\chi| x, \\end{align*}\\] and after some tedious algebra, we obtain \\[\\begin{align*} m_\\chi x^2 \\frac{\\alpha + \\beta + \\gamma}{\\eta} &= \\frac{x}{\\delta^2} \\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|} \\left(T_\\chi + (T_\\chi + 2m_\\chi)x^2 + 2|\\mathbf{p}_\\chi| x \\right) \\\\ &= \\frac{x}{\\delta^2} \\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|} \\left( T_\\chi + \\frac{|\\mathbf{p}_\\chi|^2}{T_\\chi} x^2 + 2|\\mathbf{p}_\\chi| x \\right) \\\\ &= \\frac{x}{\\delta^2} \\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|} \\frac{(T_\\chi + |\\mathbf{p}_\\chi| x)^2}{T_\\chi}. \\end{align*}\\] We also use \\[\\begin{align*} \\delta^2 &= \\left(-T_\\chi + \\frac{|\\mathbf{p}_\\chi|^2}{T_\\chi} x^2 \\right)^2 = \\frac{(|\\mathbf{p}_\\chi|^2 x^2 - T_\\chi^2)^2}{T_\\chi^2} \\\\ &= \\frac{(|\\mathbf{p}_\\chi| x - T_\\chi)^2 (|\\mathbf{p}_\\chi| x + T_\\chi)^2}{T_\\chi^2}, \\end{align*}\\] which leads to the final result \\[\\begin{equation}\\label{eq:dEv/dTx} m_\\chi x^2 \\frac{\\alpha + \\beta + \\gamma}{\\eta} = \\left( \\frac{m_\\chi}{|\\mathbf{p}_\\chi| x - T_\\chi} \\right)^2 \\frac{T_\\chi}{|\\mathbf{p}_\\chi|} x = \\frac{dE_\\nu}{dT_\\chi}. \\end{equation}\\] We observe that Eqs. \\eqref{eq:Ev} and \\eqref{eq:dEv/dTx} are exactly Eqs. (5) and (8) in BDM Physics , respectively. We therefore conclude that Eqs. \\eqref{eq:E1} and \\eqref{eq:dE1/dT2} are the general expressions for 2-2 elastic scattering involving non-zero masses.","title":"2-2 elastic scattering"},{"location":"api/kinematics/22scat/#2-2-elastic-scattering","text":"We have reviewed the 2-2 elastic scattering with one massless neutrino in BDM Physics . To accommodate a more general case, we relax the massless assumption and do not identify the incoming or outgoing particles as any specific species. This allows us to build a general-purpose class suitable for arbitrary 2-2 scattering processes involving non-zero masses.","title":"2-2 elastic scattering"},{"location":"api/kinematics/22scat/#general-expressions","text":"The scheme for the scattering of two particles, labeled 1 and 2, is shown in Fig. 1 . Each particle carries non-zero mass \\(m_1\\) and \\(m_2\\) , respectively. The four-momenta of all particles are indicated in the diagram. The scattering angle quantifies the deflection relative to the incoming direction of particle 1. After the scattering event, particles 1 and 2 are deflected by angles \\(\\vartheta\\) and \\(\\psi\\) , respectively. Figure 1. The 2-2 particle scattering in lab frame. We can write down the 4-momenta in lab frame, \\[ \\begin{align*} p_1 = (E_1,\\mathbf{p}_1),&\\quad p_2 = (m_2,\\mathbf{0}),\\\\ p_1^{\\prime} = (E_1^\\prime,\\mathbf{p}_1^\\prime),&\\quad p_2^{\\prime} = (E_2^\\prime,\\mathbf{p}_2^\\prime), \\end{align*} \\] and the corresponding \\(u\\) -channel \\[ \\begin{gather*} (p_1-p_2^\\prime)^2 = m_1^2+m_2^2-2E_1E_2^\\prime +2 |\\mathbf{p}_1| |\\mathbf{p}_2^\\prime| \\cos\\psi,\\\\ (p_2-p_1^\\prime)^2 = m_1^2+m_2^2 - 2 E_1^\\prime m_2. \\end{gather*} \\] The two identities are equivalent due to the Lorentz-invariant nature of the process. Similar to the BDM case, suppose we know \\(E_2^\\prime\\) and its kinetic energy, such that $$ T_2 = E^\\prime_2 - m_2 = E_1 - E_1^\\prime. $$ We thus have $$ \\begin{equation} E_1 (T_2+m_2) -|\\mathbf{p}_1||\\mathbf{p}_2^\\prime| x = (E_1-T_2)m_2, \\end{equation} $$ where \\(x= \\cos\\psi\\) . By letting \\(|\\mathbf{p}_1|=\\sqrt{E_1^2-m_1^2}\\) and \\(|\\mathbf{p}_2^\\prime| =\\sqrt{T_2(T_2+2m_2)}\\) , the only unknown in the above equation is \\(E_1\\) , which can be solved analytically, \\[ \\begin{equation}\\label{eq:E1} E_1=\\frac{T_2^2 m_2 + |\\mathbf{p}_2^\\prime|x\\sqrt{m_1^2 |\\mathbf{p}_2^\\prime|^2 x^2 + T_2^2 (m_2^2-m_1^2)}}{|\\mathbf{p}_2^\\prime|^2 x^2 - T_2^2}. \\end{equation} \\] Note that \\(E_1\\) gives the total energy of particle 1, thus \\(T_1 = E_1 - m_1\\) . It is true that \\(E_1 = T_1\\) only in the special case where \\(m_1 = 0\\) . Moreover, one can differentiate \\(E_1\\) with respect to \\(T_2\\) , which yields $$ \\begin{equation}\\label{eq:dE1/dT2} \\frac{dE_1}{dT_2}=m_2x^2\\times \\frac{\\alpha +\\beta + \\gamma}{\\eta} \\end{equation} $$ where \\[ \\begin{align*} \\alpha &= m_1^2 \\delta, \\\\ \\beta & = m_2^2 (2T_2+\\delta),\\\\ \\gamma &= 2m_2 x \\kappa,\\\\ \\eta &= \\delta^2 x \\kappa, \\end{align*} \\] with \\(\\delta=-T_2 + (T_2 + 2m_2)x^2\\) and \\(\\kappa=\\sqrt{(T_2+2m_2)(\\alpha+ T_2 m_2^2 )}\\) . In most cases, elastic scattering does not change the mass of the particles, thus \\[\\begin{equation} \\frac{dE_1}{dT_2} = \\frac{d}{dT_2}(T_1 + m_1) = \\frac{dT_1}{dT_2} \\end{equation}\\] and this allows all relevant quantities to be expressed in terms of the kinetic energies \\(T_i\\) . When constructing the corresponding class , the namespace will consistently refer to \\(T_i\\) instead of \\(E_i\\) . Although the angle \\(\\vartheta\\) for particle 1 is irrelevant to our study, it can still be determined via 3-momentum conservation \\begin{equation} \\sin\\vartheta = \\frac{|\\mathbf{p}_2^\\prime|}{|\\mathbf{p}_1^\\prime|} \\sin\\psi \\end{equation} where \\(|\\mathbf{p}_1^\\prime| = \\sqrt{E_1^{\\prime 2} - m_1^2}\\) and \\(E_1^\\prime = E_1 - T_2\\) .","title":"General expressions"},{"location":"api/kinematics/22scat/#validation","text":"Now recall the \\(\\nu\\chi\\) scattering with \\(E_1 = E_\\nu\\) , \\(T_2 = T_\\chi\\) , \\(m_1 = m_\\nu = 0\\) , and \\(m_2 = m_\\chi\\) . With \\(|\\mathbf{p}_2^\\prime| = |\\mathbf{p}_\\chi| = \\sqrt{T_\\chi (T_\\chi + m_\\chi)}\\) , Eq. \\eqref{eq:E1} becomes \\[\\begin{equation}\\label{eq:Ev} E_\\nu = T_\\chi m_\\chi \\frac{T_\\chi + |\\mathbf{p}_\\chi| x}{(|\\mathbf{p}_\\chi| x - T_\\chi)(|\\mathbf{p}_\\chi| x + T_\\chi)} = \\frac{T_\\chi m_\\chi}{|\\mathbf{p}_\\chi| x - T_\\chi}. \\end{equation}\\] Additionally, \\[\\begin{align*} \\alpha &= 0, \\\\ \\beta &= m_\\chi^2 \\left(T_\\chi + (T_\\chi + 2m_\\chi)x^2\\right), \\\\ \\gamma &= 2m_\\chi^2 |\\mathbf{p}_\\chi| x, \\\\ \\eta &= \\delta^2 m_\\chi |\\mathbf{p}_\\chi| x, \\end{align*}\\] and after some tedious algebra, we obtain \\[\\begin{align*} m_\\chi x^2 \\frac{\\alpha + \\beta + \\gamma}{\\eta} &= \\frac{x}{\\delta^2} \\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|} \\left(T_\\chi + (T_\\chi + 2m_\\chi)x^2 + 2|\\mathbf{p}_\\chi| x \\right) \\\\ &= \\frac{x}{\\delta^2} \\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|} \\left( T_\\chi + \\frac{|\\mathbf{p}_\\chi|^2}{T_\\chi} x^2 + 2|\\mathbf{p}_\\chi| x \\right) \\\\ &= \\frac{x}{\\delta^2} \\frac{m_\\chi^2}{|\\mathbf{p}_\\chi|} \\frac{(T_\\chi + |\\mathbf{p}_\\chi| x)^2}{T_\\chi}. \\end{align*}\\] We also use \\[\\begin{align*} \\delta^2 &= \\left(-T_\\chi + \\frac{|\\mathbf{p}_\\chi|^2}{T_\\chi} x^2 \\right)^2 = \\frac{(|\\mathbf{p}_\\chi|^2 x^2 - T_\\chi^2)^2}{T_\\chi^2} \\\\ &= \\frac{(|\\mathbf{p}_\\chi| x - T_\\chi)^2 (|\\mathbf{p}_\\chi| x + T_\\chi)^2}{T_\\chi^2}, \\end{align*}\\] which leads to the final result \\[\\begin{equation}\\label{eq:dEv/dTx} m_\\chi x^2 \\frac{\\alpha + \\beta + \\gamma}{\\eta} = \\left( \\frac{m_\\chi}{|\\mathbf{p}_\\chi| x - T_\\chi} \\right)^2 \\frac{T_\\chi}{|\\mathbf{p}_\\chi|} x = \\frac{dE_\\nu}{dT_\\chi}. \\end{equation}\\] We observe that Eqs. \\eqref{eq:Ev} and \\eqref{eq:dEv/dTx} are exactly Eqs. (5) and (8) in BDM Physics , respectively. We therefore conclude that Eqs. \\eqref{eq:E1} and \\eqref{eq:dE1/dT2} are the general expressions for 2-2 elastic scattering involving non-zero masses.","title":"Validation"},{"location":"api/kinematics/KallenLambda/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.KallenLambda \u00b6 snorer.KallenLambda( x , y , z ) \u00b6 K\u00e4llen lambda function $$ \\lambda(x,y,z)=x^2+y^2+z^2-2(xy+yz+zx), $$ a useful function for evaluating kinetical quantities in particle physics. Parameters: x : array_like y : array_like z : array_like Returns: out : scalar/ndarray out is scalar if all inputs are scalars. References \u00b6 V. Ilisie, Concepts in quantum field theory: A practitioner's toolkit , Springer (2016)","title":"KallenLambda"},{"location":"api/kinematics/KallenLambda/#snorerkallenlambda","text":"","title":"snorer.KallenLambda"},{"location":"api/kinematics/Kinematics/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Kinematics \u00b6 class snorer.Kinematics( T2 , m1 , m2 , psi ) \u00b6 This class constructs the required kinetic energy \\(T_1\\) of incoming particle with mass \\(m_1\\) to boost the target with mass \\(m_2\\) to kinetic energy \\(T_2\\) along the direction \\(\\psi\\) . See Fig. 1 in 2-2 elastic scattering . Parameters: T2 : array_like Kinetic energy \\(T_2\\) received by the particle 2, MeV m1 : array_like Mass of particle 1 (incident) \\(m_1\\) , MeV m2 : array_like Mass of particle 2 (target) \\(m_2\\) , MeV psi : array_like Lab frame scattering angle \\(\\psi\\) , rad Attributes: T1 : scalar/ndarray The required kinetic energy \\(T_1\\) of particle 1, MeV dT1 : scalar/ndarray The Jacobian \\(dT_1/dT_2\\) , dimensionless x : scalar/ndarray \\(x:=\\cos\\psi \\in [1,-1]\\) sanity : boolr/ndarray Are the parameters physically plausible? True for plausible and False for physically impossible. dLips : scalar/ndarray Value for differential Lorentz invariant phase space Examples Import snorer and do >>> import snorer as sn >>> T2,m1,m2,psi = 15,0,1e-3,0.05 # kinetic energy, m1, m2, scattering angle >>> snv = sn.Kinematics(T2,m1,m2,psi) >>> snv.T1 # required kinetic energy T1 for particle 1 -0.8451953159962898 >>> snv.dT1 # Jacobian 0.0031707324661873464 >>> snv.sanity # is this physically possible? False It is clear that massless particle 1 is no way to upscatter particle 2 with \\(m_2=10^{-3}\\) MeV to \\(T_2=15\\) MeV at angular direction \\(\\psi\\) . Becasue the required \\(T_1\\) ( snv.T1 ) is negative. The attribute snv.sanity is False , which implies this reaction is physically impossible.","title":"Kinematics"},{"location":"api/kinematics/Kinematics/#snorerkinematics","text":"","title":"snorer.Kinematics"},{"location":"api/kinematics/Mandelstam/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Mandelstam \u00b6 class snorer.Mandelstam( T2 , m1 , m2 , psi ) \u00b6 Superclass: snorer.Kinematics This class constructs the associated Mandelstam variables \\(s\\) , \\(t\\) and \\(u\\) associated with the scattering process depicted in Fig. 1 in 2-2 elastic scattering . Parameters: T2 : array_like Kinetic energy \\(T_2\\) received by the particle 2, MeV m1 : array_like Mass of particle 1 (incident) \\(m_1\\) , MeV m2 : array_like Mass of particle 2 (target) \\(m_2\\) , MeV psi : array_like Lab frame scattering angle \\(\\psi\\) , rad Attributes: s : scalar/ndarray The \\(s\\) -channel in this scattering process, MeV 2 t : scalar/ndarray The \\(t\\) -channel in this scattering process, MeV 2 u : scalar/ndarray The \\(u\\) -channel in this scattering process, MeV 2 T1 : scalar/ndarray The required kinetic energy \\(T_1\\) of particle 1, MeV dT1 : scalar/ndarray The Jacobian \\(dT_1/dT_2\\) , dimensionless x : scalar/ndarray \\(x:=\\cos\\psi \\in [1,-1]\\) sanity : bool/ndarray Are the parameters physically plausible? True for plausible and False for physically impossible. dLips : scalar/ndarray Value for differential Lorentz invariant phase space Notes Given \\(T_1\\) is obtained from its superclass snorer.Kinematics , we can evaluate all Mandelstam variables easily. Thus, \\[ \\begin{align*} s &= (p_1+p_2)^2 = m_1^2+m_2^2 + 2 E_1 m_1 \\\\ &= m_1^2+m_2^2 + 2(T_1+m_1)m_2 \\end{align*} \\] for \\(s\\) -channel, and \\[ \\begin{align*} t &= (p_2^\\prime - p_2)^2 = 2m_2^2 - 2E_2 E_2^\\prime \\\\ &= 2m_2^2 - 2(T_2+m_2)m_2. \\end{align*} \\] For \\(u\\) -channel, we use the identity $$ s+t+u = \\sum_i m_i^2 = 2(m_1^2+m_2^2) $$ where \\(i\\) indicates all particle masses before and after the reaction. References \u00b6 M. Peskin and D. Schroeder, An Introduction To Quantum Field Theory , Westview (1995)","title":"Mandelstam"},{"location":"api/kinematics/Mandelstam/#snorermandelstam","text":"","title":"snorer.Mandelstam"},{"location":"api/kinematics/Neutrino/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.Neutrino \u00b6 class snorer.Neutrino( Tx , mx , psi ) \u00b6 Superclass: snorer.Kinematics This class constructs the required neturino energy to have BDM with \\((T_\\chi,m_\\chi,\\psi)\\) . See Fig. 2 in BDM Physics . We have assumed neutrino mass \\(m_\\nu=0\\) . Parameters: Tx : array_like BDM kinetic energy \\(T_\\chi\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV psi : array_like Lab frame scattering angle \\(\\psi\\) , rad Attributes: Ev : scalar/ndarray The required neutrino energy \\(E_\\nu\\) to boost DM with \\(m_\\chi\\) to \\(T_\\chi\\) , MeV dEv : scalar/ndarray The Jacobian \\(dE_\\nu/dT_\\chi\\) , dimensionless x : scalar/ndarray \\(x:=\\cos\\psi \\in [1,-1]\\) sanity : bool/ndarray Is the reaction physically plausible? True for plausible and False for physically impossible. dLips : scalar/ndarray Value for differential Lorentz invariant phase space Examples Import snorer and do >>> import snorer as sn >>> Tx,mx,psi = 15,1e-3,0.05 # BDM kinetic energy, mx, scattering angle >>> snv = sn.Neutrino(Tx,mx,psi) >>> snv.Ev # required Ev -0.8451953159962898 >>> snv.dEv # Jacobian 0.0031707324661873464 >>> snv.sanity # is this physically possible? False This example is identical to the example conducted in snorer.Kinematics as snorer.Kinematics is the superclass of snorer.Neutrino . One understands that \\(T_1=E_\\nu\\) , \\(T_2=T_\\chi\\) , \\(m_1=m_\\nu=0\\) and \\(m_2=m_\\chi\\) .","title":"Neutrino"},{"location":"api/kinematics/Neutrino/#snorerneutrino","text":"","title":"snorer.Neutrino"},{"location":"api/kinematics/get_gx/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_gx \u00b6 snorer.get_gx( Ev , mx , psi ) \u00b6 Calculate the probability density for cross section at scattering angle psi and averaged over azimuthal angle in lab frame. This is for energy-independent cross section. See Eq. (3) in BDM Physics . Parameters: Ev : array_like The incoming neutrino energy \\(E_\\nu\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV psi : array_like Lab frame scattering angle \\(\\psi\\) , rad Returns: out : scalar/ndarray Probability density for cross section at \\(\\psi\\) and averaged over azimuthal angle \\(2\\pi\\) . The result is a scalar if the three inputs are all scalars. The unit is sr \u22121 Examples In this example, we show \\(2\\pi g_\\chi\\sin\\psi\\) vs. \\(\\psi\\) for various \\(m_\\chi\\) . import numpy as np import matplotlib.pyplot as plt import snorer as sn # Neutrino energy, mx values and psi range Ev = 10 mx_vals = np.logspace(-3,0,4) psi_vals = np.linspace(0,np.pi/2,500) # Draw gx plots for various mx for mx in mx_vals: dOmega = 2*np.pi*np.sin(psi_vals) gx_vals = get_gx(Ev,mx,psi_vals)*dOmega plt.plot(psi_vals,gx_vals,label=fr'$m_\\chi={1000*mx:.0f}$ keV') plt.yscale('log') plt.ylim(9.5e-3,) plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$2\\pi g_\\chi\\sin\\psi$') plt.legend() plt.show()","title":"get_gx"},{"location":"api/kinematics/get_gx/#snorerget_gx","text":"","title":"snorer.get_gx"},{"location":"api/kinematics/get_psiMax/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_psiMax \u00b6 ssnorer.get_psiMax( Tx , mx ) \u00b6 Get the maximumly allowed scattering angle \\(\\psi_{\\rm max}\\) . Se Eq. (6) BDM Physics . Parameters: Tx : array_like BDM kinetic energy \\(T_\\chi\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV Returns: out : scalar/ndarray Maximum allowed scattering angle \\(\\psi_{\\rm max}\\) [rad]. out is scalar if all inputs are scalars.","title":"get_psiMax"},{"location":"api/kinematics/get_psiMax/#snorerget_psimax","text":"","title":"snorer.get_psiMax"},{"location":"api/kinematics/get_thetaMax/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_thetaMax \u00b6 snorer.get_thetaMax( t , Tx , mx , Rs ) \u00b6 Find the maximum BDM field-of-view, \\(\\theta_{M}^*\\) , that centers SN at particular time \\(t^*\\) . See Eq. (24) in BDM Physics . Parameters: t : scalar The BDM at particular time \\(t^*\\) , seconds. If \\(t^* > t_{\\rm van}\\) , the result is unphysical. Tx : scalar BDM kinetic energy \\(T_\\chi\\) , MeV mx : scalar DM mass \\(m_\\chi\\) , MeV Rs : scalar Distance to supernova, \\(R_s\\) , kpc. Returns: out : scalar Maximum field-of-view centers supernova, \\(\\theta^*_M\\) [rad].","title":"get_thetaMax"},{"location":"api/kinematics/get_thetaMax/#snorerget_thetamax","text":"","title":"snorer.get_thetaMax"},{"location":"api/kinematics/get_tvan/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_tvan \u00b6 snorer.get_tvan( Tx , mx , Rs ) \u00b6 Get the BDM vanishing time. The time-zero is set as the arrival of SN \\(\\nu\\) at Earth. See Eqs. (22) and (23) in BDM Physics . Parameters: Tx : array_like BDM kinetic energy \\(T_\\chi\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV Rs : array_like Distance to supernova, \\(R_s\\) , kpc Returns: out : scalar/ndarray BDM vanishing time \\(t_{\\rm van}\\) , seconds Examples In this example, we show \\(t_{\\rm van}\\) on \\((m_\\chi,T_\\chi)\\) plane. import numpy as np import matplotlib.pyplot as plt import matplotlib.colors as mcolors import snorer as sn Rs = 9.6 # SN distance, kpc Tx_vals = np.logspace(-6,2,100) # Tx values mx_vals = np.logspace(-6,3,100) # mx values # Setup meshgrid for (mx,Tx) plane MX,TX = np.meshgrid(mx_vals,Tx_vals,indexing='ij') # Evaluating tvan and convert it to years TVAN = sn.get_tvan(TX,MX,Rs)/sn.constant.year2Seconds # Plot fig, ax = plt.subplots() # log-scaler color norm = mcolors.LogNorm(vmin=TVAN.min(), vmax=TVAN.max()) # Contour plot contour = ax.contourf(MX, TX, TVAN, levels=20, cmap=\"viridis\", norm=norm) ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel(r'$m_\\chi$ [MeV]') ax.set_ylabel(r'$T_\\chi$ [MeV]') # Color bar cbar = fig.colorbar(contour, ax=ax) cbar.set_label(r\"$t_{\\rm van}$ [yrs]\") plt.show() Notes Practically speaking, the underlying algorithm of snorer.get_tvan is not vectorized. It relies on numpy.nditer to support vectorized inputs/outputs. The kernel of snorer.get_tvan is the internal function snorer._get_tof which has the same Parameters and Returns as snorer.get_tvan but only accepts scalar inputs/outputs. It could become clumsy when the points to be calcuated are massive.","title":"get_tvan"},{"location":"api/kinematics/get_tvan/#snorerget_tvan","text":"","title":"snorer.get_tvan"},{"location":"api/kinematics/get_vx/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.get_vx \u00b6 ssnorer.get_vx( Tx , mx ) \u00b6 Get dimensionless BDM velocity \\(v_\\chi/c\\) . See BDM Physics for detail. Parameters: Tx : array_like BDM kinetic energy \\(T_\\chi\\) , MeV mx : array_like DM mass \\(m_\\chi\\) , MeV Returns: out : scalar/ndarray Dimensionless BDM velocity. out is scalar if all inputs are scalars.","title":"get_vx"},{"location":"api/kinematics/get_vx/#snorerget_vx","text":"","title":"snorer.get_vx"},{"location":"api/main/differential_flux/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.differential_flux \u00b6 snorer.differential_flux( t , Tx , mx , theta , phi , Rs , beta , Re=8.5 , sigxv0=1e-45 , is_spike=False , **kwargs ) \u00b6 The differential supernova-neutrin-boosted dark matter flux at Earth at specific time \\(t\\) and angular direction \\((\\theta,\\varphi)\\) \\[ \\left.\\tau_s\\mathcal{J}j_\\chi(d(t),r(t),T_\\chi,\\psi)\\right|_{t=\\frac{d}{c}+\\frac{\\ell}{v_\\chi}-t_\\nu}. \\] See the equation before Eq. (18) in BDM Physics , cf. Fig. 1 too. Parameters: t : float Time \\(t\\) , relative to the SN \\(\\nu\\) 's arrival Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. theta : float The zenith angle \\(\\theta\\) , rad. phi : float The azimuthal angle \\(\\varphi\\) that centers SN, rad. Rs : floate Distance from supernova to Earth, kpc. beta : floate The off-center angle, characterizes how SN deviates from GC-Earth axis angularly, rad. Re : floate The distance from GC to Earth, kpc. Default is 8.5 kpc. sigxv0 : float* Total DM- \\(\\nu\\) cross section, cm 2 . It will be multiplied by snorer.get_gx to account for the angular distribution and makes it cm 2 sr \u22121 . is_spike : bool Is halo spike included? Default is False . **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.min_distance , snorer.params.halo and snorer.params.spike . Returns: out : scalar The differential BDM flux at Earth, MeV \u22121 cm \u22122 s \u22121 sr \u22121 .","title":"differential_flux"},{"location":"api/main/differential_flux/#snorerdifferential_flux","text":"","title":"snorer.differential_flux"},{"location":"api/main/dsigma_xv/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.dsigma_xv \u00b6 snorer.dsigma_xv( Ev , mx , psi , sigxv0='1e-45' ) \u00b6 Differential DM- \\(\\nu\\) scattering cross section at angle \\(\\psi\\) in lab frame, $$ \\frac{d\\sigma_{\\chi\\nu}}{d\\Omega_{\\rm lab}}=\\sigma_0 \\times g_\\chi(\\psi). $$ See Eqs. (2) and (3) in BDM Physics . Parameters: Ev : array_like Neutrino energy, MeV. mx : array_like Dark matter mass, MeV. psi : array_like Lab frame scattering angle \\(\\psi \\in [0,\\pi/2]\\) . sigxv0 : array_like Energy-independent DM- \\(\\nu\\) cross section \\(\\sigma_0\\) , cm 2 . Default is \\(10^{-45}\\) cm 2 . Returns: out : scalar/ndarray Differential DM- \\(\\nu\\) cross section, cm 2 sr \u22121 . Out is scalar if all inputs are scalars. Notes The result is simply sigxv0 * snorer.get_gx . See also snorer.get_gx .","title":"dsigma_xv"},{"location":"api/main/dsigma_xv/#snorerdsigma_xv","text":"","title":"snorer.dsigma_xv"},{"location":"api/main/emissivity_jx/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.emissivity_jx \u00b6 snorer.emissivity_jx( Ev , dEv , mx , d , r , psi , sigxv0=1e-45 , d_cut=3.24e-15 , is_spike=False , **kwargs ) \u00b6 Emissivity \\(j_\\chi\\) of supernova-neutrino-boost dark matter at boost point. See Eq. (13) in BDM Physics . Parameters: Ev : array_like The supernova neutrino energy, MeV. dEv : array_like The Jacobian \\((dE_\\nu/dT_\\chi)(v_\\chi/c)\\) that converts per netrino energy width, \\(dE_\\nu\\) , to per BDM kinetic energy width, \\(dT_\\chi\\) . mx : array_like Dark matter mass, MeV. d : array_like Distance from supernova to boost point, kpc. r : array_like Distance from galactic center to boost point, kpc. psi : array_like The scattering angle in lab frame at boost point, rad. sigxv0 : float* Total DM- \\(\\nu\\) cross section, cm 2 . It will be multiplied by snorer.get_gx to account for the angular distribution and makes it cm 2 sr \u22121 . d_cut : float Terminating point for \\(d\\) . Below the value will return 0. Default is \\(3.24\\times 10^{-15}\\) kpc, approximating 100 km, the size of neutrino sphere. is_spike : bool Whether spike feature is included in \\(n_\\chi\\) . Default is False. **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.halo and snorer.params.spike . Returns: out : scalar/ndarray BDM emissivity at boost point along the direction \\(\\psi\\) , MeV \u22121 cm \u22123 s \u22121 sr \u22121 .","title":"emissivity_jx"},{"location":"api/main/emissivity_jx/#snoreremissivity_jx","text":"","title":"snorer.emissivity_jx"},{"location":"api/main/event/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.event \u00b6 snorer.event( mx , Rs , beta , Re=8.5 , Tx_range=[5,30] , t_range=[10,1.1045e+09] , sigxv0=1e-45 , is_spike=False , **kwargs ) \u00b6 The supernova-neutrino-boosted dark matter evnet per electron with DM- \\(e\\) cross section \\(\\sigma_{\\chi e}\\) normalized to 1 cm 2 at Earth. The field-of-view \\(d\\Omega\\) is integrated over entirely and the kinetic energy \\(T_\\chi\\) , exposure time \\(t\\) can be integrated within user-defined ranges. Precisely speaking, the event \\(N_\\chi\\) is, using Eqs. (18) in BDM Physics , \\[ N_\\chi = N_e \\sigma_{\\chi e} \\int_{t_{\\rm min}}^{t_{\\rm max}} dt \\int_{T_{\\chi,{\\rm min}}}^{T_{\\chi,{\\rm max}}} dT_\\chi \\frac{d\\Phi_\\chi}{dT_\\chi} \\] and snorer.event presumes \\(N_e=1\\) and \\(\\sigma_{\\chi e}=1\\) cm 2 . One can restore the correct \\(N_\\chi^{\\rm correct}\\) for any detector by multiplying the true \\(N_e^{\\rm true}\\) for that detector and \\(\\sigma_{\\chi e}^{\\rm true}\\) , \\[ N_\\chi^{\\rm correct} = N_\\chi \\times \\frac{N_e}{1}\\times \\frac{\\sigma_{\\chi e}^{\\rm true}}{1 \\,{\\rm cm^2}} \\times \\frac{\\sigma_{\\chi\\nu}^{\\rm true}}{10^{-45}\\,{\\rm cm^2}} \\] where we have set \\(\\sigma_{\\chi \\nu}=10^{-45}\\) cm 2 by default in the function. Parameters: mx : float Dark matter mass, MeV. Rs : floate Distance from supernova to Earth, kpc. beta : floate The off-center angle, characterizes how SN deviates from GC-Earth axis angularly, rad. Re : floate The distance from GC to Earth, kpc. Default is 8.5 kpc. Tx_range : list Integration range for BDM kinetic energy [Tx_min,Tx_max] , MeV t_range : list Integration range for exposure time [t_min,t_max] , seconds sigxv0 : float* Total DM- \\(\\nu\\) cross section, cm 2 . It will be multiplied by snorer.get_gx to account for the angular distribution and makes it cm 2 sr \u22121 . is_spike : bool Is halo spike included? Default is False . **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.min_distance , snorer.params.halo , snorer.params.spike and snorer.params.vegas . Returns: out : scalar Event number of supernova-neutrino-boosted dark matter per electron. Notes We also use vegas to evaluate \\(N_\\chi\\) . See Notes in snorer.flux .","title":"event"},{"location":"api/main/event/#snorerevent","text":"","title":"snorer.event"},{"location":"api/main/flux/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.flux \u00b6 snorer.flux( t , Tx , mx , Rs , beta , Re=8.5 , sigxv0=1e-45 , is_spike=False , **kwargs *) \u00b6 The supernova-neutrino-boosted dark matter flux at time \\(t\\) on Earth after integrated over a field-of-view \\(d\\Omega\\) . Note that zenith angle \\(\\theta\\) is integrated up to \\(\\theta^*_M\\) and azimuthal angle \\(\\varphi\\) from \\(0\\) to \\(2\\pi\\) . See Eqs. (18) and (24) in BDM Physics , cf. Fig. 1 too. Parameters: t : float Time \\(t\\) , relative to the SN \\(\\nu\\) 's arrival Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. Rs : floate Distance from supernova to Earth, kpc. beta : floate The off-center angle, characterizes how SN deviates from GC-Earth axis angularly, rad. Re : floate The distance from GC to Earth, kpc. Default is 8.5 kpc. sigxv0 : float* Total DM- \\(\\nu\\) cross section, cm 2 . It will be multiplied by snorer.get_gx to account for the angular distribution and makes it cm 2 sr \u22121 . is_spike : bool Is halo spike included? Default is False . **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.min_distance , snorer.params.halo , snorer.params.spike and snorer.params.vegas . Returns: out : scalar The differential BDM flux at Earth, MeV \u22121 cm \u22122 s \u22121 sr \u22121 . Notes We use vegas to evaluate the integral Eq. (18). This explains why we incorporate nitn and neval in keyword arguments. Increasing these values will improve the accuracy but the computation time enhances too. One may need to find a balance between acceptable accuracy and evaluation time.","title":"flux"},{"location":"api/main/flux/#snorerflux","text":"","title":"snorer.flux"},{"location":"api/main/sn_nu_spectrum/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.sn_nu_spectrum \u00b6 snorer.sn_nu_spectrum( Ev , d , d_cut=3.24e-15 , is_density=False ) \u00b6 Supernova neutrino spectrum at distance \\(d\\) to supernova, $$ \\frac{dN_\\nu}{dE_\\nu}=\\sum_i\\frac{L_{\\nu_i}}{4\\pi d^2\\langle E_{\\nu_i}\\rangle} f_{\\nu_i}(E_\\nu). $$ See Eqs. (9-12) in BDM Physics for detail. Parameters: Ev : array_like Supernova neutrino energy, MeV. d : array_like Distance from supernova to the boost point, kpc. d_cut : float Terminating point for \\(d\\) . Below the value will return 0. Default is \\(3.24\\times 10^{-15}\\) kpc, approximating 100 km, the size of neutrino sphere. is_density : bool Should convert the output to the unit of number density. Default is False and output has the unit of flux. Returns: out : scalar/ndarray Outputs flux [MeV \u22121 cm \u22122 s \u22121 ] when is_density = False , or number density [MeV \u22121 cm \u22123 ] when is_density = True . The output is scalar if all inputs are scalars. Examples In this example, we show \\(dN_\\nu/dE_\\nu\\) over \\((E_\\nu,d)\\) plane. One can clearly see that \\(d<\\) d_cut the flux is 0. import numpy as np import matplotlib.pyplot as plt import matplotlib.colors as mcolors import snorer as sn Ev_vals = np.logspace(-3,2,100) # Ev values d_vals = np.logspace(-16,2,200) # d values # Setup meshgrid for (Ev,d) plane Ev,D = np.meshgrid(Ev_vals,d_vals,indexing='ij') # Evaluate SNv flux DNvDEv = sn.sn_nu_spectrum(Ev,D) # Plot fig, ax = plt.subplots() # log-scaler color norm = mcolors.LogNorm(vmin=DNvDEv.min() + 1, vmax=DNvDEv.max()) # Contour plot contour = ax.contourf(Ev, D, DNvDEv, levels=20, cmap=\"viridis\", norm=norm) ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel(r'$E_\\nu$ [MeV]') ax.set_ylabel(r'$d$ [kpc]') # Color bar cbar = fig.colorbar(contour, ax=ax) cbar.set_label(r\"$dN_\\nu/dE_\\nu$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]\") plt.show()","title":"sn_nu_spectrum"},{"location":"api/main/sn_nu_spectrum/#snorersn_nu_spectrum","text":"","title":"snorer.sn_nu_spectrum"},{"location":"api/params/params/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.params \u00b6 snorer.params \u00b6 This instance contains default parameters that will be used in many functions as keyword arguments ( **kwargs ). Four classes of parameters are predefined (not loaded automatically with snorer in the beginning) and incorporated as attributes in this instance. We illustrate them in the followings. snorer.params.min_distance \u00b6 Instance. Attributes: d_cut : float Terminating point for \\(d\\) . Below this value snorer.sn_nu_spectrum will return 0. Default is \\(3.24\\times 10^{-15}\\) kpc, approximating 100 km, the size of neutrino sphere. r_cut : float Terminating \\(n_\\chi\\) when \\(r^\\prime <\\) r_cut , kpc. Below this value snorer.differential_flux will return 0. If one needs to incorporate dark matter spike in the central region, r_cut cannot be too large. Otherwise, the spike effect will be chopped off before it has any noticeble consequence. Default is \\(10^{-8}\\) kpc. snorer.params.halo \u00b6 Instance. Attributes: rhos : float Characteristic density, MeV cm \u22123 . Default is 184. rs : float Characteristic length, kpc. Default is 24.4. n : float Index for the halo. Default is 2. snorer.params.spike \u00b6 Instance. The following will be used as keyword arguments when is_spike = True . When having is_spike = False , typing any of the following arguments into function input will result in ValueError. Attributes: mBH : float Supermassive black hole (SMBH) mass, \\(M_\\odot\\) . Default is \\(4.29\\times 10^6\\) . tBH : float SMBH age, years. Default is \\(10^9\\) . rh : float SMBH influence radius, kpc. Defaut is 0.002. alpha : str Profile slope for halo spike, '3/2' or '7/3' . Default is '3/2' . sigv : None or float DM annihilation cross section, in the unit of \\(10^{-26}\\) cm 3 s \u22121 . None indicates no annihilation and 5.9 as \\(5.9\\times 10^{-26}\\) . snorer.params.vegas \u00b6 Instance. Attributes: nitn : int Number of chains in vegas for each integration. Default is 10. neval : int Number of evaluationg points in each chain in vegas . Default is 10000. Notes What type or types of parameters are contained in **kwargs of that function will be documented in its docstrings. Suppose the docstrings says the keyword arguments containing the values in min_distance , halo and spike , it means all the attributes in the above three categories can be used as keyword arguments in that function. We illustrate this in the following examples. Examples To view the default value, such as the characteristic density rhos in snorer , we can do >>> import snorer as sn # import snorer >>> print(sn.params.halo.rhos) 184 For spike default, such as SMBH mass mBH , >>> print(sn.params.spike.mBH) 4290000.0 In terms of implementation, let's take snorer.event as an example. By looking at its doc page, the necessary **kwargs at least contains: rhos , rs , n , d_cut , r_cut , nitn and neval . However if one sets is_spike = True , then the followings: mBH , tBH , rh , alpha and sigv are also mandatory. If user didn't specify any of them above, they snorer will use default values listed above. For instance, without any keyword argument specification >>> mx,Rs,beta = 1e-2,8.5,0.3 >>> event = sn.event(mx,Rs,beta) # none of the kwargs is specified. >>> print(event) 1.4301996553521633e-06 If we want to specify rhos and mBH , we can do >>> event_spike = sn.event(mx,Rs,beta,is_spike=True,rhos=500,mBH=1e7) >>> print(event_spike) 3.883407626493457e-06 Note that event_spike is slightly larger than event due to we turn on spike feature. However, the enhancement is not drastic due to supernova is not exactly located at the center as beta is not 0. If we remove is_spike , then the program uses default is_spike = False . This will result in ValueError due to mBH only valid when spike feature turns on.","title":"Parameters"},{"location":"api/params/params/#snorerparams","text":"","title":"snorer.params"},{"location":"api/utils/BDM/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.BoostedDarkMatter \u00b6 class snorer.BoostedDarkMatter( Rs , Rg , beta , amp2_xv , amp2_xe , mt=None , is_spike=False , **kwargs ) \u00b6 Superclass: Constants Class with medoths that evaluate supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) coming from SN in arbitrary distant galaxy with DM- \\(\\nu\\) and DM- \\(e\\) interaction cross sections descrbied by a specific particle model. This class integrates functions like snorer.flux and snorer.event as methods for user to calculate the SN \\(\\nu\\) BDM flux and event associated to any models. To construct the scattering amplitude \\(\\mathcal{M}\\) from a specific model, we take the one discussed in Ref. [ 1 ] for instance. Both DM- \\(\\nu\\) and DM- \\(e\\) have the same amplitude square \\(|\\mathcal{M}|^2\\) shown by Eq. (3) of Ref. [ 1 ] in terms of Mandelstam variables \\(s\\) , \\(t\\) , and \\(u\\) , \\[ |\\mathcal{M}|^2 = 2 \\left(\\frac{\\mathcal{Q}}{t} - m_V^2\\right)^2 (s^2 + u^2 + 4t (m_1^2 + m_2^2) - 2 (m_1^2 + m_2^2)^2) \\] where \\(\\mathcal{Q}\\) is the multiplication of coupling constants, \\(m_1\\) and \\(m_2\\) are the masses of incident and target particles respectively and \\(m_V\\) the mediator mass. Thus we can construct DM- \\(\\nu\\) amplitude square by letting, \\(m_1 = 0\\) and assume \\(m_V = m_\\chi/3\\) , \\(g_V = 10^{-6}\\) and \\(g_\\chi = 10^{-2}\\) , def amp2_xv(s,t,u,mx) -> float: mV = mx/3 gV,gx = 1e-06,1e-02 Q = gV*gx return (s**2 + u**2 + 4*t*(mx**2) - 2*(mx**2)**2)*(Q/(t - mV**2))**2 Similarily, for DM- \\(e\\) scattering, \\(m_1 = m_\\chi\\) , \\(m_2 = m_e\\) and kinetic mixing \\(\\varepsilon = 10^{-6}\\) , def amp2_xe(s,t,u,mx) -> float: mV = mx/3 me = snorer.constant.me gx,eps = 1e-02,1e-06 Q = gx*eps return 2*(s**2 + u**2 + 4*t*(me**2 + mx**2) - 2*(me**2 + mx**2)**2)*(Q/(t - mV**2))**2 These are the desired amplitudes and serve as the inputs in the class. Parameters: Rs : float Distance from Earth to SN, kpc. Rg : float Distance from Earth to the center of a distant galaxy, kpc. beta : float Off-center angle, rad. amp2_xv : func Amplitude squared for DM- \\(\\nu\\) interaction with 4 positioning arguments. amp2_xv = func(s,t,u,mx) : the first 3 are Mandelstam variables and the last one is the DM mass. amp2_xe : func Arguments are identical to amp2_xv , but is for DM- \\(e\\) interaction. Generally, amp2_xe is not exclusively for electron, user can assume any particle in the detector to be scattered off by BDM. If the target is not electron, user has to input its mass mt . See the description for parameter mt next. mt : None/float Mass of the target in the detector. Default is None and implies the target is electron. If amp2_xe is for particle other than electron, user has to assign its mass here. The unit is MeV. is_spike : bool Whether spike feature is included in \\(n_\\chi\\) . Default is False. **kwargs Keyword arguments for characteristic parameters of NFW profile and spike halo, . If is_spike = False , the parameters for configuring spiky halo will be deactivated. Default values assume Milky Way. See default arguments in snorer.params.halo and snorer.params.spike . nx( r , mx ) \u00b6 Method. Yields DM number density at place distant \\(r\\) to GC. Whether spike feature is on depending the initial setting of is_spike when the class instance is initialized. Parameters: r : float Distance from Earth to GC, kpc. mx : float Dark matter mass, MeV. Returns: out : float Dark matter number density at \\(r\\) , cm \u22123 . dsigma_xv( Tx , mx , psi ) \u00b6 Method. Yields differential DM- \\(\\nu\\) cross section for a given \\((T_\\chi,m_\\chi,\\psi)\\) associated with amp2_xv . Parameters: Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. psi : float Scattering angle in lab frame, rad. Returns: out : float Differential DM- \\(\\nu\\) cross section, cm 2 sr \u22121 . sigma_xe( Tx , mx ) \u00b6 Method. Yields total DM- \\(e\\) cross section for a given \\((T_\\chi,m_\\chi)\\) associated with amp2_xe . Parameters: Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. Returns: out : float Total DM- \\(e\\) cross section, cm 2 . flux( t , Tx , mx , **kwargs ) \u00b6 Method. The SN \\(\\nu\\) BDM flux at time \\(t\\) on Earth after integrated over a field-of-view \\(d\\Omega_{\\rm lab}\\) . Note that zenith angle \\(\\theta\\) is integrated up to \\(\\theta_{\\rm M}^*\\) and azimuthal angle \\(\\varphi\\) from \\(0\\) to \\(2\\pi\\) . Parameters: t : float The BDM ToF, relative to the first SN neutrino's arrival. Tx : float BDM kinetic energy, MeV. mx : float Dark matter mass, MeV. **kwargs Keyword arguments for min distances and vegas. See default arguments in snorer.params.min_distance and snorer.params.vegas . Returns: out : float The time-depenent boosted dark matter flux at Earth, MeV \u22121 cm 2 s \u22121 . event( mx , Tx_range=[5,30] , t_range=[10,1.1045e+09] , **kwargs ) \u00b6 Method. The SN \\(\\nu\\) BDM evnet per electron , \\(N_{\\chi,0}\\) . To retrieve the correct event number, one should mutiply the total electron number \\(N_e\\) . For instance, if the BDM event rate obtained from this function is \\(N_\\chi\\) , then the total BDM event in a detector with electron number \\(N_e\\) is \\[ N_\\chi^{\\rm correct} = N_e\\times N_{\\chi,0}. \\] Parameters: mx : float Dark matter mass, MeV. Tx_range : list Integration range for BDM kinetic energy [Tx_min,Tx_max] , MeV. Default is [5,30] . t_range : list Integration range for exposure time [t_min,t_max] , seconds. Default is [10,1.1045e+09] and implies t_max is around 35 years. **kwargs Keyword arguments for min distances and vegas. See default arguments in snorer.params.min_distance and snorer.params.vegas . Returns: out : float Event number of SN \\(\\nu\\) BDM per electron. References \u00b6 Y.-H. Lin et al. , Phys. Rev. D 108 , 083013 (2023)","title":"BoostedDarkMatter"},{"location":"api/utils/BDM/#snorerboosteddarkmatter","text":"","title":"snorer.BoostedDarkMatter"},{"location":"api/utils/coord_transf/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; Coordinate Transformations \u00b6 We briefly introduce how to extract the off-center angle \\(\\beta\\) , cf. Fig. 1 in BDM Physics , from two widely used astronomical coordinate systems: galactic and equatorial coordinates . This enables the input of arbitrary supernova (SN) locations from astrophysical databases, e.g. SRcat , into snorer , allowing users to evaluate its corresponding BDM signature. Galactic coordinate \u00b6 The galactic coordinate system is shown in Fig. 1 , with longitude \\(\\ell\\) and latitude \\(b\\) . Once \\((\\ell, b)\\) for a SN is specified, its position on the celestial sphere is determined. Given that the distance from Earth to the SN, \\(R_s\\) , is typically provided by the database, the final task is to extract \\(\\beta\\) , the deviation of SN from galactic center (GC) in polar direction. Figure 1. The galactic coordinate system, including longitude \\(\\ell\\) and latitude \\(b\\). Before proceeding, note that there are two conventions within this coordinate system. In the Cartesian representation, Earth is placed at the origin, and the GC is at \\((x, y, z) = (0, R_e, 0)\\) . See the side view of this geometric configuration in Fig. 2 . Figure 2. The Cartesian representation of galactic coordinate with distance included. With two unit vectors\u2014one pointing from Earth to the SN, \\(\\hat{\\mathbf{s}} = (x_s, y_s, z_s) / R_s\\) , and the other pointing from Earth to the GC, \\(\\hat{\\mathbf{g}} = (0, 1, 0)\\) \u2014we immediately find \\[\\begin{equation} y_s = R_s \\cos b \\cos\\ell. \\end{equation}\\] The reason why \\(x_s\\) and \\(z_s\\) are not needed becomes clear when we evaluate \\(\\beta\\) , \\[\\begin{equation}\\label{eq:cos_beta_MW} \\cos\\beta = \\hat{\\mathbf{g}} \\cdot \\hat{\\mathbf{s}} = \\cos b \\cos\\ell, \\end{equation}\\] which involves only the \\(y\\) -component of the SN position in galactic coordinates. Note that when we extract \\(\\beta\\) from galactic coordinates, the inverse transformation is not possible. It is evident that the map from \\((\\ell, b)\\) to \\(\\beta\\) is many-to-one : \\(\\beta\\) is a scalar while \\((\\ell, b)\\) contains two degrees of freedom. Without an additional constraint, the inverse problem is ill-posed. Therefore, reconstructing the SN location relative to the galactic plane using only \\(\\beta\\) is implausible. For completeness, to fully recover the spatial location, one would need the missing azimuthal angle around the Earth-GC axis, which depends on both \\(x_s\\) and \\(z_s\\) . We omit further detail here, as it is irrelevant to our current purpose. Supernova in arbitrary distant galaxy \u00b6 We now consider a more general case where the SN lies in an arbitrary distant galaxy, and we wish to evaluate the corresponding BDM signature from that SN. Again, regardless of how the scene changes, the underlying task remains the same: we must determine three quantities, \\(R_g\\) , \\(R_s\\) , and \\(\\beta\\) . The latter two are already familiar, while \\(R_g\\) refers to the distance between Earth and the center of the distant galaxy. Effectively, this means we replace \\(R_e\\) by \\(R_g\\) in the calculation. See Fig. 3 . Figure 3. SN in an arbitrary distant galaxy. Suppose the galactic coordinates for the two stellar objects are \\((\\ell_s, b_s)\\) for the SN and \\((\\ell_g, b_g)\\) for the distant GC. We can use the same procedure as before to obtain their Cartesian representations: \\((x_s, y_s, z_s)\\) for the SN and \\((x_g, y_g, z_g)\\) for the galaxy center. Thus, for the SN: \\[\\begin{align*} x_s &= R_s \\cos b_s \\sin(2\\pi - \\ell_s), \\\\ y_s &= R_s \\cos b_s \\cos \\ell_s, \\\\ z_s &= R_s \\sin b_s, \\end{align*}\\] and for the distant galaxy: \\[\\begin{align*} x_g &= R_g \\cos b_g \\sin(2\\pi - \\ell_g), \\\\ y_g &= R_g \\cos b_g \\cos \\ell_g, \\\\ z_g &= R_g \\sin b_g. \\end{align*}\\] We define two unit vectors for the two stellar objects: $$ \\hat{\\mathbf{s}} = (-\\cos b_s \\sin \\ell_s, \\cos b_s \\cos \\ell_s, \\sin b_s), $$ for pointing to the SN direction and $$ \\hat{\\mathbf{g}} = (-\\cos b_g \\sin \\ell_g, \\cos b_g \\cos \\ell_g, \\sin b_g). $$ for pointing to the GC. The angle \\(\\beta\\) can then be retrieved using the same dot product formula: \\begin{equation} \\cos \\beta = \\hat{\\mathbf{g}} \\cdot \\hat{\\mathbf{s}} = \\cos b_s \\cos b_g \\cos(\\ell_s - \\ell_g) + \\sin b_s \\sin b_g. \\end{equation} In the case of our MW, where \\(\\ell_g = b_g = 0\\) , this expression reduces to Eq. \\eqref{eq:cos_beta_MW}. Equatorial coordinate \u00b6 Another commonly used coordinate system is the equatorial coordinate system, which is specified by right ascension \\(\\alpha\\) (RA) and declination \\(\\delta\\) (DEC). Due to its complexity, we do not provide the detailed mathematical conversion from \\((\\alpha, \\delta)\\) to \\(\\beta\\) here. To handle this task, we make use of Astropy to convert \\((\\alpha, \\delta)\\) into \\((\\ell, b)\\) . Once this conversion is done, we can follow the discussion in the previous section to compute \\(\\beta\\) . Note that in snorer , we assume the input \\((\\alpha, \\delta)\\) values are expressed in the ICRS J2000.0 frame.","title":"Coordinate Transformations"},{"location":"api/utils/coord_transf/#coordinate-transformations","text":"We briefly introduce how to extract the off-center angle \\(\\beta\\) , cf. Fig. 1 in BDM Physics , from two widely used astronomical coordinate systems: galactic and equatorial coordinates . This enables the input of arbitrary supernova (SN) locations from astrophysical databases, e.g. SRcat , into snorer , allowing users to evaluate its corresponding BDM signature.","title":"Coordinate Transformations"},{"location":"api/utils/coord_transf/#galactic-coordinate","text":"The galactic coordinate system is shown in Fig. 1 , with longitude \\(\\ell\\) and latitude \\(b\\) . Once \\((\\ell, b)\\) for a SN is specified, its position on the celestial sphere is determined. Given that the distance from Earth to the SN, \\(R_s\\) , is typically provided by the database, the final task is to extract \\(\\beta\\) , the deviation of SN from galactic center (GC) in polar direction. Figure 1. The galactic coordinate system, including longitude \\(\\ell\\) and latitude \\(b\\). Before proceeding, note that there are two conventions within this coordinate system. In the Cartesian representation, Earth is placed at the origin, and the GC is at \\((x, y, z) = (0, R_e, 0)\\) . See the side view of this geometric configuration in Fig. 2 . Figure 2. The Cartesian representation of galactic coordinate with distance included. With two unit vectors\u2014one pointing from Earth to the SN, \\(\\hat{\\mathbf{s}} = (x_s, y_s, z_s) / R_s\\) , and the other pointing from Earth to the GC, \\(\\hat{\\mathbf{g}} = (0, 1, 0)\\) \u2014we immediately find \\[\\begin{equation} y_s = R_s \\cos b \\cos\\ell. \\end{equation}\\] The reason why \\(x_s\\) and \\(z_s\\) are not needed becomes clear when we evaluate \\(\\beta\\) , \\[\\begin{equation}\\label{eq:cos_beta_MW} \\cos\\beta = \\hat{\\mathbf{g}} \\cdot \\hat{\\mathbf{s}} = \\cos b \\cos\\ell, \\end{equation}\\] which involves only the \\(y\\) -component of the SN position in galactic coordinates. Note that when we extract \\(\\beta\\) from galactic coordinates, the inverse transformation is not possible. It is evident that the map from \\((\\ell, b)\\) to \\(\\beta\\) is many-to-one : \\(\\beta\\) is a scalar while \\((\\ell, b)\\) contains two degrees of freedom. Without an additional constraint, the inverse problem is ill-posed. Therefore, reconstructing the SN location relative to the galactic plane using only \\(\\beta\\) is implausible. For completeness, to fully recover the spatial location, one would need the missing azimuthal angle around the Earth-GC axis, which depends on both \\(x_s\\) and \\(z_s\\) . We omit further detail here, as it is irrelevant to our current purpose.","title":"Galactic coordinate"},{"location":"api/utils/coord_transf/#equatorial-coordinate","text":"Another commonly used coordinate system is the equatorial coordinate system, which is specified by right ascension \\(\\alpha\\) (RA) and declination \\(\\delta\\) (DEC). Due to its complexity, we do not provide the detailed mathematical conversion from \\((\\alpha, \\delta)\\) to \\(\\beta\\) here. To handle this task, we make use of Astropy to convert \\((\\alpha, \\delta)\\) into \\((\\ell, b)\\) . Once this conversion is done, we can follow the discussion in the previous section to compute \\(\\beta\\) . Note that in snorer , we assume the input \\((\\alpha, \\delta)\\) values are expressed in the ICRS J2000.0 frame.","title":"Equatorial coordinate"},{"location":"api/utils/equa_to_beta/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.equatorial_to_beta \u00b6 snorer.equatorial_to_beta( ra , dec , GC_coord=None ) \u00b6 Transform equatorial coordinate to off-center angle and galactic coordinate \\((\\beta,\\ell,b)\\) . Parameters: ra : array_like Right ascension, hms in string type. Eg. '5h6.7m4.4s' . dec : array_like Declination, dms in string type. Eg. '6d10.7m9.4s' . GC_coord : None/list The equatorial coordinate for arbitrary galactic center. Default is None , which automatically implements our Milky Way center. For a specific GC coordinate, it should have GC_coord = [RA,DEC] where RA and DEC are, similar to ra and dec , in hms and dms units respectively. Additionally, they should be subject to ICRS J2000.0. Returns: out : tuple Tuple of \\((\\beta,\\ell,b)\\) in rad. Each component is scalar if all inputs are scalars. Notes We rely on astropy.coordinates.SkyCoord in Astropy to resolve \\((\\ell,b)\\) from \\((\\alpha,\\delta)\\) and obtain \\(\\beta\\) by snorer.galactic_to_beta .","title":"equatorial_to_beta"},{"location":"api/utils/equa_to_beta/#snorerequatorial_to_beta","text":"","title":"snorer.equatorial_to_beta"},{"location":"api/utils/gal_to_beta/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } snorer.galactic_to_beta \u00b6 snorer.galactic_to_beta( l , b , GC_coord=[0,0] ) \u00b6 Transform galactic coordinate \\((\\ell,b)\\) to off-center angle \\(\\beta\\) . See Eqs. (2) in Coordinate Transformations . Parameters: l : array_like Galactic longitude, rad. b : array_like Galactic latitude, rad. GC_coord : list Galactic coordinate for arbitrary galactic center \\((\\ell_g,b_g)\\) . Default is Milky Way center GC_coord = [0,0] . Returns: out : scalar/ndarray Off-center angle \\(\\beta\\) , rad. The result is scalar if all inputs are scalars.","title":"galactic_to_beta"},{"location":"api/utils/gal_to_beta/#snorergalactic_to_beta","text":"","title":"snorer.galactic_to_beta"},{"location":"manual/advanced/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; .mono { font-family: monospace; } Advanced Topics \u00b6 We introduce some advanced usage in this document. In the following content, all equation numbers refer to BDM Physics unless specified otherwise. First, import the necessary packages: # import python packages import numpy as np import ipyparallel as ipp # import plotting package import matplotlib.pyplot as plt import matplotlib.colors as mcolors # uncomment the following two lines if you have a Hi-DPI monitor and wish to have a better figure resolution # %matplotlib inline # %config InlineBackend.figure_format='retina' # import snorer import snorer as sn print(f'Current version of snorer: {sn.__version__}') Current version of snorer: 2.0.0 Distribution across the celestial sphere \u00b6 We draw how supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) distributes across the sky. We use Cassiopeia A (Cas A) to be our SN in this example. Its \\(\\alpha\\) and \\(\\delta\\) are 23h23m24s and 58d49m00s respectively and \\(R_s\\approx 3.5\\) kpc. Hence, we obtain the off-center angle \\(\\beta\\) and its galactic coordinate by casA_beta,l_sn,b_sn = sn.equatorial_to_beta('23h23m24s','58d49m00s') print(f\"The off-center angle for Cas A approximates {casA_beta:.3f} rad.\") The off-center angle for Cas A approximates 1.950 rad. To evaluate the distribution across the sky, it is equivalent to draw \\[ \\begin{equation} \\left.\\frac{d\\Phi_\\chi}{dT_\\chi d\\Omega} = \\tau_s \\mathcal{J} j_\\chi\\right|_{t=\\frac{d}{c}+\\frac{\\ell}{v_\\chi}-t_\\nu} \\end{equation} \\] on the celestial sphere spanned by the galactic coordinate \\(\\ell\\) and \\(b\\) . The corresponding function in snorer is sn.differential_flux with 10 parameters. The first seven t , Tx , mx , theta , phi , Rs , beta are mandatory and the last three Re = 8.5 , sigxv0 = 1e-45 and is_spike = False are optional. Note that theta and phi are the zenith and azimuthal angles, cf. Fig. 1 in BDM Physics. Figure 1. Cas A and its location \\((\\ell_s,b_s)\\) on the galactic coordinate. Another point \\((\\ell_0,b_0)\\) is also labeled. Suppose Cas A locates at \\((\\ell_s,b_s)\\) on the galactic coordinate shown in Fig. 1, another point \\((\\ell_0,b_0)\\) that is distant from Cas A by \\(\\theta\\) and rotates by \\(\\varphi\\) azimuthally. We can determined them through \\[ \\begin{equation} \\theta = \\sqrt{\\ell^{\\prime 2}+b^{\\prime 2}},\\quad {\\rm and} \\quad \\varphi= \\tan^{-1}\\left(\\frac{\\ell^\\prime}{b^\\prime}\\right) \\end{equation} \\] where \\[ \\begin{equation} \\ell^\\prime = \\ell_0 - \\ell_s\\quad{\\rm and}\\quad b^\\prime = b_0-b_s. \\end{equation} \\] With \\(\\theta\\) and \\(\\varphi\\) , we further apply both to sn.differential_flux to get the differential flux. Note that we will eventually display the result using the Aitoff projection and in matplotlib such projections \\(\\ell\\in[-\\pi,\\pi)\\) , thus we define a function wrap_angle to convert \\(\\ell\\) from \\([0,2\\pi)\\) to \\([-\\pi,\\pi)\\) . The step-by-step approach is to: Construct a canvas across the entire galactic coordinate Calculate the \\((\\theta,\\varphi)\\) for every point \\((\\ell,b)\\) on the canvas Put \\((\\theta,\\varphi)\\) into sn.differential_flux and retrieve the BDM differential flux at that point def wrap_angle(l): \"\"\"Confine longitudinal in -pi and pi\"\"\" return (l + np.pi) % (2 * np.pi) - np.pi # Setup DM properties Tx,mx = 5,1 Rs = 3.5 # kpc t = 350 * sn.constant.year2Seconds # Setup canvas for galactic coordinate l and b l_vals = np.linspace(-np.pi,np.pi,800) b_vals = np.linspace(-np.pi/2,np.pi/2,400) L,B = np.meshgrid(l_vals,b_vals,indexing=\"ij\") # Evaluate dtheta and dvarphi for each grid point on the canvas L_coord = wrap_angle(L - l_sn) # adjust galactic longitude to [-pi, pi) B_coord = B - b_sn dtheta = np.sqrt(L_coord**2 + B_coord**2) dphi = np.arctan2(L_coord,B_coord)%(2 * np.pi) # using atan2 and mod 2pi to convert galactic latitude to [-pi/2, pi/2) # Canvas to store the result diffFlux = np.zeros_like(L) with np.nditer([dtheta,dphi,diffFlux],op_flags=[['readonly'],['readonly'],['writeonly']]) as it: for theta,phi,flux in it: flux[...] = sn.differential_flux(t,Tx,mx,theta,phi,Rs,casA_beta) # Plot fig = plt.figure(figsize=(12, 5)) ax = fig.add_subplot(111,projection='aitoff') norm = mcolors.SymLogNorm(linthresh=diffFlux.max()/1e2, vmin=diffFlux.max()/5e1, vmax=diffFlux.max(), base=10) mesh = ax.pcolormesh(L , B, diffFlux, cmap='inferno', norm=norm, rasterized=True) cbar = fig.colorbar(mesh, ax=ax, orientation='vertical') cbar.set_label(r\"$d\\Phi_\\chi/dtd\\Omega$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$ sr$^{-1}$]\") # axis label style ax.tick_params(axis=\"x\", colors=\"white\") ax.grid(True,linestyle='--', linewidth=0.7) # axis ticks x_ticks = np.linspace(-np.pi + np.pi/6, np.pi - np.pi/6, 11) y_ticks = np.linspace(-np.pi/2, np.pi/2, 13) ax.set_xticks(x_ticks) # set galactic longitude tick labels ax.set_xticklabels([r'\u2212150\u00b0', '\u2212120\u00b0', '\u221290\u00b0', '\u221260\u00b0', '\u221230\u00b0', '0\u00b0', '30\u00b0', '60\u00b0', '90\u00b0', '120\u00b0', '150\u00b0']) ax.set_yticks(y_ticks) # set galactic latitude tick labels ax.set_yticklabels(['\u221290\u00b0', '\u221275\u00b0', '\u221260\u00b0', '\u221245\u00b0', '\u221230\u00b0', '\u221215\u00b0', '0\u00b0', '15\u00b0', '30\u00b0', '45\u00b0', '60\u00b0', '75\u00b0', '90\u00b0']) ax.set_title(r'Cas A: $(T_\\chi,m_\\chi)=(5,1)$ MeV',y=1.1) plt.show() Note the above is a particular slice of \\(T_\\chi\\) . For practical case, one should integrate sn.differential_flux over a range of \\(T_\\chi\\) due to none of the existing detectors having infinite energy resolution. User-defined scattering amplitude \u00b6 Functions sn.flux and sn.event and the core functions to construct them are all based on energy-independent cross sections \\(\\sigma_{\\chi\\nu}\\) and \\(\\sigma_{\\chi e}\\) . However, by introducing a specific particle model, cross sections are no longer energy-independent but depend on the Mandelstam variables and model parameters. Thus, sn.flux and sn.event are not applicable. To resolve this issue, we provide a class sn.BoostedDarkMatter to cope with. This class integrate all the functions to evaluate BDM flux and event and manipulating halo properties as class methods . Additionally, this class takes scattering amplitudes for \\(\\chi\\nu\\) and \\(\\chi e\\) interactions as its parameters and calculate \\(d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}\\) and \\(\\sigma_{\\chi e}\\) automatically. We illustrate this by the famous \\(L_{\\mu-\\tau}\\) model with DM component \\(\\chi\\) . The Lagrangian is \\[ \\begin{alignat}{1} \\mathcal{L}_\\chi \\supset & -\\frac{1}{4}V_{\\mu\\nu}V^{\\mu\\nu}+\\frac{\\varepsilon}{2\\cos\\theta_W}F_{\\mu\\nu}V^{\\mu\\nu}-\\frac{1}{2}m_V^2 V_\\mu V^\\mu \\nonumber \\\\ & \\quad -m_\\chi \\bar{\\chi}\\chi +g_\\chi V_\\mu \\bar{\\chi}\\gamma^\\mu \\chi \\nonumber \\\\ & \\quad +g_V V_\\mu Q_{\\alpha\\beta}\\left(\\bar{\\ell}_\\alpha\\gamma^\\mu \\ell_\\beta +\\bar{\\nu}_\\alpha \\gamma^\\mu P_L \\nu_\\beta\\right) \\end{alignat} \\] with the first line for kinetic mixing, the second line for dark sector interaction and the last for coupling between dark and lepton sector. The associated Feynman diagrams for \\(\\chi \\nu\\) and \\(\\chi e\\) scatterings are shown in Fig. 2. Figure 2. Feynman diagrams for \\(\\chi\\nu\\) (left) and \\(\\chi e\\) (right) scatterings described by \\(L_{\\mu-\\tau}\\) model. The amplitude squared \\(|\\mathcal{M}|^2\\) is given by \\[ \\begin{equation} |\\mathcal{M}|^{2} =2\\left(\\frac{\\mathcal{Q}}{t-m_{V}^{2}}\\right)^{2}[s^{2}+u^{2} +4t(m_{1}^{2}+m_{2}^{2}) -2(m_{1}^{2}+m_{2}^{2})^{2}], \\end{equation} \\] where \\(s\\) , \\(t\\) and \\(u\\) are Mandelstam variables and \\(m_1\\) and \\(m_2\\) are incoming and being scattered particles respectively. We can encode such information into python function by def amp2_xv(s,t,u,mx) -> float: \"\"\"DM-v scattering amplitude squared\"\"\" mV = mx/3 gV,gx = 1e-06,1e-02 Q = gV*gx return (s**2 + u**2 + 4*t*(mx**2) - 2*(mx**2)**2)*(Q/(t - mV**2))**2 def amp2_xe(s,t,u,mx) -> float: \"\"\"DM-e scattering amplitude squared\"\"\" mV = mx/3 me = 0.511 # MeV gx,eps = 1e-02,1e-06 Q = gx*eps return 2*(s**2 + u**2 + 4*t*(me**2 + mx**2) - 2*(me**2 + mx**2)**2)*(Q/(t - mV**2))**2 Both functions only take 4 positioning arguments with the first three are Mandelstam variables (MeV 2 ) and the last is DM mass (MeV). Other model parameters should be defined either in the function or somewhere else. They cannot be the function input(s). We again use Cas A as the example. First, build up the instance for Cas A BDM and given it is within our Milky Way, we have \\(R_g = R_e=8.5\\) kpc. casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) There are plenty of methods can be called in the instance casA_bdm . For example, we can examine the associated \\(d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}\\) and \\(\\sigma_{\\chi e}\\) : # Differential DM-v cross sections Tx,mx = 5,1 # Get maximumlly allowed psi psi_max = sn.get_psiMax(Tx,mx) psi_max -= psi_max/1000 # avoid diverge at psi_max psi_vals = np.linspace(0,psi_max,100) # differential sigma_xv dsigxv = [casA_bdm.dsigma_xv(Tx,mx,psi) for psi in psi_vals] # Plot plt.plot(psi_vals,dsigxv) plt.yscale('log') plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}$ [cm$^2$ sr$^{-1}$]') plt.show() # Differential DM-e cross sections mx = 1 Tx_vals = np.logspace(-5,2,100) # differential sigma_xv sigxe = [casA_bdm.sigma_xe(Tx,mx) for Tx in Tx_vals] # Plot plt.plot(Tx_vals,sigxe) plt.xscale('log') plt.yscale('log') plt.xlabel(r'$T_\\chi$ [MeV]') plt.ylabel(r'$\\sigma_{\\chi e}$ [cm$^2$]') plt.show() Now we are ready to evaluate the BDM flux and event. For flux, given Cas A exploded 350 years ago, it is already 350 year-old. We have to determine the vanishing time first. # Setup DM properties Tx,mx = 5,1 Rs = 3.5 # kpc tvan = sn.get_tvan(Tx,mx,Rs) print(f'Vanishing time is {tvan/sn.constant.year2Seconds:.2f} years.') Vanishing time is 557.07 years. Hence for \\((T_\\chi,m_\\chi)=(5,1)\\) MeV, \\(t_{\\rm van}=557.07\\) years. However, 350 years have passed, leaving only 207 years atmost before it ceases completely. We can use the flux method to evaluate. It takes 3 inputs: t , Tx and mx . Additional **kwargs determine the cut distances d_cut and r_cut for SN \\(\\nu\\) spectrum and halo profile, respectively, due to both are proportional \\(1/L^n\\) and diverges when \\(L\\to 0\\) . Others like nitn and neval are for vegas . Note that this method does not contain any **kwargs related to halo profile as the halo behavior is decided during the initialization of the instance. See their API pages: sn.BoostedDarkMatter and sn.params for detail. t0 = 350 * sn.constant.year2Seconds time_vals = np.linspace(t0,tvan,70) def get_casA_flux(t,Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe): \"\"\"flux\"\"\" import snorer as sn Tx,mx = 5,1 casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) return casA_bdm.flux(t,Tx,mx,neval=5000) # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_casA_flux, time_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results casA_flux = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_casA_flux: 0%| | 0/70 [00:00<?, ?tasks/s] Stopping engine(s): 1742019912 engine set stopped 1742019912: {'engines': {'0': {'exit_code': 0, 'pid': 35213, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 35214, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 35215, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 35216, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 35217, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 35201, 'identifier': 'ipcontroller-1742019911-edc4-31540'} plt.plot(time_vals/sn.constant.year2Seconds + 1675,casA_flux) plt.yscale('log') plt.ylim(3e-16,) plt.xlabel(r'Anno Domini') plt.ylabel(r'$d\\Phi_\\chi/dT_\\chi dt$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]') plt.show() To evaluate event number, remember the parameter t_range in sn.event is the integration range of time interval and starts from \\(t_0=10\\) seconds by default. But it is not the case for Cas A as 350 years has passed. We shoud begin \\(t_0=350\\) years and end with, say, 35 years after \\(t_0\\) . Hence, mx_vals = np.logspace(-6,2,35) def get_casA_event(mx,Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe): \"\"\"flux\"\"\" import snorer as sn t0 = 350 * sn.constant.year2Seconds tf = (350 + 35) * sn.constant.year2Seconds casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) try: event = casA_bdm.event(mx,t_range=[t0,tf],neval=15000) except: event = 0 return event # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_casA_event, mx_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results casA_event = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_casA_event: 0%| | 0/35 [00:00<?, ?tasks/s] engine set stopped 1742023011: {'engines': {'1': {'exit_code': 0, 'pid': 36515, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 36516, 'identifier': '2'}, '0': {'exit_code': 0, 'pid': 36514, 'identifier': '0'}, '3': {'exit_code': 0, 'pid': 36517, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 36518, 'identifier': '4'}}, 'exit_code': 0} Stopping engine(s): 1742023069 engine set stopped 1742023069: {'engines': {'0': {'exit_code': 0, 'pid': 36594, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 36595, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 36596, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 36597, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 36598, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 36580, 'identifier': 'ipcontroller-1742023068-i421-31540'} plt.scatter(mx_vals,casA_event) plt.xscale('log') plt.yscale('log') #plt.ylim(3e-16,) plt.xlabel(r'$m_\\chi$ [MeV]') plt.ylabel(r'$N_\\chi$ per electron') plt.show() Unlike sn.event which the result is normalized to per electron and \\(\\sigma_{\\chi e}=1\\) cm 2 , in this class instance, \\(\\sigma_{\\chi e}\\) is determined by user-specified \\(|\\mathcal{M}|^2\\) , thus the cross section is exact what user expects at such energy. One only needs to multiply the correct electron number \\(N_e\\) in that detector. For example, Super-K has \\(7\\times 10^{33}\\) electrons approximately, then the BDM event is \\[ N_\\chi^{\\rm SK} = N_e^{\\rm SK} \\times N_\\chi = 7\\times 10^{33} N_\\chi \\] In the above plot, one sees that no event when \\(m_\\chi\\lesssim 500\\) keV. It is because the corresponding \\(t_{\\rm van}\\) for \\(m_\\chi\\) and \\(T_\\chi\\) -integrated range are much smaller than 350 years. Thus BDM from Cas A no longer exists at the present day. DM-nucleus scattering \u00b6 We discuss a more general case when target in the detector is not electron. Though by default sn.BoostedDarkMatter assumes \\(\\chi e\\) scattering, but the parameter amp2_xe is not exclusively for \\(\\chi e\\) interaction. To elaborate, we assume the target to be interacted is Xenon with target mass approximating \\(m_t = 1.3\\times 10^5\\) MeV. We can rewrite amp2_xe by m_xenon = 1.3e5 # xenon mass def amp2_x_xenon(s,t,u,mx) -> float: \"\"\"DM-xenon scattering amplitude squared\"\"\" mV = mx/3 mt = m_xenon # xenon mass, MeV gx,eps = 1e-02,1e-06 Q = gx*eps return 2*(s**2 + u**2 + 4*t*(mt**2 + mx**2) - 2*(mt**2 + mx**2)**2)*(Q/(t - mV**2))**2 When initialize sn.BoostedDarkMatter instance, we have to specify the target mass mt too, such as casA_bdm_xenon = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_x_xenon,mt=m_xenon,is_spike=False) Now we compare the associated \\(\\sigma_{\\chi e}\\) and \\(\\sigma_{\\chi-{\\rm Xe}}\\) , # Differential DM-e cross sections mx = 1 Tx_vals = np.logspace(-5,2,100) sigxe = [casA_bdm.sigma_xe(Tx,mx) for Tx in Tx_vals] sigx_xe = [casA_bdm_xenon.sigma_xe(Tx,mx) for Tx in Tx_vals] # Plot plt.plot(Tx_vals,sigx_xe,label=r'$\\sigma_{\\chi - {\\rm Xe}}$') plt.plot(Tx_vals,sigxe,label=r'$\\sigma_{\\chi e}$') plt.xscale('log') plt.yscale('log') plt.xlabel(r'$T_\\chi$ [MeV]') plt.ylabel(r'$\\sigma$ [cm$^2$]') plt.legend() plt.show() Thus in casA_bdm_xenon , the method sigma_xe is for DM-Xenon interaction cross section. Note that the above is a very naive example and is not plausible in practice. Given when nucleus is under discussion, nucleus form factor should be introduced in amp2_x_xenon . We relegate this to the users who work in this field. Override methods dsigma_xv and sigma_xe \u00b6 Under certain circumstances, issues and unstable results may occur in our algorithm for calculating dsigma_xv and sigma_xe . If this happens, users may wish to override these two methods with their own functions. It can be done easily, given that dsigma_xv and sigma_xe take three and two positioning arguments , respectively. See this API page . Users can provide their own functions and replace them, as long as the units for dsigma_xv and sigma_xe are cm 2 sr \u22121 and cm 2 , respectively. For example, let dsigma_xv and sigma_xe be constant # constant dsigma_xv casA_bdm.dsigma_xv = lambda Tx,mx,psi: 1e-35/4/np.pi # constant sigma_xe casA_bdm.sigma_xe = lambda Tx,mx: 1e-35 This will override the methods for calculating cross sections in casA_bdm and affect casA_bdm.flux and casA_bdm.event .","title":"Advanced Topics"},{"location":"manual/advanced/#advanced-topics","text":"We introduce some advanced usage in this document. In the following content, all equation numbers refer to BDM Physics unless specified otherwise. First, import the necessary packages: # import python packages import numpy as np import ipyparallel as ipp # import plotting package import matplotlib.pyplot as plt import matplotlib.colors as mcolors # uncomment the following two lines if you have a Hi-DPI monitor and wish to have a better figure resolution # %matplotlib inline # %config InlineBackend.figure_format='retina' # import snorer import snorer as sn print(f'Current version of snorer: {sn.__version__}') Current version of snorer: 2.0.0","title":"Advanced Topics"},{"location":"manual/advanced/#distribution-across-the-celestial-sphere","text":"We draw how supernova-neutrino-boosted dark matter (SN \\(\\nu\\) BDM) distributes across the sky. We use Cassiopeia A (Cas A) to be our SN in this example. Its \\(\\alpha\\) and \\(\\delta\\) are 23h23m24s and 58d49m00s respectively and \\(R_s\\approx 3.5\\) kpc. Hence, we obtain the off-center angle \\(\\beta\\) and its galactic coordinate by casA_beta,l_sn,b_sn = sn.equatorial_to_beta('23h23m24s','58d49m00s') print(f\"The off-center angle for Cas A approximates {casA_beta:.3f} rad.\") The off-center angle for Cas A approximates 1.950 rad. To evaluate the distribution across the sky, it is equivalent to draw \\[ \\begin{equation} \\left.\\frac{d\\Phi_\\chi}{dT_\\chi d\\Omega} = \\tau_s \\mathcal{J} j_\\chi\\right|_{t=\\frac{d}{c}+\\frac{\\ell}{v_\\chi}-t_\\nu} \\end{equation} \\] on the celestial sphere spanned by the galactic coordinate \\(\\ell\\) and \\(b\\) . The corresponding function in snorer is sn.differential_flux with 10 parameters. The first seven t , Tx , mx , theta , phi , Rs , beta are mandatory and the last three Re = 8.5 , sigxv0 = 1e-45 and is_spike = False are optional. Note that theta and phi are the zenith and azimuthal angles, cf. Fig. 1 in BDM Physics. Figure 1. Cas A and its location \\((\\ell_s,b_s)\\) on the galactic coordinate. Another point \\((\\ell_0,b_0)\\) is also labeled. Suppose Cas A locates at \\((\\ell_s,b_s)\\) on the galactic coordinate shown in Fig. 1, another point \\((\\ell_0,b_0)\\) that is distant from Cas A by \\(\\theta\\) and rotates by \\(\\varphi\\) azimuthally. We can determined them through \\[ \\begin{equation} \\theta = \\sqrt{\\ell^{\\prime 2}+b^{\\prime 2}},\\quad {\\rm and} \\quad \\varphi= \\tan^{-1}\\left(\\frac{\\ell^\\prime}{b^\\prime}\\right) \\end{equation} \\] where \\[ \\begin{equation} \\ell^\\prime = \\ell_0 - \\ell_s\\quad{\\rm and}\\quad b^\\prime = b_0-b_s. \\end{equation} \\] With \\(\\theta\\) and \\(\\varphi\\) , we further apply both to sn.differential_flux to get the differential flux. Note that we will eventually display the result using the Aitoff projection and in matplotlib such projections \\(\\ell\\in[-\\pi,\\pi)\\) , thus we define a function wrap_angle to convert \\(\\ell\\) from \\([0,2\\pi)\\) to \\([-\\pi,\\pi)\\) . The step-by-step approach is to: Construct a canvas across the entire galactic coordinate Calculate the \\((\\theta,\\varphi)\\) for every point \\((\\ell,b)\\) on the canvas Put \\((\\theta,\\varphi)\\) into sn.differential_flux and retrieve the BDM differential flux at that point def wrap_angle(l): \"\"\"Confine longitudinal in -pi and pi\"\"\" return (l + np.pi) % (2 * np.pi) - np.pi # Setup DM properties Tx,mx = 5,1 Rs = 3.5 # kpc t = 350 * sn.constant.year2Seconds # Setup canvas for galactic coordinate l and b l_vals = np.linspace(-np.pi,np.pi,800) b_vals = np.linspace(-np.pi/2,np.pi/2,400) L,B = np.meshgrid(l_vals,b_vals,indexing=\"ij\") # Evaluate dtheta and dvarphi for each grid point on the canvas L_coord = wrap_angle(L - l_sn) # adjust galactic longitude to [-pi, pi) B_coord = B - b_sn dtheta = np.sqrt(L_coord**2 + B_coord**2) dphi = np.arctan2(L_coord,B_coord)%(2 * np.pi) # using atan2 and mod 2pi to convert galactic latitude to [-pi/2, pi/2) # Canvas to store the result diffFlux = np.zeros_like(L) with np.nditer([dtheta,dphi,diffFlux],op_flags=[['readonly'],['readonly'],['writeonly']]) as it: for theta,phi,flux in it: flux[...] = sn.differential_flux(t,Tx,mx,theta,phi,Rs,casA_beta) # Plot fig = plt.figure(figsize=(12, 5)) ax = fig.add_subplot(111,projection='aitoff') norm = mcolors.SymLogNorm(linthresh=diffFlux.max()/1e2, vmin=diffFlux.max()/5e1, vmax=diffFlux.max(), base=10) mesh = ax.pcolormesh(L , B, diffFlux, cmap='inferno', norm=norm, rasterized=True) cbar = fig.colorbar(mesh, ax=ax, orientation='vertical') cbar.set_label(r\"$d\\Phi_\\chi/dtd\\Omega$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$ sr$^{-1}$]\") # axis label style ax.tick_params(axis=\"x\", colors=\"white\") ax.grid(True,linestyle='--', linewidth=0.7) # axis ticks x_ticks = np.linspace(-np.pi + np.pi/6, np.pi - np.pi/6, 11) y_ticks = np.linspace(-np.pi/2, np.pi/2, 13) ax.set_xticks(x_ticks) # set galactic longitude tick labels ax.set_xticklabels([r'\u2212150\u00b0', '\u2212120\u00b0', '\u221290\u00b0', '\u221260\u00b0', '\u221230\u00b0', '0\u00b0', '30\u00b0', '60\u00b0', '90\u00b0', '120\u00b0', '150\u00b0']) ax.set_yticks(y_ticks) # set galactic latitude tick labels ax.set_yticklabels(['\u221290\u00b0', '\u221275\u00b0', '\u221260\u00b0', '\u221245\u00b0', '\u221230\u00b0', '\u221215\u00b0', '0\u00b0', '15\u00b0', '30\u00b0', '45\u00b0', '60\u00b0', '75\u00b0', '90\u00b0']) ax.set_title(r'Cas A: $(T_\\chi,m_\\chi)=(5,1)$ MeV',y=1.1) plt.show() Note the above is a particular slice of \\(T_\\chi\\) . For practical case, one should integrate sn.differential_flux over a range of \\(T_\\chi\\) due to none of the existing detectors having infinite energy resolution.","title":"Distribution across the celestial sphere"},{"location":"manual/advanced/#user-defined-scattering-amplitude","text":"Functions sn.flux and sn.event and the core functions to construct them are all based on energy-independent cross sections \\(\\sigma_{\\chi\\nu}\\) and \\(\\sigma_{\\chi e}\\) . However, by introducing a specific particle model, cross sections are no longer energy-independent but depend on the Mandelstam variables and model parameters. Thus, sn.flux and sn.event are not applicable. To resolve this issue, we provide a class sn.BoostedDarkMatter to cope with. This class integrate all the functions to evaluate BDM flux and event and manipulating halo properties as class methods . Additionally, this class takes scattering amplitudes for \\(\\chi\\nu\\) and \\(\\chi e\\) interactions as its parameters and calculate \\(d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}\\) and \\(\\sigma_{\\chi e}\\) automatically. We illustrate this by the famous \\(L_{\\mu-\\tau}\\) model with DM component \\(\\chi\\) . The Lagrangian is \\[ \\begin{alignat}{1} \\mathcal{L}_\\chi \\supset & -\\frac{1}{4}V_{\\mu\\nu}V^{\\mu\\nu}+\\frac{\\varepsilon}{2\\cos\\theta_W}F_{\\mu\\nu}V^{\\mu\\nu}-\\frac{1}{2}m_V^2 V_\\mu V^\\mu \\nonumber \\\\ & \\quad -m_\\chi \\bar{\\chi}\\chi +g_\\chi V_\\mu \\bar{\\chi}\\gamma^\\mu \\chi \\nonumber \\\\ & \\quad +g_V V_\\mu Q_{\\alpha\\beta}\\left(\\bar{\\ell}_\\alpha\\gamma^\\mu \\ell_\\beta +\\bar{\\nu}_\\alpha \\gamma^\\mu P_L \\nu_\\beta\\right) \\end{alignat} \\] with the first line for kinetic mixing, the second line for dark sector interaction and the last for coupling between dark and lepton sector. The associated Feynman diagrams for \\(\\chi \\nu\\) and \\(\\chi e\\) scatterings are shown in Fig. 2. Figure 2. Feynman diagrams for \\(\\chi\\nu\\) (left) and \\(\\chi e\\) (right) scatterings described by \\(L_{\\mu-\\tau}\\) model. The amplitude squared \\(|\\mathcal{M}|^2\\) is given by \\[ \\begin{equation} |\\mathcal{M}|^{2} =2\\left(\\frac{\\mathcal{Q}}{t-m_{V}^{2}}\\right)^{2}[s^{2}+u^{2} +4t(m_{1}^{2}+m_{2}^{2}) -2(m_{1}^{2}+m_{2}^{2})^{2}], \\end{equation} \\] where \\(s\\) , \\(t\\) and \\(u\\) are Mandelstam variables and \\(m_1\\) and \\(m_2\\) are incoming and being scattered particles respectively. We can encode such information into python function by def amp2_xv(s,t,u,mx) -> float: \"\"\"DM-v scattering amplitude squared\"\"\" mV = mx/3 gV,gx = 1e-06,1e-02 Q = gV*gx return (s**2 + u**2 + 4*t*(mx**2) - 2*(mx**2)**2)*(Q/(t - mV**2))**2 def amp2_xe(s,t,u,mx) -> float: \"\"\"DM-e scattering amplitude squared\"\"\" mV = mx/3 me = 0.511 # MeV gx,eps = 1e-02,1e-06 Q = gx*eps return 2*(s**2 + u**2 + 4*t*(me**2 + mx**2) - 2*(me**2 + mx**2)**2)*(Q/(t - mV**2))**2 Both functions only take 4 positioning arguments with the first three are Mandelstam variables (MeV 2 ) and the last is DM mass (MeV). Other model parameters should be defined either in the function or somewhere else. They cannot be the function input(s). We again use Cas A as the example. First, build up the instance for Cas A BDM and given it is within our Milky Way, we have \\(R_g = R_e=8.5\\) kpc. casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) There are plenty of methods can be called in the instance casA_bdm . For example, we can examine the associated \\(d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}\\) and \\(\\sigma_{\\chi e}\\) : # Differential DM-v cross sections Tx,mx = 5,1 # Get maximumlly allowed psi psi_max = sn.get_psiMax(Tx,mx) psi_max -= psi_max/1000 # avoid diverge at psi_max psi_vals = np.linspace(0,psi_max,100) # differential sigma_xv dsigxv = [casA_bdm.dsigma_xv(Tx,mx,psi) for psi in psi_vals] # Plot plt.plot(psi_vals,dsigxv) plt.yscale('log') plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}$ [cm$^2$ sr$^{-1}$]') plt.show() # Differential DM-e cross sections mx = 1 Tx_vals = np.logspace(-5,2,100) # differential sigma_xv sigxe = [casA_bdm.sigma_xe(Tx,mx) for Tx in Tx_vals] # Plot plt.plot(Tx_vals,sigxe) plt.xscale('log') plt.yscale('log') plt.xlabel(r'$T_\\chi$ [MeV]') plt.ylabel(r'$\\sigma_{\\chi e}$ [cm$^2$]') plt.show() Now we are ready to evaluate the BDM flux and event. For flux, given Cas A exploded 350 years ago, it is already 350 year-old. We have to determine the vanishing time first. # Setup DM properties Tx,mx = 5,1 Rs = 3.5 # kpc tvan = sn.get_tvan(Tx,mx,Rs) print(f'Vanishing time is {tvan/sn.constant.year2Seconds:.2f} years.') Vanishing time is 557.07 years. Hence for \\((T_\\chi,m_\\chi)=(5,1)\\) MeV, \\(t_{\\rm van}=557.07\\) years. However, 350 years have passed, leaving only 207 years atmost before it ceases completely. We can use the flux method to evaluate. It takes 3 inputs: t , Tx and mx . Additional **kwargs determine the cut distances d_cut and r_cut for SN \\(\\nu\\) spectrum and halo profile, respectively, due to both are proportional \\(1/L^n\\) and diverges when \\(L\\to 0\\) . Others like nitn and neval are for vegas . Note that this method does not contain any **kwargs related to halo profile as the halo behavior is decided during the initialization of the instance. See their API pages: sn.BoostedDarkMatter and sn.params for detail. t0 = 350 * sn.constant.year2Seconds time_vals = np.linspace(t0,tvan,70) def get_casA_flux(t,Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe): \"\"\"flux\"\"\" import snorer as sn Tx,mx = 5,1 casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) return casA_bdm.flux(t,Tx,mx,neval=5000) # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_casA_flux, time_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results casA_flux = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_casA_flux: 0%| | 0/70 [00:00<?, ?tasks/s] Stopping engine(s): 1742019912 engine set stopped 1742019912: {'engines': {'0': {'exit_code': 0, 'pid': 35213, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 35214, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 35215, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 35216, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 35217, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 35201, 'identifier': 'ipcontroller-1742019911-edc4-31540'} plt.plot(time_vals/sn.constant.year2Seconds + 1675,casA_flux) plt.yscale('log') plt.ylim(3e-16,) plt.xlabel(r'Anno Domini') plt.ylabel(r'$d\\Phi_\\chi/dT_\\chi dt$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]') plt.show() To evaluate event number, remember the parameter t_range in sn.event is the integration range of time interval and starts from \\(t_0=10\\) seconds by default. But it is not the case for Cas A as 350 years has passed. We shoud begin \\(t_0=350\\) years and end with, say, 35 years after \\(t_0\\) . Hence, mx_vals = np.logspace(-6,2,35) def get_casA_event(mx,Rs=Rs,Rg=8.5,beta=casA_beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe): \"\"\"flux\"\"\" import snorer as sn t0 = 350 * sn.constant.year2Seconds tf = (350 + 35) * sn.constant.year2Seconds casA_bdm = sn.BoostedDarkMatter(Rs=Rs,Rg=8.5,beta=beta,amp2_xv=amp2_xv,amp2_xe=amp2_xe,is_spike=False) try: event = casA_bdm.event(mx,t_range=[t0,tf],neval=15000) except: event = 0 return event # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_casA_event, mx_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results casA_event = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_casA_event: 0%| | 0/35 [00:00<?, ?tasks/s] engine set stopped 1742023011: {'engines': {'1': {'exit_code': 0, 'pid': 36515, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 36516, 'identifier': '2'}, '0': {'exit_code': 0, 'pid': 36514, 'identifier': '0'}, '3': {'exit_code': 0, 'pid': 36517, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 36518, 'identifier': '4'}}, 'exit_code': 0} Stopping engine(s): 1742023069 engine set stopped 1742023069: {'engines': {'0': {'exit_code': 0, 'pid': 36594, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 36595, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 36596, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 36597, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 36598, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 36580, 'identifier': 'ipcontroller-1742023068-i421-31540'} plt.scatter(mx_vals,casA_event) plt.xscale('log') plt.yscale('log') #plt.ylim(3e-16,) plt.xlabel(r'$m_\\chi$ [MeV]') plt.ylabel(r'$N_\\chi$ per electron') plt.show() Unlike sn.event which the result is normalized to per electron and \\(\\sigma_{\\chi e}=1\\) cm 2 , in this class instance, \\(\\sigma_{\\chi e}\\) is determined by user-specified \\(|\\mathcal{M}|^2\\) , thus the cross section is exact what user expects at such energy. One only needs to multiply the correct electron number \\(N_e\\) in that detector. For example, Super-K has \\(7\\times 10^{33}\\) electrons approximately, then the BDM event is \\[ N_\\chi^{\\rm SK} = N_e^{\\rm SK} \\times N_\\chi = 7\\times 10^{33} N_\\chi \\] In the above plot, one sees that no event when \\(m_\\chi\\lesssim 500\\) keV. It is because the corresponding \\(t_{\\rm van}\\) for \\(m_\\chi\\) and \\(T_\\chi\\) -integrated range are much smaller than 350 years. Thus BDM from Cas A no longer exists at the present day.","title":"User-defined scattering amplitude"},{"location":"manual/demo/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; Demonstration \u00b6 In this page, we present three demonstrations showing how BDM evolves over time on the celestial sphere. Specifically, we display the \\( T_\\chi \\) -integrated BDM flux for \\( m_\\chi = 5 \\, \\text{keV} \\) , defined by \\begin{equation} \\frac{d\\Phi_\\chi(t)}{d\\Omega} = \\int_{T_{\\chi,\\mathrm{min}}}^{T_{\\chi,\\mathrm{max}}} \\frac{d\\Phi_\\chi(t)}{dT_\\chi\\, d\\Omega} \\end{equation} with integration ranges \\( (T_{\\chi,\\mathrm{min}}, T_{\\chi,\\mathrm{max}}) = (5, 50) \\) , \\( (300, 1000) \\) , and \\( (1, 1000) \\) keV. We assume the Milky Way (MW) core-collapse supernova (CCSN) rate is approximately 1.63 per century, and the simulation spans a total duration of 100,000 years. On average, this corresponds to about 1,630 CCSNe occurring during the simulation period. The CCSN locations are sampled from the MW baryonic density distribution, and their birth times are assumed to be uniformly distributed over the 100,000-year period. The animations below illustrate the time evolution in logarithmic time scale . The dataset containing the simulated CCSN positions and birth dates used in these animations can be downloaded here . Animations \u00b6 \\((T_{\\chi,{\\rm min}},T_{\\chi,{\\rm max}})=(5,50)~{\\rm keV}\\) \u00b6 Your browser does not suppor MP4 playback. Download video \\((T_{\\chi,{\\rm min}},T_{\\chi,{\\rm max}})=(300,1000)~{\\rm keV}\\) \u00b6 Your browser does not suppor MP4 playback. Download video \\((T_{\\chi,{\\rm min}},T_{\\chi,{\\rm max}})=(1,1000)~{\\rm keV}\\) \u00b6 Your browser does not suppor MP4 playback. Download video","title":"Demonstration"},{"location":"manual/demo/#demonstration","text":"In this page, we present three demonstrations showing how BDM evolves over time on the celestial sphere. Specifically, we display the \\( T_\\chi \\) -integrated BDM flux for \\( m_\\chi = 5 \\, \\text{keV} \\) , defined by \\begin{equation} \\frac{d\\Phi_\\chi(t)}{d\\Omega} = \\int_{T_{\\chi,\\mathrm{min}}}^{T_{\\chi,\\mathrm{max}}} \\frac{d\\Phi_\\chi(t)}{dT_\\chi\\, d\\Omega} \\end{equation} with integration ranges \\( (T_{\\chi,\\mathrm{min}}, T_{\\chi,\\mathrm{max}}) = (5, 50) \\) , \\( (300, 1000) \\) , and \\( (1, 1000) \\) keV. We assume the Milky Way (MW) core-collapse supernova (CCSN) rate is approximately 1.63 per century, and the simulation spans a total duration of 100,000 years. On average, this corresponds to about 1,630 CCSNe occurring during the simulation period. The CCSN locations are sampled from the MW baryonic density distribution, and their birth times are assumed to be uniformly distributed over the 100,000-year period. The animations below illustrate the time evolution in logarithmic time scale . The dataset containing the simulated CCSN positions and birth dates used in these animations can be downloaded here .","title":"Demonstration"},{"location":"manual/demo/#animations","text":"","title":"Animations"},{"location":"manual/emissivity/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; Emissivity \u00b6 We systematically derive the BDM emissivity \\(j_\\chi\\) , given by Eq. (13) in BDM Physics , \\begin{equation} j_\\chi = c n_\\chi \\frac{dn_\\nu}{dE_\\nu} \\frac{d\\sigma_{\\chi\\nu}}{d\\Omega} \\left( \\frac{dE_\\nu}{dT_\\chi} \\frac{v_\\chi}{c} \\right). \\end{equation} Below, we provide two approaches: one that is more familiar to particle physicists, and another that is more heuristic. All terms can be expressed in vector notations generally, but we omitt this in the following discussion for simplicity. Particle approach \u00b6 Specific number intensity \u00b6 First, recall that the particle number \\(N\\) is defined as \\[\\begin{equation} N\\equiv \\int d^3 p d^3x\\, f(x,p) \\end{equation}\\] where \\( f(x, p) \\) is the phase space distribution and \\( p \\) the particle momentum. Hence the differential particle flux is given by \\begin{equation}\\label{eq:diff_flux} d\\Phi = \\int d^3p f(x, p)v(p) = \\int dp d\\Omega\\, p^2 f(x, p)\\, v(p) \\end{equation} with \\( v \\) the particle velocity. This distribution is defined in momentum space because \\( d^3p/E \\) is Lorentz invariant, with the dispersion relation \\( E = \\sqrt{p^2 + m^2} \\) . Transforming to other phase space variables is straightforward via an appropriate Jacobian factor. From now on, we omit \\(x \\) for simplicity. We refer the integrand in Eq. \\eqref{eq:diff_flux} as the specific number intensity \\( I(p) \\) , \\begin{equation}\\label{eq:I} I(p) \\equiv p^2 f(p)v(p) = \\frac{d\\Phi}{dp d\\Omega}. \\end{equation} This quantity has the dimension of per unit momentum (energy) per unit area per steradian. Emissivity on the SN \\(\\nu\\) shell \u00b6 Since the flux equals number density times velocity, we have \\[\\begin{equation}\\label{eq:flux_I} \\frac{d \\Phi}{dp d\\Omega} = \\frac{dn}{dp d\\Omega}v(p). \\end{equation}\\] Alternatively, the flux is also defined as \\begin{equation}\\label{eq:flux_j} \\frac{d\\Phi}{dp d\\Omega} = \\int ds \\, j_\\chi \\end{equation} where \\(j_\\chi\\) is the emissivity and we only look for the component such that \\(v\\) is parallel to \\(s\\) . Combining the two expressions above, we obtain \\begin{equation}\\label{eq:jx_def} \\frac{dn}{dp d\\Omega} v = \\int ds\\, j_\\chi = v \\int dt \\, j_\\chi \\end{equation} where \\( ds = v dt \\) is used. Now, we turn to the BDM case and rewrite the relation above as \\[\\begin{equation} j_\\chi = \\frac{dn_\\chi}{dp_\\chi d\\Omega dt} . \\end{equation}\\] Here, \\(d\\Omega\\) is exclusively at the boost point B. Thus, we obtain \\[\\begin{equation}\\label{eq:jx} j_\\chi = \\frac{dn_\\chi}{dp_\\chi d\\Omega dt} = c n_\\chi(r) \\frac{dn_\\nu}{dE_\\nu} \\frac{d\\sigma_{\\chi \\nu}}{d\\Omega} \\frac{dE_\\nu}{dp_\\chi} \\end{equation}\\] and one can further convert \\( dE_\\nu/dp_\\chi \\) to \\( dE_\\nu/dT_\\chi \\) by \\[ \\frac{dT_\\chi}{dp_\\chi} = \\frac{v_\\chi}{c}. \\] Note that in the earlier step, we considered only the \\(v\\) -parallel-to- \\(\\ell\\) component, which has been accounted for in the definition of \\( d\\sigma_{\\chi\\nu}/d\\Omega \\) . Heuristic approach \u00b6 In this section, we re-derive the same expression for \\( j_\\chi \\) using a heuristic method inspired by astrophysical domain. Suppose the number of BDM particles \\( dN_\\chi \\) passing through a surface element \\( dA \\) , in a direction specified by an angle \\( \\psi \\) , is proportional to \\( dt \\) , \\( dp_\\chi \\) , \\( d\\Omega \\) , and the projected surface area element \\( \\cos\\psi\\, dA \\equiv dA_\\perp \\) . See Fig. 1 below. The proportional factor is referred to as the specific intensity \\( I_\\chi \\) . Figure 1. Overall BDM emitted at boost point B. We can therefore write \\[\\begin{equation} dN_\\chi = I_\\chi dA_\\perp d\\Omega dp_\\chi dt \\end{equation}\\] which implies \\[\\begin{equation} I_\\chi = \\frac{dN_\\chi}{dp_\\chi d\\Omega dA_\\perp dt} = \\frac{d\\Phi_\\chi}{dp_\\chi d\\Omega} \\equiv \\frac{dn_\\chi}{dp_\\chi d\\Omega} v_\\chi \\end{equation}\\] where one can verify that \\( dN_\\chi / dA_\\perp dt \\) indeed has the units of flux, and \\( n_\\chi \\) denotes the BDM number density. The radiative transfer equation implies: \\[\\begin{equation} \\frac{dI_\\chi}{ds} = -\\alpha_\\chi I_\\chi + j_\\chi \\end{equation}\\] where \\( \\alpha_\\chi \\) characterizes the absorption rate of BDM particles during propagation. However, we assume this effect is highly suppressed and thus negligible in our analysis. Therefore, we obtain \\begin{equation} I_\\chi = \\int ds\\, j_\\chi. \\end{equation} Repeating the same reasoning applied in Eq. \\eqref{eq:jx_def} then leads us directly to the desired result in Eq. \\eqref{eq:jx}.","title":"Emissivity"},{"location":"manual/emissivity/#emissivity","text":"We systematically derive the BDM emissivity \\(j_\\chi\\) , given by Eq. (13) in BDM Physics , \\begin{equation} j_\\chi = c n_\\chi \\frac{dn_\\nu}{dE_\\nu} \\frac{d\\sigma_{\\chi\\nu}}{d\\Omega} \\left( \\frac{dE_\\nu}{dT_\\chi} \\frac{v_\\chi}{c} \\right). \\end{equation} Below, we provide two approaches: one that is more familiar to particle physicists, and another that is more heuristic. All terms can be expressed in vector notations generally, but we omitt this in the following discussion for simplicity.","title":"Emissivity"},{"location":"manual/emissivity/#particle-approach","text":"","title":"Particle approach"},{"location":"manual/emissivity/#heuristic-approach","text":"In this section, we re-derive the same expression for \\( j_\\chi \\) using a heuristic method inspired by astrophysical domain. Suppose the number of BDM particles \\( dN_\\chi \\) passing through a surface element \\( dA \\) , in a direction specified by an angle \\( \\psi \\) , is proportional to \\( dt \\) , \\( dp_\\chi \\) , \\( d\\Omega \\) , and the projected surface area element \\( \\cos\\psi\\, dA \\equiv dA_\\perp \\) . See Fig. 1 below. The proportional factor is referred to as the specific intensity \\( I_\\chi \\) . Figure 1. Overall BDM emitted at boost point B. We can therefore write \\[\\begin{equation} dN_\\chi = I_\\chi dA_\\perp d\\Omega dp_\\chi dt \\end{equation}\\] which implies \\[\\begin{equation} I_\\chi = \\frac{dN_\\chi}{dp_\\chi d\\Omega dA_\\perp dt} = \\frac{d\\Phi_\\chi}{dp_\\chi d\\Omega} \\equiv \\frac{dn_\\chi}{dp_\\chi d\\Omega} v_\\chi \\end{equation}\\] where one can verify that \\( dN_\\chi / dA_\\perp dt \\) indeed has the units of flux, and \\( n_\\chi \\) denotes the BDM number density. The radiative transfer equation implies: \\[\\begin{equation} \\frac{dI_\\chi}{ds} = -\\alpha_\\chi I_\\chi + j_\\chi \\end{equation}\\] where \\( \\alpha_\\chi \\) characterizes the absorption rate of BDM particles during propagation. However, we assume this effect is highly suppressed and thus negligible in our analysis. Therefore, we obtain \\begin{equation} I_\\chi = \\int ds\\, j_\\chi. \\end{equation} Repeating the same reasoning applied in Eq. \\eqref{eq:jx_def} then leads us directly to the desired result in Eq. \\eqref{eq:jx}.","title":"Heuristic approach"},{"location":"manual/overview/","text":"window.MathJax = { tex: { tags: \"ams\" // Auto-numbering, AMS based } }; BDM Physics \u00b6 We review all the details provided in Refs. [ 1 , 2 ]. While these papers present mathematical expressions suitable for general readers, the content in this section is tailored for programming purposes. The goal of this document is not to replace Refs. [ 1 , 2 ] but to bridge the gap between traditional journal writing and the technical details required for programming. Typos and misstatements are corrected here to ensure clarity and to facilitate understanding of the subsequent Python code. General picture \u00b6 Given a non-zero cross section between DM ( \\(\\chi\\) ) and neutrino ( \\(\\nu\\) ), it is expected that SN \\(\\nu\\) can scatter with halo \\(\\chi\\) particles as they propagate outward from the explosion site. We illustrate the general setup in Fig. 1 . In this figure, the supernova (SN), galactic center (GC), and Earth are labeled as S, G, and E respectively. Figure 1. The 3D schematic of SN\\(\\nu\\)-induced BDM. In Fig. 1 , S, G, and E lie on the same plane, and a \\(\\chi\\) particle is boosted at point B on the SN \\(\\nu\\) shell. Here, \\(d\\) denotes the distance \\(\\overline{\\mathsf{SB}}\\) , \\(\\ell\\) the distance \\(\\overline{\\mathsf{BE}}\\) , \\(R_s\\) the distance between the SN and Earth, and \\(R_e\\) the distance between the GC and Earth. The DM number density at point B is given by \\(n_\\chi(r)\\) , where \\(r\\) is the radial distance from the GC to B. We adopt the NFW profile [ 3 ] for \\(n_\\chi\\) : \\[\\begin{equation} n_\\chi(r) = \\frac{\\rho_s}{m_\\chi} \\frac{1}{\\frac{r}{r_s} ( 1 + \\frac{r}{r_s} )^2} \\end{equation}\\] where \\(\\rho_s = 184\\) MeV cm \u22123 and \\(r_s = 24.4\\) kpc. Due to the spherically symmetric nature of the DM halo, there is no need to specify the orientation of the galactic plane. However, unless S lies precisely along the axis \\(\\overline{\\mathsf{GE}}\\) , the resulting BDM distribution will not be azimuthally symmetric in \\(\\varphi\\) . The angle \\(\\beta\\) quantifies the angular displacement of the SN relative to the GC, \\(\\psi\\) the scattering angle and its corresponding angular direction viewed as \\(\\theta\\) on E. These quantities are further explained in the API documentation: Positioning and Coordinate Transformations . Particle kinematics \u00b6 When a \\(\\nu\\) carries energy \\(E_\\nu\\) and scatters with a static \\(\\chi\\) at point B, the DM particle receives kinetic energy \\(T_\\chi\\) given by $$ T_\\chi = \\frac{E_\\nu^2}{E_\\nu + m_\\chi / 2} \\left( \\frac{1 + \\cos\\theta_c}{2} \\right) $$ where \\(\\theta_c\\) is the scattering angle in the center-of-mass (cm) frame (not to be confused with the \\(\\theta\\) in Fig. 1 ). Assuming \\(\\theta_c\\) is uniformly distributed in \\([0, \\pi]\\) , it can be related to the lab frame scattering angle \\(\\psi\\) by $$ \\theta_c = 2 \\tan^{-1}(\\gamma \\tan\\psi) $$ where \\(\\psi \\in [0, \\pi/2]\\) and the boost factor is defined as $$ \\gamma = \\frac{E_\\nu + m_\\chi}{\\sqrt{m_\\chi(2E_\\nu + m_\\chi)}}. $$ Thus, the differential cross section in the lab frame becomes \\begin{equation} \\frac{d\\sigma_{\\chi\\nu}}{d\\Omega_{\\rm lab}} = \\frac{1}{2\\pi} \\frac{d\\sigma_{\\chi\\nu}}{d\\cos\\psi} = \\sigma_0 \\times g_\\chi(\\psi) \\end{equation} where \\begin{equation}\\label{eq:gx} g_\\chi(\\psi) = \\frac{\\gamma^2 \\sec^3\\psi}{\\pi (1 + \\gamma^2 \\tan^2\\psi)^2} \\end{equation} is the angular distribution of the \\(\\chi\\nu\\) scattering cross section in the lab frame. One can verify that Eq. \\eqref{eq:gx} satisfies the normalization condition $$ 2\\pi \\int_0^{\\pi/2} g_\\chi(\\psi)\\, \\sin\\psi\\, d\\psi = 1 $$ and that the result is independent of \\(\\gamma\\) . When \\(d\\) , \\(\\ell\\) , and \\(R_s\\) are specified, the scattering angle \\(\\psi\\) can be determined using the law of cosines: $$ R_s^2 = d^2 + \\ell^2 - 2d\\ell \\cos(\\pi - \\psi) $$ which gives \\begin{equation}\\label{eq:geo_psi} \\psi = \\cos^{-1} \\left( \\frac{R_s^2 - d^2 - \\ell^2}{2d\\ell} \\right). \\end{equation} Constraint by positive-definite \\(E_\\nu\\) \u00b6 Note that although the valid range of \\(\\psi\\) from Eq. \\eqref{eq:geo_psi} lies in \\([0, \\pi]\\) , Eq. \\eqref{eq:gx} imposes a stronger constraint. While Eq. \\eqref{eq:geo_psi} is purely a geometric relation, Eq. \\eqref{eq:gx} arises from the kinematics of the scattering process. In fact, further analysis reveals that the true valid range for \\(\\psi\\) is even narrower. Let us consider the \\(\\chi\\nu\\) scattering in the lab frame, illustrated in Fig. 2 . Figure 2. \\(\\chi\\nu\\) scattering in lab frame. We write the four-momenta for each particle as \\[ \\begin{align*} p_{\\nu} &= (E_{\\nu}, 0, 0, E_{\\nu}), \\\\ p_{\\chi} &= (m_{\\chi}, 0, 0, 0), \\\\ p_{\\nu}^{\\prime} &= (E_{\\nu}^{\\prime}, x, y, z), \\\\ p_{\\chi}^{\\prime} &= \\left(E_{\\chi}, -|\\mathbf{p}_{\\chi}|\\sin\\psi, 0, |\\mathbf{p}_{\\chi}|\\cos\\psi \\right), \\end{align*} \\] where \\((x, y, z)\\) are irrelevant to the calculation. Assuming \\(m_\\nu = 0\\) and using the metric signature \\(g^{\\mu\\nu}=g_{\\mu\\nu} = \\mathrm{diag}(1, -1, -1, -1)\\) , relativistic kinematics gives \\[ \\begin{align*} (p_\\nu - p_\\chi^\\prime)^2 &= (p_\\chi - p_\\nu^\\prime)^2, \\\\ m_\\chi^2 - 2E_\\nu (E_\\chi - |\\mathbf{p}_{\\chi}|\\cos\\psi) &= m_\\chi^2 - 2m_\\chi E_\\nu^\\prime. \\end{align*} \\] Using the relations \\(E_\\chi = T_\\chi + m_\\chi\\) and \\(T_\\chi = E_\\nu - E_\\nu^\\prime\\) , the equation becomes \\[\\begin{equation}\\label{eq:Ev} E_\\nu = \\frac{T_\\chi m_\\chi}{|\\mathbf{p}_{\\chi}|\\cos\\psi - T_\\chi}. \\end{equation}\\] Given the BDM kinetic energy \\(T_\\chi\\) and scattering angle \\(\\psi\\) at point B, Eq. \\eqref{eq:Ev} determines the required \\(E_\\nu\\) to produce such a configuration. Since \\(E_\\nu\\) must be positive and finite, this imposes a stronger constraint: \\[\\begin{equation}\\label{eq:psi_max} |\\mathbf{p}_\\chi| \\cos\\psi - T_\\chi > 0 \\quad \\Rightarrow \\quad \\psi < \\psi_{\\rm max} := \\cos^{-1} \\left( \\frac{T_\\chi}{|\\mathbf{p}_{\\chi}|} \\right). \\end{equation}\\] It is also straightforward to derive \\[ |\\mathbf{p}_\\chi| = \\sqrt{T_\\chi (T_\\chi + 2m_\\chi)}. \\] Hence, the physically allowed range for \\(\\psi\\) is \\[\\begin{equation} \\psi \\in [0, \\psi_{\\rm max}) \\end{equation}\\] and \\(E_\\nu\\) diverges as \\(\\psi \\to \\psi_{\\rm max}\\) . Moreover, by differentiating Eq. \\eqref{eq:Ev} with respect to \\(T_\\chi\\) , we obtain \\[\\begin{equation}\\label{eq:dEv/dTx} \\frac{dE_\\nu}{dT_\\chi} = \\left( \\frac{m_\\chi}{|\\mathbf{p}_{\\chi}|\\cos\\psi - T_\\chi} \\right)^2 \\frac{T_\\chi}{|\\mathbf{p}_{\\chi}|} \\cos\\psi. \\end{equation}\\] This expression will be useful in later derivations. Dark emissivity \u00b6 The key factor is determining how many \\(\\chi\\) particles are boosted at point B. This is generally characterized by the emissivity , which has units of cm \u22123 \u202fs \u22121 , or MeV \u22121 \u202fcm \u22123 \u202fs \u22121 when expressed in terms of the energy spectrum. SN \\(\\nu\\) spectrum \u00b6 We begin by writing down the SN \\(\\nu\\) energy spectrum on the shell at distance \\(d\\) : \\begin{equation}\\label{eq:snv_spectrum} \\frac{dN_\\nu}{dE_\\nu} = \\sum_i \\frac{L_{\\nu_i}}{4\\pi d^2 \\langle E_{\\nu_i} \\rangle} E_\\nu^2 f_{\\nu_i}(E_\\nu) \\end{equation} where \\(L_{\\nu_i} = L_{\\rm tot} / 6\\) is the luminosity for each neutrino species ( \\(\\nu_{e,\\mu,\\tau}\\) and their antiparticles), and \\(f_{\\nu_i}(E_\\nu)\\) is the neutrino phase space distributin that obeys Fermi-Dirac statistics [ 4 ]: \\begin{equation} f_{\\nu_i}(E_\\nu) = \\frac{1}{F_2(\\eta_\\nu)} \\frac{1}{T_\\nu^3} \\frac{1}{e^{E_\\nu/T_\\nu - \\eta_\\nu} + 1} \\end{equation} where \\begin{equation} F_k(\\eta) = \\int_0^\\infty dx\\, \\frac{x^k}{e^{x - \\eta} + 1}. \\end{equation} We list all the numerical values for the parameters mentioned above in Tab. 1 . Parameters Values Parameters Values \\(\\langle E_{\\nu_e}\\rangle\\) 11 MeV \\(T_{\\nu_e}\\) 2.76 MeV \\(\\langle E_{\\bar{\\nu}_e}\\rangle\\) 16 MeV \\(T_{\\bar{\\nu}_e}\\) 4.01 MeV \\(\\langle E_{\\nu_x,\\bar{\\nu}_x}\\rangle\\) 25 MeV \\(T_{\\nu_x,\\bar{\\nu}_x}\\) 6.26 MeV \\(L_{\\rm tot}\\) \\(3\\times10^{52}\\) erg s \u22121 \\(\\eta_i\\) 3 Table 1. Numerical values for parameters. Suppose the duration of the SN explosion is approximately \\(\\tau_s = 10\\) s. The total energy released in the form of neutrinos from a single explosion is roughly \\(10^{53}\\) erg. Number density on the shell \u00b6 After converting erg to MeV, one can verify that Eq. \\eqref{eq:snv_spectrum}, when multiplied by \\(\\tau_s\\) , has units of MeV \u22121 \u202fcm \u22122 . Since neutrinos travel at the speed of light, the thickness of the SN \\(\\nu\\) shell can be estimated as \\(h = c \\tau_s\\) . The number density of neutrinos on the shell is then given by \\begin{equation}\\label{eq:snv_nd} \\frac{dn_\\nu}{dE_\\nu} = \\frac{dN_\\nu}{dE_\\nu} \\frac{\\tau_s}{h} = \\sum_i \\frac{L_{\\nu_i}}{4\\pi d^2 \\langle E_{\\nu_i} \\rangle c} E_\\nu^2 f_{\\nu_i}(E_\\nu). \\end{equation} One can confirm that \\(dn_\\nu/dE_\\nu\\) has units of MeV \u22121 \u202fcm \u22123 , which has the correct dimension. Emissivity on the shell \u00b6 To obtain the emissivity \\(j_\\chi\\) at point B on the SN \\(\\nu\\) shell, one simply computes $$ j_\\chi = c\\, n_\\nu\\, n_\\chi\\, \\frac{d\\sigma_{\\chi\\nu}}{d\\Omega_{\\rm lab}}, $$ which has units of cm \u22123 \u202fs \u22121 \u202fsr \u22121 , where sr \u22121 indicates per steradian. It is often more convenient to restore the energy spectrum form and express it in terms of \\(T_\\chi\\) , yielding \\begin{equation}\\label{eq:jx} j_\\chi(d, r, T_\\chi, \\psi) = c n_\\chi \\frac{dn_\\nu}{dE_\\nu} \\left( \\frac{1}{2\\pi} \\frac{d\\sigma_{\\chi\\nu}}{d\\cos\\psi} \\right) \\left( \\frac{dE_\\nu}{dT_\\chi} \\frac{v_\\chi}{c} \\right) \\end{equation} where \\(dE_\\nu / dT_\\chi\\) is given in Eq. \\eqref{eq:dEv/dTx}. The above equation describes the BDM emissivity at any point on the shell and has units of MeV \u22121 \u202fcm \u22123 \u202fs \u22121 \u202fsr \u22121 . A more detailed derivation of Eq. \\eqref{eq:jx} can be found in Emissivity . SN \\(\\nu\\) BDM flux \u00b6 When the emissivity at any point is known, one can calculate the BDM flux at Earth by integrating \\(j_\\chi\\) along the line of sight (l.o.s.) \\(\\ell\\) . Thus, cf. Figs. 1 and 3 , \\begin{equation}\\label{eq:total_Phi} \\frac{d\\Phi_\\chi}{dT_\\chi\\, d\\Omega} = \\int d\\ell\\, j_\\chi\\, \\Theta(r_\\nu - d)\\, \\Theta(d + h - r_\\nu) \\end{equation} where \\(d\\Omega\\) denotes the field-of-view (f.o.v.) centered on the SN. The two \\(\\Theta\\) functions ensure that \\(j_\\chi\\) is only non-zero within the shell. Without loss of generality, we assume \\(h \\ll d\\) , so that $$ \\Theta(r_\\nu - d)\\, \\Theta(d + h - r_\\nu) \\approx h\\, \\delta(r_\\nu - d) = c\\tau_s\\, \\delta(r_\\nu - d), $$ where \\(\\delta(x)\\) is the Dirac delta function. Thus, Eq. \\eqref{eq:total_Phi} describes the total BDM flux observable on Earth. Note that \\(\\delta(r_\\nu - d)\\) has units of [L \u22121 ], which cancels the length dimension from \\(c\\tau_s\\) . This ensures the approximation is dimensionless and self-consistent. Figure 3. BDM production on the shell with thickness \\(h\\) at a distance \\(d\\) from the SN. When \\(\\ell\\) and \\(\\theta\\) are specified, \\(j_\\chi\\) is non-zero at \\(r_\\nu\\) only if \\(d \\leq r_\\nu \\leq d + h\\). From line-of-sight to time-dependency \u00b6 However, Eq. \\eqref{eq:total_Phi} is inadequate because it does not take the DM velocity into account. Given that DM is massive, BDM cannot propagate at the same velocity as SN \\(\\nu\\) . Depending on where the \\(\\chi\\) particle is upscattered, it will arrive at Earth at different times. This results in a broadened flux-vs-time profile compared to that of the SN \\(\\nu\\) burst. BDM will arrive earlier if it was upscattered closer to Earth, and significantly later if it was upscattered farther away. To incorporate the time-dependent behavior, let the time of the SN explosion define time-zero. Then, the time required for SN \\(\\nu\\) to propagate from S to E is $$ t_\\nu = \\frac{R_s}{c}. $$ For BDM produced at point B, the arrival time at Earth is \\begin{equation}\\label{eq:tprime} t^\\prime = \\frac{d}{c} + \\frac{\\ell}{v_\\chi}, \\end{equation} where the first term accounts for the time taken by SN \\(\\nu\\) to travel from S to B, and the second term accounts for the BDM's time of flight to Earth. The BDM velocity is given by $$ v_\\chi = \\frac{\\sqrt{T_\\chi (T_\\chi + 2m_\\chi)}}{T_\\chi + m_\\chi} c. $$ By applying the law of cosines, we express \\(d\\) as \\begin{equation}\\label{eq:d} d = \\sqrt{\\ell^2 + R_s^2 - 2\\ell R_s \\cos\\theta}. \\end{equation} Taking the total differential of Eq. \\eqref{eq:tprime}, we find \\begin{equation}\\label{eq:dtprime} dt^\\prime = \\left( \\frac{\\ell - R_s \\cos\\theta}{c d} + \\frac{1}{v_\\chi} \\right) d\\ell = \\mathcal{J}^{-1} d\\ell. \\end{equation} Note that \\(\\mathcal{J}\\) has the same dimension as velocity, i.e., [L\u202fT \u22121 ]. Before recasting Eq. \\eqref{eq:total_Phi} into a time-dependent form, we first manipulate $$ c\\tau_s \\delta(r_\\nu - d) = \\tau_s \\delta\\left( \\frac{r_\\nu}{c} - \\frac{d}{c} \\right) = \\tau_s \\delta\\left( \\frac{r_\\nu}{c} - t^\\prime + \\frac{\\ell}{v_\\chi} \\right) = \\tau_s \\delta\\left( t^\\prime - \\frac{r_\\nu}{c} - \\frac{\\ell}{v_\\chi} \\right), $$ using the identity \\(\\delta(ax) = \\delta(x)/|a|\\) . Under the thin-shell approximation ( \\(h \\ll d\\) ), we write $$ d \\leq r_\\nu \\leq d + h \\approx 1 \\leq \\frac{r_\\nu}{d} \\leq 1 + \\frac{h}{d} \\quad \\Rightarrow \\quad r_\\nu \\approx d. $$ Thus, the delta function becomes $$ c\\tau_s \\delta(r_\\nu - d) \\approx \\tau_s \\delta\\left( t^\\prime - \\frac{d}{c} - \\frac{\\ell}{v_\\chi} \\right). $$ Hence, we can recast Eq. \\eqref{eq:total_Phi} from a line-of-sight integration into a time-domain integration: \\[ \\frac{d\\Phi_\\chi}{dT_\\chi d\\Omega} = \\tau_s \\int dt^\\prime\\, \\mathcal{J} j_\\chi \\delta\\left( t^\\prime - \\frac{d}{c} - \\frac{\\ell}{v_\\chi} \\right) = \\left. \\tau_s \\mathcal{J} j_\\chi \\right|_{t^\\prime = \\frac{d}{c} + \\frac{\\ell}{v_\\chi}}. \\] In the last step, the \\(\\delta\\) function constrains the integrand to be non-zero only at \\(t^\\prime = d/c + \\ell/v_\\chi\\) . Finally, we integrate over the f.o.v. as seen from Earth: \\[\\begin{equation}\\label{eq:BDM_flux} \\frac{d\\Phi_\\chi(t^\\prime)}{dT_\\chi} = \\left. \\tau_s \\int_0^{2\\pi} d\\varphi \\int_0^{\\pi/2} d\\theta\\, \\sin\\theta \\mathcal{J} j_\\chi(d, r, T_\\chi, \\psi) \\right|_{t^\\prime = \\frac{d}{c} + \\frac{\\ell}{v_\\chi}}. \\end{equation}\\] This is the time-dependent SN \\(\\boldsymbol{\\nu}\\) -induced BDM flux observed at Earth. To verify dimensional consistency: $$ \\left[ \\tau_s \\cdot d\\varphi\\, d\\theta\\, \\sin\\theta \\cdot \\mathcal{J} \\cdot j_\\chi \\right] = \\mathrm{s} \\cdot \\mathrm{sr} \\cdot \\frac{\\mathrm{cm}}{\\mathrm{s}} \\cdot \\frac{1}{\\mathrm{MeV\\;cm^3\\;s\\;sr}} = \\mathrm{MeV^{-1}\\;cm^{-2}\\;s^{-1}}, $$ showing that Eq. \\eqref{eq:BDM_flux} has the correct units for differential flux per energy. Instead of setting \\(t^\\prime = 0\\) at the moment of SN explosion, it is more convenient to shift the reference point to the arrival of SN \\(\\nu\\) at Earth: \\begin{equation}\\label{eq:t} t = t^\\prime - t_\\nu = \\frac{d}{c} + \\frac{\\ell}{v_\\chi} - t_\\nu, \\end{equation} which leads to the final expression for the observed BDM flux: \\[\\begin{equation}\\label{eq:BDM_flux_earth} \\frac{d\\Phi_\\chi(t)}{dT_\\chi} = \\left. \\tau_s \\int_0^{2\\pi} d\\varphi \\int_0^{\\pi/2} d\\theta\\, \\sin\\theta \\mathcal{J} j_\\chi(d, r, T_\\chi, \\psi) \\right|_{t = \\frac{d}{c} + \\frac{\\ell}{v_\\chi} - t_\\nu}. \\end{equation}\\] Note that the prefactor \\(\\tau_s\\) is actually redundant. We have defined $$ L_{\\rm tot} = \\frac{\\mathcal{E}_{\\rm tot}}{\\tau_s}, $$ where \\(\\mathcal{E}_{\\rm tot} \\approx 3 \\times 10^{53}\\) erg is the total energy released in the form of neutrinos (see Tab. 1 ). Hence, \\[ \\tau_s \\times L_{\\rm tot} = \\mathcal{E}_{\\rm tot}. \\] In numerical calculations, we can therefore drop the explicit factor of \\(\\tau_s\\) and replace \\(L_{\\rm tot}\\) by \\(\\mathcal{E}_{\\rm tot}\\) in Eq. \\eqref{eq:snv_spectrum}. Time-dependent feature \u00b6 Judging from Eq. \\eqref{eq:BDM_flux_earth}, it is clear that the BDM flux from an individual SN is not everlasting. The final portion of the signal arrives from the BDM particles with the longest propagation time. Hence, we define the vanishing time as $$ t_{\\rm van} = \\max \\left[ \\frac{d(\\theta)}{c} + \\frac{\\ell(\\theta)}{v_\\chi} - t_\\nu \\right]. $$ Using the law of sines (cf. Fig. 1 ), $$ \\frac{\\ell}{\\sin(\\psi - \\theta)} = \\frac{d}{\\sin\\theta} = \\frac{R_s}{\\sin\\psi}, $$ we obtain the time-delay formula \\begin{equation}\\label{eq:t_psi} t = \\frac{R_s}{c} \\frac{\\sin\\theta}{\\sin\\psi} + \\frac{R_s}{v_\\chi} \\frac{\\sin(\\psi - \\theta)}{\\sin\\psi} - t_\\nu. \\end{equation} It is evident that, for fixed \\(\\theta\\) , \\(t\\) increases monotonically with \\(\\psi \\in [0, \\pi/2]\\) . Therefore, to globally maximize \\(t\\) , we set \\(\\psi = \\psi_{\\rm max}\\) (cf. Eq. \\eqref{eq:psi_max}), which depends only on \\(T_\\chi\\) and \\(m_\\chi\\) . To find the corresponding \\(\\theta\\) that yields the maximum \\(t\\) , we solve \\begin{equation}\\label{eq:theta_maximum_t} \\frac{\\cos\\theta}{c} = \\frac{\\cos(\\psi_{\\rm max} - \\theta)}{v_\\chi}. \\end{equation} This equation can be solved numerically for \\(\\theta\\) . Suppose the solution is \\(\\theta_{\\rm MAX}\\) , then the vanishing time is given by \\begin{equation}\\label{eq:tvan} t_{\\rm van} = \\frac{d(\\theta_{\\rm MAX})}{c} + \\frac{\\ell(\\theta_{\\rm MAX})}{v_\\chi} - t_\\nu. \\end{equation} We emphasize that Eq. \\eqref{eq:tvan} provides the exact solution for \\(t_{\\rm van}\\) , and it remains valid in both the relativistic and non-relativistic regimes. In contrast, the approximation given by Eq. (13) in Ref. [ 2 ] is only suitable for the relativistic case. Field-of-view across the sky \u00b6 From the previous subsection, we learned that \\(\\theta_{\\rm MAX}\\) determines the maximum field of view f.o.v. angle at the vanishing time \\(t_{\\rm van}\\) . Now, we consider the inverse problem: given a particular time \\(t^* < t_{\\rm van}\\) , we ask what is the corresponding angular extent of the observable BDM flux. Let \\(\\theta^*_M\\) satisfy Eq. \\eqref{eq:t_psi}: \\[\\begin{equation} t^* = \\frac{R_s}{c} \\frac{\\sin\\theta^*_M}{\\sin\\psi_{\\rm max}} + \\frac{R_s}{v_\\chi} \\frac{\\sin(\\psi_{\\rm max} - \\theta^*_M)}{\\sin\\psi_{\\rm max}} - t_\\nu, \\end{equation}\\] then \\(\\theta^*_M\\) determines the maximal f.o.v. angle at observation time \\(t = t^*\\) . Thus, at any given time, the region in the sky containing non-zero BDM flux corresponds to the angular range \\begin{equation} \\theta \\in [0, \\theta^*_M). \\end{equation} References \u00b6 Y.-H. Lin et al. , Phys. Rev. Lett. 130 , 111002 (2023) Y.-H. Lin et al. , Phys. Rev. D. 108 , 083013 (2023) J. F. Navarro et al. , Astrophys. J. 462 , 563 (1996) H. Duan et al. , Phys. Rev. D 74 , 105014 (2006)","title":"BDM Physics"},{"location":"manual/overview/#bdm-physics","text":"We review all the details provided in Refs. [ 1 , 2 ]. While these papers present mathematical expressions suitable for general readers, the content in this section is tailored for programming purposes. The goal of this document is not to replace Refs. [ 1 , 2 ] but to bridge the gap between traditional journal writing and the technical details required for programming. Typos and misstatements are corrected here to ensure clarity and to facilitate understanding of the subsequent Python code.","title":"BDM Physics"},{"location":"manual/overview/#general-picture","text":"Given a non-zero cross section between DM ( \\(\\chi\\) ) and neutrino ( \\(\\nu\\) ), it is expected that SN \\(\\nu\\) can scatter with halo \\(\\chi\\) particles as they propagate outward from the explosion site. We illustrate the general setup in Fig. 1 . In this figure, the supernova (SN), galactic center (GC), and Earth are labeled as S, G, and E respectively. Figure 1. The 3D schematic of SN\\(\\nu\\)-induced BDM. In Fig. 1 , S, G, and E lie on the same plane, and a \\(\\chi\\) particle is boosted at point B on the SN \\(\\nu\\) shell. Here, \\(d\\) denotes the distance \\(\\overline{\\mathsf{SB}}\\) , \\(\\ell\\) the distance \\(\\overline{\\mathsf{BE}}\\) , \\(R_s\\) the distance between the SN and Earth, and \\(R_e\\) the distance between the GC and Earth. The DM number density at point B is given by \\(n_\\chi(r)\\) , where \\(r\\) is the radial distance from the GC to B. We adopt the NFW profile [ 3 ] for \\(n_\\chi\\) : \\[\\begin{equation} n_\\chi(r) = \\frac{\\rho_s}{m_\\chi} \\frac{1}{\\frac{r}{r_s} ( 1 + \\frac{r}{r_s} )^2} \\end{equation}\\] where \\(\\rho_s = 184\\) MeV cm \u22123 and \\(r_s = 24.4\\) kpc. Due to the spherically symmetric nature of the DM halo, there is no need to specify the orientation of the galactic plane. However, unless S lies precisely along the axis \\(\\overline{\\mathsf{GE}}\\) , the resulting BDM distribution will not be azimuthally symmetric in \\(\\varphi\\) . The angle \\(\\beta\\) quantifies the angular displacement of the SN relative to the GC, \\(\\psi\\) the scattering angle and its corresponding angular direction viewed as \\(\\theta\\) on E. These quantities are further explained in the API documentation: Positioning and Coordinate Transformations .","title":"General picture"},{"location":"manual/overview/#dark-emissivity","text":"The key factor is determining how many \\(\\chi\\) particles are boosted at point B. This is generally characterized by the emissivity , which has units of cm \u22123 \u202fs \u22121 , or MeV \u22121 \u202fcm \u22123 \u202fs \u22121 when expressed in terms of the energy spectrum.","title":"Dark emissivity"},{"location":"manual/overview/#snnu-bdm-flux","text":"When the emissivity at any point is known, one can calculate the BDM flux at Earth by integrating \\(j_\\chi\\) along the line of sight (l.o.s.) \\(\\ell\\) . Thus, cf. Figs. 1 and 3 , \\begin{equation}\\label{eq:total_Phi} \\frac{d\\Phi_\\chi}{dT_\\chi\\, d\\Omega} = \\int d\\ell\\, j_\\chi\\, \\Theta(r_\\nu - d)\\, \\Theta(d + h - r_\\nu) \\end{equation} where \\(d\\Omega\\) denotes the field-of-view (f.o.v.) centered on the SN. The two \\(\\Theta\\) functions ensure that \\(j_\\chi\\) is only non-zero within the shell. Without loss of generality, we assume \\(h \\ll d\\) , so that $$ \\Theta(r_\\nu - d)\\, \\Theta(d + h - r_\\nu) \\approx h\\, \\delta(r_\\nu - d) = c\\tau_s\\, \\delta(r_\\nu - d), $$ where \\(\\delta(x)\\) is the Dirac delta function. Thus, Eq. \\eqref{eq:total_Phi} describes the total BDM flux observable on Earth. Note that \\(\\delta(r_\\nu - d)\\) has units of [L \u22121 ], which cancels the length dimension from \\(c\\tau_s\\) . This ensures the approximation is dimensionless and self-consistent. Figure 3. BDM production on the shell with thickness \\(h\\) at a distance \\(d\\) from the SN. When \\(\\ell\\) and \\(\\theta\\) are specified, \\(j_\\chi\\) is non-zero at \\(r_\\nu\\) only if \\(d \\leq r_\\nu \\leq d + h\\).","title":"SN\\(\\nu\\) BDM flux"},{"location":"manual/tutorial/","text":"Tutorial \u00b6 In this tutorial, we briefly introduce the basic usage of snorer , from the basic functions related to supernova (SN) flux, and boosted dark matter (BDM) flux and event calculations, etc. This tutorial is not meant for a complete guide for all classses and functions, but a portal to utilize the most important feature for physics calculation. For how to manipulate DM halo, we refer to their API description pages: snorer.HaloSpike and snorer.nx . To have a full description of every functions, we refer the users to API document. In the following content, all equation numbers are referred to BDM Physics unless specified otherwise. We begin with importing snorer and other useful packages in this tutorial. We use ipyparallel to manifest multiprocessing feature on jupyter for Mac/Windows users. For linux users, they can simply use multiprocessing . # import python packages import numpy as np import ipyparallel as ipp # import plotting package import matplotlib.pyplot as plt import matplotlib.colors as mcolors # uncomment the following two lines if you have a Hi-DPI monitor and wish to have a better figure resolution # %matplotlib inline # %config InlineBackend.figure_format='retina' # import snorer import snorer as sn print(f'Current version of snorer: {sn.__version__}') Current version of snorer: 2.0.0 The SN \\(\\nu\\) spectrum \u00b6 The SN \\(\\nu\\) spectrum is shown in Eq. (9) and the corresponding function in snorer is sn.sn_nu_spectrum . It takes four arguments where the first two Ev and d are necessary. They indicate the SN \\(\\nu\\) energy, in MeV, and the flux at distance \\(d\\) to the SN explosion site. The last two d_trunct and is_density are optional. When \\(d\\to 0\\) , Eq. (9) diverges, one has to set a truncation point. The default is \\(3.24\\times 10^{-15}\\) kpc which roughly corresponds to 100 km and is the size of neutrino sphere. is_density is to change the output to density unit, see Eq. (12). # Neutrino energy Ev_vals = np.logspace(-3,2,100) # Distance to the explosion site d_vals = np.logspace(-16,2,200) # Setup meshgrid for (Ev,d) plane Ev,D = np.meshgrid(Ev_vals,d_vals,indexing='ij') # Evaluate SNv flux DNvDEv = sn.sn_nu_spectrum(Ev,D) # Plot fig, ax = plt.subplots() # log-scaler color norm = mcolors.LogNorm(vmin=DNvDEv.min()+1, vmax=DNvDEv.max()) # Contour plot contour = ax.contourf(Ev, D, DNvDEv, levels=20, cmap=\"viridis\", norm=norm) ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel(r'$E_\\nu$ [MeV]') ax.set_ylabel(r'$d$ [kpc]') # Color bar cbar = fig.colorbar(contour, ax=ax) cbar.set_label(r\"$dN_\\nu/dE_\\nu$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]\") plt.show() The differential DM- \\(\\nu\\) cross section \u00b6 How DM distributes in lab-frame angular direction after boosted by \\(\\nu\\) is desecribed by Eq. (2). Given its energy indpendency, we assume the total cross section, after integrating over solid angle, is \\(\\sigma_0\\) . The differential case is just \\(\\sigma_0 \\times g_\\chi\\) . The corresponding function is sn.dsigma_xv and it takes four parameters. The first three are Ev , mx and psi , the incoming neutrino energy (MeV), DM mass (MeV) and lab frame scattering angle (rad). The last one sigxv0 is \\(\\sigma_0\\) and by default is 10 \u221245 cm 2 . # Neutrino energy, mx values and psi range Ev = 10 mx_vals = np.logspace(-3,0,4) sigma0 = 1e-35 psi_vals = np.linspace(0,np.pi/2,500) for mx in mx_vals: # differential cross section diff_sigma0 = sn.dsigma_xv(Ev,mx,psi_vals,sigxv0 = sigma0) # make plot plt.plot(psi_vals,diff_sigma0,label=fr'$m_\\chi={1000*mx:.0f}$ keV') plt.yscale('log') plt.legend() plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}$ [cm$^2$ sr$^{-1}$]') plt.show() One can also compare with sn.get_gx because sn.dsigma_xv = sigxv0 * sn.get_gx . Note that the plot in sn.get_gx page, we have weighted the result by \\(d\\Omega=2\\pi \\sin\\psi\\) . It explains the numerics is 0 at \\(\\psi=0\\) . Evaluating SN \\(\\nu\\) BDM \u00b6 Flux at Earth \u00b6 The SN \\(\\nu\\) BDM flux at Earth is given by Eq. (18), which has been integrated over the sky that contains non-zero BDM. The corresponding function is sn.flux and takes 8 parameters and **kwargs . The first 5 are t , Tx , mx , Rs and beta that indicate the time of arrival at Earth, relative to SN \\(\\nu\\) 's arrival at Earth, the BDM kinetic energy (MeV), the BDM mass (MeV), the distance to SN (kpc) and the off-center angle (rad). The rest 3 optional are Re = 8.5 , sigxv0 = 1e-45 and is_density = False . Re is the distance to galactic center and is_density determines whether the halo spike should be included. For additional keyword arguments, see pages for sn.flux and sn.params . Additionally, BDM flux only lasts unitil \\(t=t_{\\rm van}\\) , see Eq. (23). To evaluate the time-dependent flux, \\(t>t_{\\rm van}\\) is meaningless as the flux is 0. We can obtain the maximum time to be calculated at first by sn.get_tvan . It takes three inputs Tx , mx and Rs . For example, let's assume there is a SN at \\((R_s,\\beta)=(9.9\\,{\\rm kpc},0.33\\,{\\rm rad})\\) and BDM has \\((T_\\chi,m_\\chi)=(10,0.1)\\) MeV: # SN location Rs, beta = 9.9, 0.33 # kpc, rad # BDM properties Tx, mx = 10, 0.1 # MeV # Get vanishing time tvan = sn.get_tvan(Tx,mx,Rs) print(f'Vanishing time is {tvan/sn.constant.year2Seconds:.2f} years.') # convert from seconds to years Vanishing time is 80.61 years. For a particular time, say \\(t=23\\) years, one can set t = 23 * sn.constant.year2Seconds bdmflux = sn.flux(t,Tx,mx,Rs,beta) print(f'BDM flux at {t/sn.constant.year2Seconds:.2f} is {bdmflux:.4e} /MeV/cm^2/s.') BDM flux at 23.00 is 5.5491e-18 /MeV/cm^2/s. Now we can construct the time-dependent BDM flux, say from \\(t=0\\) to \\(t=80.61\\) years. In sn.flux we use vegas to perform the multidimension integral Eq. (18). Hence we use ipyparallel to utilize the multiprocessing computing on Mac/Windows jupyter notebook. # Define a function for multiprocessing flux evaluation by ipyparallel def get_flux(t): from snorer import flux Rs, beta = 9.9, 0.33 # kpc, rad Tx, mx = 10, 0.1 # MeV return flux(t,Tx,mx,Rs,beta) # Time steps time_vals = np.logspace(1,np.log10(tvan),50) # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_flux, time_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results bdmflux_time = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_flux: 0%| | 0/50 [00:00<?, ?tasks/s] Stopping engine(s): 1741921266 engine set stopped 1741921266: {'engines': {'0': {'exit_code': 0, 'pid': 5889, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 5890, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 5891, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 5892, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 5893, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 5876, 'identifier': 'ipcontroller-1741921265-4v3e-2996'} # Plot plt.plot(time_vals/sn.constant.year2Seconds,bdmflux_time) plt.xscale('log') plt.yscale('log') plt.ylim(5e-19,2e-17) plt.xlabel(r'$t$ [years]') plt.ylabel(r'$d\\Phi_\\chi/dT_\\chi dt$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]') plt.show() Event at Earth \u00b6 We call function sn.event to evaluate the BDM event \\(N_\\chi\\) at Earth. It's simply \\[ N_\\chi =N_e \\sigma_{\\chi e} \\int_{t_{\\rm min}}^{t_{\\rm max}} dt\\int_{T_{\\chi,{\\rm min}}}^{T_{\\chi,{\\rm max}}}dT_\\chi \\frac{d\\Phi_\\chi}{dT_\\chi dt} \\] It takes 8 inputs and **kwargs . The first three mx , Rs and beta are necessary. The last five Re , Tx_range , t_range , sigxv0 and is_spike are optional. By default Tx_range = [5,30] is the \\(T_\\chi\\) -integration range (MeV) and t_range = [10,1.1045e+09] is the time-integration range (seconds). The default \\(t_{\\rm max}\\) approximates 35 years. Note that the function will automatically truncate \\(t_{\\rm max}\\) at \\(t_{\\rm van}\\) if the user-input \\(t_{\\rm max}\\) is greater than \\(t_{\\rm van}\\) . Note that sn.event is normalized to \\(N_e = 1\\) , the electron number, and \\(\\sigma_{\\chi e}=1\\) cm 2 , the DM-electron cross section. One can easily scale the result to a detector with arbitrary number of \\(N_e\\) and \\(\\sigma_{\\chi e}=1\\) . # Define a function for multiprocessing event evaluation by ipyparallel def get_event(mx): from snorer import event Rs, beta = 8.5, 0.0 # kpc, rad return event(mx,Rs,beta,r_cut=1e-5,neval=30000) # increasing the evaluation number in each MCMC chain in vegas # DM mass to be evaluated mx_vals = np.logspace(-6,2,35) # request a cluster with ipp.Cluster(n = 5) as rc: # 5 cores # get a view on the cluster view = rc.load_balanced_view() # submit the tasks asyncresult = view.map_async(get_event, mx_vals) # wait interactively for results asyncresult.wait_interactive() # retrieve actual results bdmevent_mx = asyncresult.get() Starting 5 engines with <class 'ipyparallel.cluster.launcher.LocalEngineSetLauncher'> 0%| | 0/5 [00:00<?, ?engine/s] get_event: 0%| | 0/35 [00:00<?, ?tasks/s] engine set stopped 1741928354: {'engines': {'0': {'exit_code': 0, 'pid': 9398, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 9399, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 9400, 'identifier': '2'}, '4': {'exit_code': 0, 'pid': 9402, 'identifier': '4'}, '3': {'exit_code': 0, 'pid': 9401, 'identifier': '3'}}, 'exit_code': 0} Stopping engine(s): 1741928391 engine set stopped 1741928391: {'engines': {'0': {'exit_code': 0, 'pid': 9444, 'identifier': '0'}, '1': {'exit_code': 0, 'pid': 9445, 'identifier': '1'}, '2': {'exit_code': 0, 'pid': 9446, 'identifier': '2'}, '3': {'exit_code': 0, 'pid': 9447, 'identifier': '3'}, '4': {'exit_code': 0, 'pid': 9448, 'identifier': '4'}}, 'exit_code': 0} Stopping controller Controller stopped: {'exit_code': 0, 'pid': 9432, 'identifier': 'ipcontroller-1741928390-sv9q-2996'} Assume \\(N_e=3\\times 10^{33}\\) and \\(\\sigma_{\\chi e}=10^{-35}\\) cm 2 : Ne = 1e33 sigxe = 1e-35 bdmevent_mx = np.array(bdmevent_mx) * Ne * sigxe # Plot plt.scatter(mx_vals,bdmevent_mx) plt.xscale('log') plt.yscale('log') #plt.ylim(5e-19,2e-17) plt.xlabel(r'$m_\\chi$ [MeV]') plt.ylabel(r'$N_\\chi$') plt.show() More about **kwargs in sn.flux and sn.event \u00b6 We elaborate the optional parameters contained in **kwargs for both sn.flux and sn.event . Practically, they determine the DM halo shape ( sn.params.halo and sn.params.spike ) and control vegas algortihm ( sn.params.vegas ). See its API page for detail. For halo related **kwargs , if sets is_spike = False , then only three are avalaible: rhos : Characteristic denisty, MeV cm -3 . rs : Characteristic length, kpc. n : Halo profile slope. If is_spike = True , then there are five additional **kwargs will be activated: mBH : Supermassive black hole (SMBH) mass, \\(M_\\odot\\) . tBH : SMBH age, years. rh : SMBH influence radius, kpc. alpha : Spike slope, string type, only two options: '3/2' and '7/3' . sigv : DM annihilation cross section in the unit of 10 -26 cm 3 s -1 . For example, if we wish to have \\(\\langle \\sigma v\\rangle = 3\\times 10^{-26}\\) cm 3 s -1 , we simply set sigv = 3 . If one sets is_spike = False and typing any of the above **kwargs for spiky halo, ValueError will appear. Now if we want to evaluate a galaxy similar to our Milky Way but \\(\\rho_s=100\\) and \\(n=3.3\\) . Also we wish to have spike feature, such as SMBH mass is \\(10^7~M_\\odot\\) and strong annihilation such that \\(\\langle \\sigma v\\rangle = 13\\times 10^{-26}\\) . We can then set # Halo setup rhos, n = 100, 3.3 mBH, sigv = 1e7, 13 # SN location Rs, beta = 9.9, 0.33 # kpc, rad # BDM properties Tx, mx = 10, 0.1 # MeV # Flux t = 15*sn.constant.year2Seconds bdmflux_customized = sn.flux(t,Tx,mx,Rs,beta,is_spike=True,mBH=mBH,sigv=sigv,neval=15000) print(bdmflux_customized) 6.6134929121434916e-18 Coordinate transform and SN in arbitrary distant galaxy \u00b6 snorer also provides functions for converting galactic and equatorial coordinates into off-center angle \\(\\beta\\) , see Coordinate Transoformation for discussion. This aids us to compute those SNe documented in SRcat . For example, the Crab Neubla has \\((\\alpha,\\delta)= (05{\\rm h}34{\\rm m}31{\\rm s}, 22{\\rm d}01{\\rm m}00{\\rm s})\\) in equatorial coordinate based on ICRS J2000.0 frame. We can obtain \\(\\beta\\) by sn.equatorial_to_beta . This function takes three inputs and the first two are ra and dec in string type which correspond to \\(\\alpha\\) and \\(\\delta\\) of the SN to be investigated. The third one GC_coord is optional. Default None will automatically refer to Milky Way center. If you have your own prefer galaxy to be studied, please specifiy as GC = [gc_ra,gc_dec] where gc_ra and gc_dec are the equatorial coordinate of the galactic center. Additionally, sn.equatorial_to_beta will output a tuple contains three values \\((\\beta,\\ell,b)\\) where the last two indicate the galactic coordinate \\(\\ell\\) and \\(b\\) of SN. # Coordinate crab_ra, crab_dec = '05h34m31s', '22d01m00s' crab_beta,_,_ = sn.equatorial_to_beta(crab_ra,crab_dec) print(f'Off-center angle of Crab Neubla is {crab_beta:.3e} rad.') Off-center angle of Crab Neubla is 3.013e+00 rad. Now we show a case where SN is not in the Milky Way, the SN1987a, which located in Large Magellanic Cloud. There locations are given in # Print LMC coordinate: ra,dec,dist print(sn.constant.LMC_coord) # Print SN1987a coordinate: ra,dec,dist print(sn.constant.SN1987a_coord) ['05h23m34.5264s', '-69d45m22.053s', 49.97] ['05h35m27.8733s', '-69d16m10.478s', 51.4] Hence to get \\(\\beta\\) , we do SN1987a_ra,SN1987a_dec,Rs = sn.constant.SN1987a_coord LMC_ra,LMC_dec,Rg = sn.constant.LMC_coord sn1987a_beta,_,_ = sn.equatorial_to_beta(SN1987a_ra,SN1987a_dec,GC_coord=[LMC_ra,LMC_dec]) To evaluate event, we still use sn.event but have to specify Re by Rg because the default Re = 8.5 implies the distance between Earth and Milky Way center. mx = 0.5 beta = 0.0 # kpc, rad SN1987a_event = sn.event(mx,Rs,beta,Re=Rg,r_cut=1e-5,neval=30000) SN1987a_event *= (Ne * sigxe) # Assuming Ne and sigma_xe follow previously print(f'BDM event from SN1987a in LMC is {SN1987a_event:.3e}.') BDM event from SN1987a in LMC is 8.512e-13.","title":"Tutorial"},{"location":"manual/tutorial/#tutorial","text":"In this tutorial, we briefly introduce the basic usage of snorer , from the basic functions related to supernova (SN) flux, and boosted dark matter (BDM) flux and event calculations, etc. This tutorial is not meant for a complete guide for all classses and functions, but a portal to utilize the most important feature for physics calculation. For how to manipulate DM halo, we refer to their API description pages: snorer.HaloSpike and snorer.nx . To have a full description of every functions, we refer the users to API document. In the following content, all equation numbers are referred to BDM Physics unless specified otherwise. We begin with importing snorer and other useful packages in this tutorial. We use ipyparallel to manifest multiprocessing feature on jupyter for Mac/Windows users. For linux users, they can simply use multiprocessing . # import python packages import numpy as np import ipyparallel as ipp # import plotting package import matplotlib.pyplot as plt import matplotlib.colors as mcolors # uncomment the following two lines if you have a Hi-DPI monitor and wish to have a better figure resolution # %matplotlib inline # %config InlineBackend.figure_format='retina' # import snorer import snorer as sn print(f'Current version of snorer: {sn.__version__}') Current version of snorer: 2.0.0","title":"Tutorial"},{"location":"manual/tutorial/#the-snnu-spectrum","text":"The SN \\(\\nu\\) spectrum is shown in Eq. (9) and the corresponding function in snorer is sn.sn_nu_spectrum . It takes four arguments where the first two Ev and d are necessary. They indicate the SN \\(\\nu\\) energy, in MeV, and the flux at distance \\(d\\) to the SN explosion site. The last two d_trunct and is_density are optional. When \\(d\\to 0\\) , Eq. (9) diverges, one has to set a truncation point. The default is \\(3.24\\times 10^{-15}\\) kpc which roughly corresponds to 100 km and is the size of neutrino sphere. is_density is to change the output to density unit, see Eq. (12). # Neutrino energy Ev_vals = np.logspace(-3,2,100) # Distance to the explosion site d_vals = np.logspace(-16,2,200) # Setup meshgrid for (Ev,d) plane Ev,D = np.meshgrid(Ev_vals,d_vals,indexing='ij') # Evaluate SNv flux DNvDEv = sn.sn_nu_spectrum(Ev,D) # Plot fig, ax = plt.subplots() # log-scaler color norm = mcolors.LogNorm(vmin=DNvDEv.min()+1, vmax=DNvDEv.max()) # Contour plot contour = ax.contourf(Ev, D, DNvDEv, levels=20, cmap=\"viridis\", norm=norm) ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel(r'$E_\\nu$ [MeV]') ax.set_ylabel(r'$d$ [kpc]') # Color bar cbar = fig.colorbar(contour, ax=ax) cbar.set_label(r\"$dN_\\nu/dE_\\nu$ [MeV$^{-1}$ cm$^{-2}$ s$^{-1}$]\") plt.show()","title":"The SN\\(\\nu\\) spectrum"},{"location":"manual/tutorial/#the-differential-dm-nu-cross-section","text":"How DM distributes in lab-frame angular direction after boosted by \\(\\nu\\) is desecribed by Eq. (2). Given its energy indpendency, we assume the total cross section, after integrating over solid angle, is \\(\\sigma_0\\) . The differential case is just \\(\\sigma_0 \\times g_\\chi\\) . The corresponding function is sn.dsigma_xv and it takes four parameters. The first three are Ev , mx and psi , the incoming neutrino energy (MeV), DM mass (MeV) and lab frame scattering angle (rad). The last one sigxv0 is \\(\\sigma_0\\) and by default is 10 \u221245 cm 2 . # Neutrino energy, mx values and psi range Ev = 10 mx_vals = np.logspace(-3,0,4) sigma0 = 1e-35 psi_vals = np.linspace(0,np.pi/2,500) for mx in mx_vals: # differential cross section diff_sigma0 = sn.dsigma_xv(Ev,mx,psi_vals,sigxv0 = sigma0) # make plot plt.plot(psi_vals,diff_sigma0,label=fr'$m_\\chi={1000*mx:.0f}$ keV') plt.yscale('log') plt.legend() plt.xlabel(r'$\\psi$ [rad]') plt.ylabel(r'$d\\sigma_{\\chi\\nu}/d\\Omega_{\\rm lab}$ [cm$^2$ sr$^{-1}$]') plt.show() One can also compare with sn.get_gx because sn.dsigma_xv = sigxv0 * sn.get_gx . Note that the plot in sn.get_gx page, we have weighted the result by \\(d\\Omega=2\\pi \\sin\\psi\\) . It explains the numerics is 0 at \\(\\psi=0\\) .","title":"The differential DM-\\(\\nu\\) cross section"},{"location":"manual/tutorial/#evaluating-snnu-bdm","text":"","title":"Evaluating SN\\(\\nu\\) BDM"},{"location":"manual/tutorial/#coordinate-transform-and-sn-in-arbitrary-distant-galaxy","text":"snorer also provides functions for converting galactic and equatorial coordinates into off-center angle \\(\\beta\\) , see Coordinate Transoformation for discussion. This aids us to compute those SNe documented in SRcat . For example, the Crab Neubla has \\((\\alpha,\\delta)= (05{\\rm h}34{\\rm m}31{\\rm s}, 22{\\rm d}01{\\rm m}00{\\rm s})\\) in equatorial coordinate based on ICRS J2000.0 frame. We can obtain \\(\\beta\\) by sn.equatorial_to_beta . This function takes three inputs and the first two are ra and dec in string type which correspond to \\(\\alpha\\) and \\(\\delta\\) of the SN to be investigated. The third one GC_coord is optional. Default None will automatically refer to Milky Way center. If you have your own prefer galaxy to be studied, please specifiy as GC = [gc_ra,gc_dec] where gc_ra and gc_dec are the equatorial coordinate of the galactic center. Additionally, sn.equatorial_to_beta will output a tuple contains three values \\((\\beta,\\ell,b)\\) where the last two indicate the galactic coordinate \\(\\ell\\) and \\(b\\) of SN. # Coordinate crab_ra, crab_dec = '05h34m31s', '22d01m00s' crab_beta,_,_ = sn.equatorial_to_beta(crab_ra,crab_dec) print(f'Off-center angle of Crab Neubla is {crab_beta:.3e} rad.') Off-center angle of Crab Neubla is 3.013e+00 rad. Now we show a case where SN is not in the Milky Way, the SN1987a, which located in Large Magellanic Cloud. There locations are given in # Print LMC coordinate: ra,dec,dist print(sn.constant.LMC_coord) # Print SN1987a coordinate: ra,dec,dist print(sn.constant.SN1987a_coord) ['05h23m34.5264s', '-69d45m22.053s', 49.97] ['05h35m27.8733s', '-69d16m10.478s', 51.4] Hence to get \\(\\beta\\) , we do SN1987a_ra,SN1987a_dec,Rs = sn.constant.SN1987a_coord LMC_ra,LMC_dec,Rg = sn.constant.LMC_coord sn1987a_beta,_,_ = sn.equatorial_to_beta(SN1987a_ra,SN1987a_dec,GC_coord=[LMC_ra,LMC_dec]) To evaluate event, we still use sn.event but have to specify Re by Rg because the default Re = 8.5 implies the distance between Earth and Milky Way center. mx = 0.5 beta = 0.0 # kpc, rad SN1987a_event = sn.event(mx,Rs,beta,Re=Rg,r_cut=1e-5,neval=30000) SN1987a_event *= (Ne * sigxe) # Assuming Ne and sigma_xe follow previously print(f'BDM event from SN1987a in LMC is {SN1987a_event:.3e}.') BDM event from SN1987a in LMC is 8.512e-13.","title":"Coordinate transform and SN in arbitrary distant galaxy"}]}